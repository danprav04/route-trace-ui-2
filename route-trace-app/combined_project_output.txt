--- Project Tree ---

route-trace-app/
├── public
│   ├── index.html
│   ├── manifest.json
│   └── robots.txt
├── src
│   ├── components
│   │   ├── Auth
│   │   │   └── LoginForm.jsx
│   │   ├── Common
│   │   │   ├── ErrorMessage.jsx
│   │   │   ├── LoadingSpinner.jsx
│   │   │   ├── Navbar.jsx
│   │   │   └── Sidebar.jsx
│   │   ├── Comparison
│   │   │   ├── ComparisonItem.jsx
│   │   │   ├── ComparisonSelector.jsx
│   │   │   └── HistoryRouteVisualizer.jsx
│   │   ├── History
│   │   │   ├── HistoryItem.jsx
│   │   │   └── HistoryList.jsx
│   │   └── RouteTrace
│   │       ├── DirectRouteTraceInputForm.jsx
│   │       ├── DirectRouteTraceSection.jsx
│   │       ├── DirectRouteVisualizer.jsx
│   │       ├── HopDisplay.jsx
│   │       ├── MacTraceDisplay.jsx
│   │       ├── MacTraceInputForm.jsx
│   │       ├── MacTraceSection.jsx
│   │       ├── MacTraceVisualizer.jsx
│   │       ├── RouteComparisonContainer.jsx
│   │       ├── RouteInputForm.jsx
│   │       ├── RouteTraceSection.jsx
│   │       └── RouteVisualizer.jsx
│   ├── hooks
│   │   └── useAuth.js
│   ├── pages
│   │   ├── AllRoutesPage.jsx
│   │   ├── ComparisonPage.jsx
│   │   ├── DirectRouteTracePage.jsx
│   │   ├── HistoryPage.jsx
│   │   ├── LoginPage.jsx
│   │   ├── MacTracePage.jsx
│   │   ├── NotFoundPage.jsx
│   │   └── RouteTracePage.jsx
│   ├── services
│   │   ├── api.js
│   │   ├── authService.js
│   │   └── routeService.js
│   ├── store
│   │   ├── slices
│   │   │   ├── authSlice.js
│   │   │   ├── directRouteSlice.js
│   │   │   ├── historySlice.js
│   │   │   ├── macTraceSlice.js
│   │   │   └── routeTraceSlice.js
│   │   └── store.js
│   ├── utils
│   │   └── formatters.js
│   ├── App.css
│   ├── App.js
│   ├── App.test.js
│   ├── index.css
│   ├── index.js
│   ├── reportWebVitals.js
│   ├── setupTests.js
│   └── theme.js
├── .gitignore
├── combine_project.js
├── package.json
└── README.md


--- File Contents ---

// ----- File: .gitignore -----

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*


// ----- End File: .gitignore -----

// ----- File: README.md -----

# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: [https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

### Analyzing the Bundle Size

This section has moved here: [https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

### Making a Progressive Web App

This section has moved here: [https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

### Advanced Configuration

This section has moved here: [https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

### Deployment

This section has moved here: [https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

### `npm run build` fails to minify

This section has moved here: [https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)


// ----- End File: README.md -----

// ----- File: combine_project.js -----

const fs = require('fs');
const path = require('path');

// --- Configuration ---

// Directories to completely ignore
const EXCLUDED_DIRS = [
    'node_modules',
    '.git',
    'build',
    'coverage',
    '.vscode',
    '.idea',
    '. Caches' // Example for specific tools
];

// Specific files to ignore
const EXCLUDED_FILES = [
    'package-lock.json',
    'yarn.lock',
    '.env',
    '.DS_Store'
];

// File extensions to ignore (lower-cased)
const EXCLUDED_EXTENSIONS = [
    '.png', '.jpg', '.jpeg', '.gif', '.bmp', '.tiff', '.webp', // Images
    '.svg', // SVGs can be code, but often treated as assets in CRA
    '.ico', // Favicon
    '.woff', '.woff2', '.ttf', '.eot', // Fonts
    '.mp4', '.mov', '.avi', // Videos
    '.mp3', '.wav', // Audio
    '.map', // Source maps
    '.pdf', '.doc', '.docx', '.xls', '.xlsx', // Documents
    '.zip', '.gz', '.tar' // Archives
];

// File extensions to *include* (if not excluded elsewhere). Add more if needed.
// If empty, all non-excluded extensions will be included.
// Useful if you *only* want specific source types.
const INCLUDED_EXTENSIONS = [
    // '.js', '.jsx', '.ts', '.tsx', // Javascript/Typescript
    // '.css', '.scss', '.sass', '.less', '.module.css', // Stylesheets
    // '.json', // Config files, data
    // '.html', // HTML files (like public/index.html)
    // '.md' // Markdown
]; // Leave empty to include *all* non-excluded files

const OUTPUT_FILE = 'combined_project_output.txt';

// --- Helper Functions ---

function isExcluded(relativePath, stats) {
    const baseName = path.basename(relativePath);
    const ext = path.extname(baseName).toLowerCase();

    if (stats.isDirectory()) {
        return EXCLUDED_DIRS.includes(baseName);
    }

    if (EXCLUDED_FILES.includes(baseName)) {
        return true;
    }

    if (EXCLUDED_EXTENSIONS.includes(ext)) {
        return true;
    }

    // If INCLUDED_EXTENSIONS is specified, *only* include those
    if (INCLUDED_EXTENSIONS.length > 0 && !INCLUDED_EXTENSIONS.includes(ext)) {
        return true;
    }


    return false;
}

// --- Tree Generation ---

function generateTree(dir, rootDir, prefix = '', includedFiles) {
    let tree = '';
    try {
        const entries = fs.readdirSync(dir, { withFileTypes: true });
        const filteredEntries = entries
            .filter(entry => {
                 // Always check exclusion based on the *full* relative path from the root
                const entryRelativePath = path.relative(rootDir, path.join(dir, entry.name));
                const stats = fs.statSync(path.join(dir, entry.name)); // Need stats for isExcluded check
                 // Don't add excluded items to the tree *at all*
                return !isExcluded(entryRelativePath, stats);
            })
            .sort((a, b) => {
                // Directories first, then files, then alphabetically
                if (a.isDirectory() && !b.isDirectory()) return -1;
                if (!a.isDirectory() && b.isDirectory()) return 1;
                return a.name.localeCompare(b.name);
            });

        filteredEntries.forEach((entry, index) => {
            const isLast = index === filteredEntries.length - 1;
            const connector = isLast ? '└── ' : '├── ';
            const entryPath = path.join(dir, entry.name);
            const entryRelativePath = path.relative(rootDir, entryPath); // Path relative to project root

            tree += `${prefix}${connector}${entry.name}\n`;

            if (entry.isDirectory()) {
                const newPrefix = prefix + (isLast ? '    ' : '│   ');
                tree += generateTree(entryPath, rootDir, newPrefix, includedFiles);
            } else {
                // Optionally: Only add files to the tree that will be included in the content part
                 if (includedFiles.has(entryRelativePath)) {
                     // File already added during tree build if check is here
                 } else {
                    // If we want the tree to show *all* non-excluded files, even if INCLUDED_EXTENSIONS
                    // limits content, then we don't need the check above.
                    // Current implementation shows all non-excluded files/dirs in the tree.
                 }
            }
        });
    } catch (err) {
        console.error(`Error reading directory ${dir}: ${err.message}`);
        tree += `${prefix}└── [Error reading directory]\n`;
    }
    return tree;
}


// --- File Content Gathering ---

function gatherFileContents(dir, rootDir) {
    let filesToInclude = new Map(); // Using Map to store { relativePath: absolutePath }

    function traverse(currentDir) {
        try {
            const entries = fs.readdirSync(currentDir, { withFileTypes: true });

            for (const entry of entries) {
                const absolutePath = path.join(currentDir, entry.name);
                const relativePath = path.relative(rootDir, absolutePath);
                 // Use statSync here to check if it's a file or dir for exclusion
                let stats;
                 try {
                     stats = fs.statSync(absolutePath);
                 } catch (statErr) {
                     console.warn(`Warning: Could not stat ${absolutePath}. Skipping. Error: ${statErr.message}`);
                     continue; // Skip if stat fails (e.g., broken symlink)
                 }


                if (isExcluded(relativePath, stats)) {
                    // console.log(`Excluding: ${relativePath}`); // Uncomment for debugging exclusions
                    continue;
                }

                if (entry.isDirectory()) {
                    traverse(absolutePath);
                } else if (entry.isFile()) {
                    // console.log(`Including: ${relativePath}`); // Uncomment for debugging inclusions
                    filesToInclude.set(relativePath, absolutePath);
                }
            }
        } catch (err) {
            console.error(`Error reading directory ${currentDir}: ${err.message}`);
        }
    }

    traverse(dir);
    return filesToInclude; // Return the Map
}

// --- Main Execution ---

function main() {
    // Use current directory as default, or first command-line argument
    const projectDir = path.resolve(process.argv[2] || '.');
    const outputFilePath = path.join(projectDir, OUTPUT_FILE); // Output in the project dir

    console.log(`Scanning project directory: ${projectDir}`);
    console.log(`Output will be written to: ${outputFilePath}`);

    if (!fs.existsSync(projectDir) || !fs.statSync(projectDir).isDirectory()) {
        console.error(`Error: Project directory not found or is not a directory: ${projectDir}`);
        process.exit(1);
    }

    // 1. Gather all files first to know what will be included in the content
    const includedFilesMap = gatherFileContents(projectDir, projectDir); // Map { relativePath: absolutePath }
    const includedFileRelativePaths = new Set(includedFilesMap.keys()); // Set { relativePath } for quick lookup in tree generation

    // 2. Generate the project tree (pass the set of included files for potential filtering)
    console.log("Generating project tree...");
    const projectName = path.basename(projectDir);
    const projectTree = `${projectName}/\n` + generateTree(projectDir, projectDir, '', includedFileRelativePaths);


    // 3. Read and combine file contents
    console.log(`Reading content of ${includedFilesMap.size} files...`);
    let combinedContent = '';
    const sortedRelativePaths = Array.from(includedFilesMap.keys()).sort(); // Sort for consistent order

    for (const relativePath of sortedRelativePaths) {
        const absolutePath = includedFilesMap.get(relativePath);
        try {
            const content = fs.readFileSync(absolutePath, 'utf8');
            combinedContent += `// ----- File: ${relativePath} -----\n\n`;
            combinedContent += content;
            combinedContent += '\n\n// ----- End File: ' + relativePath + ' -----\n\n';
        } catch (err) {
            console.warn(`Warning: Could not read file ${absolutePath}. Skipping. Error: ${err.message}`);
            combinedContent += `// ----- File: ${relativePath} -----\n\n`;
            combinedContent += `// ***** Error reading file: ${err.message} *****\n\n`;
             combinedContent += '// ----- End File: ' + relativePath + ' -----\n\n';
        }
    }

    // 4. Combine tree and content
    const finalOutput = `--- Project Tree ---\n\n${projectTree}\n\n--- File Contents ---\n\n${combinedContent}`;

    // 5. Write to output file
    console.log(`Writing combined output to ${outputFilePath}...`);
    try {
        fs.writeFileSync(outputFilePath, finalOutput, 'utf8');
        console.log('Done!');
    } catch (err) {
        console.error(`Error writing output file ${outputFilePath}: ${err.message}`);
        process.exit(1);
    }
}

main();

// ----- End File: combine_project.js -----

// ----- File: package.json -----

{
  "name": "route-trace-app",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@mui/icons-material": "^7.0.2",
    "@mui/material": "^7.0.2",
    "@reduxjs/toolkit": "^2.6.1",
    "@testing-library/dom": "^10.4.0",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^13.5.0",
    "axios": "^1.8.4",
    "date-fns": "^4.1.0",
    "js-cookie": "^3.0.5",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "react-redux": "^9.2.0",
    "react-router-dom": "^7.5.0",
    "react-scripts": "5.0.1",
    "uuid": "^10.0.0",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

// ----- End File: package.json -----

// ----- File: public\index.html -----

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#ffffff" /> <!-- Default theme color -->
    <meta
      name="description"
      content="RouteTrace Network Analysis Utility"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!-- Material UI Fonts -->
    <link
      rel="preconnect"
      href="https://fonts.googleapis.com"
    />
    <link
      rel="preconnect"
      href="https://fonts.gstatic.com"
      crossorigin
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
    />
    <title>RouteTrace</title>
    <!-- Global styles moved to index.css and managed by MUI -->
    <style>
      /* Minimal baseline styles */
      html, body, #root {
        height: 100%;
        margin: 0;
        padding: 0;
      }
      body {
        font-family: 'Roboto', sans-serif;
        /* Background color is handled by MUI ThemeProvider + CssBaseline */
      }
    </style>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>

// ----- End File: public\index.html -----

// ----- File: public\manifest.json -----

{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}


// ----- End File: public\manifest.json -----

// ----- File: public\robots.txt -----

# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:


// ----- End File: public\robots.txt -----

// ----- File: src\App.css -----

.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}


// ----- End File: src\App.css -----

// ----- File: src\App.js -----

// ----- File: src\App.js -----
// ----- File: src\App.js -----
import React, { useState, useMemo } from 'react';
import { Routes, Route, Navigate, useLocation } from 'react-router-dom';
import {
    Box,
    CssBaseline,
    ThemeProvider,
    Toolbar,
    AppBar,
    IconButton,
    Typography,
    Container,
    createTheme
} from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import LoginPage from './pages/LoginPage';
import RouteTracePage from './pages/RouteTracePage'; // Combined Trace
import MacTracePage from './pages/MacTracePage'; // MAC Trace
import DirectRouteTracePage from './pages/DirectRouteTracePage'; // Direct Route Trace
import HistoryPage from './pages/HistoryPage';
import AllRoutesPage from './pages/AllRoutesPage';
import ComparisonPage from './pages/ComparisonPage';
import NotFoundPage from './pages/NotFoundPage';
import Sidebar from './components/Common/Sidebar';
import { useAuth } from './hooks/useAuth';
import getDesignTokens from './theme';

const drawerWidth = 240;

function ProtectedRoute({ children }) {
  const { isAuthenticated } = useAuth();
  const location = useLocation();

  if (!isAuthenticated) {
    // Redirect them to the /login page, but save the current location they were
    // trying to go to when they were redirected. This allows us to send them
    // along to that page after they login, which is a nicer user experience
    // than dropping them off on the home page.
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return children;
}

function App() {
  const { isAuthenticated } = useAuth();
  const [mobileOpen, setMobileOpen] = useState(false);
  // Default theme mode preference can be set here or from localStorage
  const [mode, setMode] = useState(() => {
      const savedMode = localStorage.getItem('themeMode');
      // Add system preference check as a fallback
      // const prefersDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      return savedMode === 'dark' ? 'dark' : 'light'; // Default to light if no preference saved
  });

  const handleDrawerToggle = () => {
    setMobileOpen(!mobileOpen);
  };

  // Memoize the color mode toggle function
  const colorMode = useMemo(
    () => ({
      toggleColorMode: () => {
        setMode((prevMode) => {
          const newMode = prevMode === 'light' ? 'dark' : 'light';
          localStorage.setItem('themeMode', newMode);
          return newMode;
        });
      },
    }),
    [], // Empty dependency array means this object doesn't change
  );

  // Memoize the theme based on the mode
  const theme = useMemo(() => createTheme(getDesignTokens(mode)), [mode]);

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline /> {/* Ensures baseline styles and background color */}
      <Box sx={{ display: 'flex', minHeight: '100vh' }}>

        {/* Render Sidebar only if authenticated */}
        {isAuthenticated && (
          <Sidebar
            drawerWidth={drawerWidth}
            mobileOpen={mobileOpen}
            handleDrawerToggle={handleDrawerToggle}
            mode={mode}
            toggleColorMode={colorMode.toggleColorMode}
          />
        )}

        {/* Main Content Area */}
        <Box
          component="main"
          sx={{
            flexGrow: 1,
            width: isAuthenticated ? { sm: `calc(100% - ${drawerWidth}px)` } : '100%',
            // Add Toolbar height for spacing below the potential mobile AppBar
            // Use Container to center content and provide max width if desired
            // For full-width pages, you might remove Container or adjust its props
          }}
        >
           {/* Mobile-only AppBar */}
           {isAuthenticated && (
                <AppBar
                    position="fixed"
                    elevation={1} // Subtle elevation
                    sx={{
                        width: { sm: `calc(100% - ${drawerWidth}px)` },
                        ml: { sm: `${drawerWidth}px` },
                        display: { xs: 'block', sm: 'none' }, // Show only on extra-small screens
                        backdropFilter: 'blur(8px)', // Optional: Add blur effect
                        backgroundColor: (theme) => theme.palette.mode === 'dark' ? 'rgba(18, 18, 18, 0.7)' : 'rgba(255, 255, 255, 0.7)',
                    }}
                >
                    <Toolbar>
                        <IconButton
                            color="inherit"
                            aria-label="open drawer"
                            edge="start"
                            onClick={handleDrawerToggle}
                            sx={{ mr: 2, display: { sm: 'none' } }} // Ensure button hides on larger screens too
                        >
                            <MenuIcon />
                        </IconButton>
                        <Typography variant="h6" noWrap component="div" sx={{ flexGrow: 1 }}>
                            RouteTrace
                        </Typography>
                        {/* Optional: Add theme toggle or other actions to mobile app bar */}
                    </Toolbar>
                </AppBar>
            )}

             {/* Add a Toolbar component here to create space below the fixed AppBar
                 Only necessary if the AppBar is always visible (e.g., even on desktop),
                 or if the mobile AppBar exists. */}
            <Toolbar sx={{ display: { xs: 'block', sm: 'none' }}} /> {/* Spacer for mobile app bar */}

            {/* Page Content Container */}
            <Container maxWidth="xl" sx={{ py: 3, px: {xs: 2, sm: 3} }}>
                <Routes>
                    <Route path="/login" element={<LoginPage />} />

                    {/* Protected Routes */}
                    <Route path="/" element={<ProtectedRoute><RouteTracePage /></ProtectedRoute>} />
                    <Route path="/mac-trace" element={<ProtectedRoute><MacTracePage /></ProtectedRoute>} />
                    <Route path="/direct-route-trace" element={<ProtectedRoute><DirectRouteTracePage /></ProtectedRoute>} />
                    <Route path="/comparison" element={<ProtectedRoute><ComparisonPage /></ProtectedRoute>} />
                    <Route path="/history" element={<ProtectedRoute><HistoryPage /></ProtectedRoute>} />
                    <Route path="/all-routes" element={<ProtectedRoute><AllRoutesPage /></ProtectedRoute>} />

                    {/* Catch-all Not Found Route */}
                    <Route path="*" element={<NotFoundPage />} />
                </Routes>
            </Container>
        </Box>
      </Box>
    </ThemeProvider>
  );
}

export default App;

// ----- End File: src\App.js -----

// ----- End File: src\App.js -----

// ----- File: src\App.test.js -----

import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});


// ----- End File: src\App.test.js -----

// ----- File: src\components\Auth\LoginForm.jsx -----

// ----- File: src\components\Auth\LoginForm.jsx -----
import React, { useState, useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { useNavigate, useLocation } from 'react-router-dom';
import {
    TextField,
    Button,
    Box,
    Typography,
    CircularProgress,
    Alert,
    Paper,
    Container,
    Avatar
} from '@mui/material';
import LockOutlinedIcon from '@mui/icons-material/LockOutlined';
import { loginUser, resetAuthError } from '../../store/slices/authSlice';

const LoginForm = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const dispatch = useDispatch();
  const navigate = useNavigate();
  const location = useLocation();
  const { loading, error, isAuthenticated } = useSelector((state) => state.auth);

  const from = location.state?.from?.pathname || "/"; // Redirect path after login

  // Redirect if already logged in
  useEffect(() => {
      if (isAuthenticated) {
          navigate(from, { replace: true });
      }
  }, [isAuthenticated, navigate, from]);

  // Clear error when component mounts or location changes (if error persists across navigation)
  useEffect(() => {
      dispatch(resetAuthError());
      // Optional: Return cleanup function if needed, though usually handled by slice state
      // return () => { dispatch(resetAuthError()); };
  }, [dispatch, location]); // Depend on location to clear error if user navigates away and back


  const handleSubmit = (e) => {
    e.preventDefault();
    if (!username || !password) return; // Basic validation
    dispatch(loginUser({ username, password }))
      .unwrap() // Allows chaining .then() and .catch() on the dispatch
      .then(() => {
        navigate(from, { replace: true }); // Redirect on successful login
      })
      .catch((err) => {
        // Error is already handled by the slice and displayed via useSelector
        // Optionally log for debugging, but avoid user-facing console errors in prod
        // console.error("Login failed:", err);
      });
  };

  return (
    <Container component="main" maxWidth="xs">
      <Paper
          elevation={3}
          sx={{
            marginTop: 8,
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            padding: (theme) => theme.spacing(3, 4), // Adjust padding
            borderRadius: 2, // Softer corners
          }}
       >
        <Avatar sx={{ m: 1, bgcolor: 'secondary.main' }}>
          <LockOutlinedIcon />
        </Avatar>
        <Typography component="h1" variant="h5" gutterBottom>
          Sign in
        </Typography>
        {error && (
            <Alert severity="error" sx={{ width: '100%', mb: 2 }}>
                {error}
            </Alert>
        )}
        <Box component="form" onSubmit={handleSubmit} noValidate sx={{ mt: 1, width: '100%' }}>
          <TextField
            margin="normal"
            required
            fullWidth
            id="username"
            label="Username"
            name="username"
            autoComplete="username"
            autoFocus
            value={username}
            onChange={(e) => setUsername(e.target.value)}
            disabled={loading}
            error={!!error} // Highlight field if there's a login error
          />
          <TextField
            margin="normal"
            required
            fullWidth
            name="password"
            label="Password"
            type="password"
            id="password"
            autoComplete="current-password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            disabled={loading}
            error={!!error} // Highlight field if there's a login error
          />
          {/* Consider adding 'Forgot password?' link or Remember me checkbox if needed */}
          <Button
            type="submit"
            fullWidth
            variant="contained"
            disabled={loading || !username || !password} // Disable if loading or fields empty
            sx={{ mt: 3, mb: 2, position: 'relative', height: 40 }} // Set fixed height
          >
            {loading ? (
                <CircularProgress
                     size={24}
                     sx={{
                         color: 'inherit', // Inherit button text color
                         position: 'absolute',
                         top: '50%',
                         left: '50%',
                         marginTop: '-12px',
                         marginLeft: '-12px',
                    }}
                />
            ) : (
                'Sign In'
            )}
          </Button>
          {/* Optional: Add link to Sign Up page if applicable */}
          {/* <Grid container>
            <Grid item xs>
              <Link href="#" variant="body2">
                Forgot password?
              </Link>
            </Grid>
            <Grid item>
              <Link href="#" variant="body2">
                {"Don't have an account? Sign Up"}
              </Link>
            </Grid>
          </Grid> */}
        </Box>
      </Paper>
      {/* Optional: Add copyright or footer */}
      {/* <Typography variant="body2" color="text.secondary" align="center" sx={{ mt: 5 }}>
        {'Copyright © '}
        <Link color="inherit" href="https://yourwebsite.com/">
          Your Website
        </Link>{' '}
        {new Date().getFullYear()}
        {'.'}
      </Typography> */}
    </Container>
  );
};

export default LoginForm;

// ----- End File: src\components\Auth\LoginForm.jsx -----

// ----- File: src\components\Common\ErrorMessage.jsx -----

// ----- File: src\components\Common\ErrorMessage.jsx -----
import React from 'react';
import { Alert, AlertTitle, Collapse } from '@mui/material';
import ReportProblemIcon from '@mui/icons-material/ReportProblem'; // More prominent icon

const ErrorMessage = ({ error, title = "Error" }) => {
  const hasError = !!error;
  const message = typeof error === 'string' ? error : error?.message || 'An unexpected error occurred.';

  return (
    // Use Collapse for smooth appearance/disappearance
    <Collapse in={hasError}>
        <Alert
            severity="error"
            icon={<ReportProblemIcon fontSize="inherit" />} // Custom icon
            sx={{
                mt: 2,
                mb: 2,
                // Improve visual prominence
                border: (theme) => `1px solid ${theme.palette.error.dark}`,
                bgcolor: 'error.lighter', // Use theme-defined lighter error background if available
                '& .MuiAlert-message': { // Ensure message area takes full width
                    width: '100%',
                },
            }}
            // You might add an action button, e.g., to dismiss or retry
            // action={
            //   <Button color="inherit" size="small">
            //     RETRY
            //   </Button>
            // }
        >
        <AlertTitle sx={{ fontWeight: 'bold' }}>{title}</AlertTitle>
        {message}
        {/* Optional: Display more details if error is an object */}
        {typeof error === 'object' && error?.details && (
            <pre style={{ fontSize: '0.75rem', marginTop: '8px', whiteSpace: 'pre-wrap', wordBreak: 'break-all' }}>
                {JSON.stringify(error.details, null, 2)}
            </pre>
        )}
        </Alert>
    </Collapse>
  );
};

export default ErrorMessage;

// ----- End File: src\components\Common\ErrorMessage.jsx -----

// ----- File: src\components\Common\LoadingSpinner.jsx -----

// ----- File: src\components\Common\LoadingSpinner.jsx -----
import React from 'react';
import { Box, CircularProgress, Typography } from '@mui/material';

const LoadingSpinner = ({ size = 40, message }) => (
  <Box sx={{
      display: 'flex',
      flexDirection: 'column', // Stack spinner and message vertically
      justifyContent: 'center',
      alignItems: 'center',
      p: 3, // Add more padding
      minHeight: 150, // Ensure it takes up some space
      color: 'text.secondary' // Use secondary text color for message
    }}>
    <CircularProgress size={size} sx={{ mb: message ? 2 : 0 }} />
    {message && <Typography variant="caption">{message}</Typography>}
  </Box>
);

export default LoadingSpinner;

// ----- End File: src\components\Common\LoadingSpinner.jsx -----

// ----- File: src\components\Common\Navbar.jsx -----

import React from 'react';
import { useDispatch } from 'react-redux';
import { Link as RouterLink, useNavigate } from 'react-router-dom';
import { AppBar, Toolbar, Typography, Button, Box, IconButton } from '@mui/material';
import AccountTreeIcon from '@mui/icons-material/AccountTree'; // Example icon
import { logoutUser } from '../../store/slices/authSlice';

const Navbar = () => {
  const dispatch = useDispatch();
  const navigate = useNavigate();

  const handleLogout = () => {
    dispatch(logoutUser());
    navigate('/login'); // Redirect to login after logout
  };

  return (
    <AppBar position="fixed">
      <Toolbar>
         <IconButton
          size="large"
          edge="start"
          color="inherit"
          aria-label="logo"
          component={RouterLink}
          to="/"
          sx={{ mr: 1 }}
        >
          <AccountTreeIcon />
        </IconButton>
        <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
          RouteTrace
        </Typography>
        <Box sx={{ '& button': { ml: 1 } }}>
             <Button color="inherit" component={RouterLink} to="/">
                 Trace Route
            </Button>
             <Button color="inherit" component={RouterLink} to="/history">
                 My History
            </Button>
              <Button color="inherit" component={RouterLink} to="/all-routes">
                 All Routes
            </Button>
            <Button color="inherit" onClick={handleLogout}>
                Logout
            </Button>
        </Box>
      </Toolbar>
    </AppBar>
  );
};

export default Navbar;

// ----- End File: src\components\Common\Navbar.jsx -----

// ----- File: src\components\Common\Sidebar.jsx -----

// ----- File: src\components\Common\Sidebar.jsx -----
// ----- File: src\components\Common\Sidebar.jsx -----
import React from 'react';
import { useDispatch } from 'react-redux';
import { Link as RouterLink, useNavigate, useLocation } from 'react-router-dom';
import {
    Drawer, Box, List, ListItem, ListItemButton, ListItemIcon,
    ListItemText, Toolbar, Divider, Typography, IconButton, Tooltip,
    Avatar, Stack, Button // <-- Added Button import
} from '@mui/material';
import AccountTreeIcon from '@mui/icons-material/AccountTree';
import RouteIcon from '@mui/icons-material/Route'; // Combined Trace
import SettingsEthernetIcon from '@mui/icons-material/SettingsEthernet'; // MAC Trace
import NetworkCheckIcon from '@mui/icons-material/NetworkCheck'; // Direct Route Trace
import CompareArrowsIcon from '@mui/icons-material/CompareArrows'; // Comparison Page
import HistoryIcon from '@mui/icons-material/History'; // My History
import PeopleIcon from '@mui/icons-material/People'; // All Routes
import LogoutIcon from '@mui/icons-material/Logout';
import Brightness4Icon from '@mui/icons-material/Brightness4'; // Dark mode
import Brightness7Icon from '@mui/icons-material/Brightness7'; // Light mode
import { logoutUser } from '../../store/slices/authSlice';
import { useAuth } from '../../hooks/useAuth';

// Helper to get initials from username
const getInitials = (name = '') => {
    return name
        .split(' ')
        .map((n) => n[0])
        .join('')
        .toUpperCase()
        .substring(0, 2); // Max 2 initials
};


const Sidebar = ({ drawerWidth, mobileOpen, handleDrawerToggle, mode, toggleColorMode }) => {
    const dispatch = useDispatch();
    const navigate = useNavigate();
    const location = useLocation();
    const { user } = useAuth();

    const handleLogout = () => {
        dispatch(logoutUser());
        navigate('/login', { replace: true }); // Use replace to prevent going back to protected routes
    };

    const menuItems = [
        { text: 'Combined Trace', icon: <RouteIcon />, path: '/' },
        { text: 'Direct Route Trace', icon: <NetworkCheckIcon />, path: '/direct-route-trace' },
        { text: 'MAC Trace', icon: <SettingsEthernetIcon />, path: '/mac-trace' },
        { text: 'Compare Traces', icon: <CompareArrowsIcon />, path: '/comparison' },
        { text: 'My History', icon: <HistoryIcon />, path: '/history' },
        { text: 'All Routes', icon: <PeopleIcon />, path: '/all-routes' }, // Consider conditional rendering based on user role
    ];

    const drawerContent = (
        <Box sx={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
            {/* Header Section */}
            <Toolbar sx={{ display: 'flex', alignItems: 'center', justifyContent: 'flex-start', px: 2, gap: 1.5 }}>
                <AccountTreeIcon fontSize="large" color="primary" />
                <Typography variant="h6" noWrap component="div" color="primary.main" fontWeight="bold">
                    RouteTrace
                </Typography>
            </Toolbar>
            <Divider />

            {/* Navigation Links */}
            <List sx={{ flexGrow: 1, py: 1 }}>
                {menuItems.map((item) => (
                    <ListItem key={item.text} disablePadding sx={{ display: 'block' }}>
                        <ListItemButton
                            component={RouterLink}
                            to={item.path}
                            selected={location.pathname === item.path}
                            onClick={handleDrawerToggle} // Close mobile drawer on item click
                            sx={{
                                minHeight: 48,
                                justifyContent: 'initial',
                                px: 2.5,
                                borderRadius: 1, // Add slight rounding
                                mx: 1, // Add horizontal margin
                                mb: 0.5, // Add vertical spacing
                                '&.Mui-selected': { // Style for selected item
                                    backgroundColor: (theme) => theme.palette.action.selected,
                                    '& .MuiListItemIcon-root, & .MuiListItemText-primary': {
                                        color: (theme) => theme.palette.primary.main,
                                        fontWeight: 'medium',
                                    },
                                },
                                '&:hover': { // Style for hover
                                     backgroundColor: (theme) => theme.palette.action.hover,
                                }
                            }}
                        >
                            <ListItemIcon sx={{ minWidth: 0, mr: 3, justifyContent: 'center', color: 'text.secondary' }}>
                                {item.icon}
                            </ListItemIcon>
                            <ListItemText primary={item.text} sx={{ opacity: 1 }} primaryTypographyProps={{ variant: 'body2' }} />
                        </ListItemButton>
                    </ListItem>
                ))}
            </List>
            <Divider />

            {/* User Info and Actions Footer */}
            <Box sx={{ p: 2, mt: 'auto' }}> {/* Push to bottom */}
                 <Stack direction="row" spacing={1.5} alignItems="center" sx={{ mb: 2 }}>
                    <Avatar sx={{ bgcolor: 'secondary.main', width: 32, height: 32, fontSize: '0.8rem' }}>
                        {getInitials(user?.username)}
                    </Avatar>
                    <Typography variant="body2" fontWeight="medium" noWrap>
                        {user?.username || 'Unknown User'}
                    </Typography>
                     <Tooltip title={`Switch to ${mode === 'dark' ? 'light' : 'dark'} mode`} sx={{ ml: 'auto' }}>
                        <IconButton onClick={toggleColorMode} color="inherit" size="small">
                            {mode === 'dark' ? <Brightness7Icon fontSize="small" /> : <Brightness4Icon fontSize="small" />}
                        </IconButton>
                      </Tooltip>
                 </Stack>

                <Button
                    fullWidth
                    variant="outlined" // Use outlined or text for less emphasis
                    color="inherit" // Inherit color, could be error for destructive action
                    startIcon={<LogoutIcon />}
                    onClick={handleLogout}
                    size="small"
                >
                    Logout
                </Button>
            </Box>
        </Box>
    );

    return (
        <Box
            component="nav"
            sx={{ width: { sm: drawerWidth }, flexShrink: { sm: 0 } }} // Use sm breakpoint
            aria-label="main navigation"
        >
            {/* Temporary Drawer for Mobile */}
            <Drawer
                variant="temporary"
                open={mobileOpen}
                onClose={handleDrawerToggle}
                ModalProps={{ keepMounted: true }} // Better open performance on mobile.
                sx={{
                    display: { xs: 'block', sm: 'none' },
                    '& .MuiDrawer-paper': {
                         boxSizing: 'border-box',
                         width: drawerWidth,
                         borderRight: 'none' // Remove border if using elevation or distinct bg
                    },
                }}
            >
                {drawerContent}
            </Drawer>

            {/* Permanent Drawer for Desktop */}
            <Drawer
                variant="permanent"
                sx={{
                    display: { xs: 'none', sm: 'block' },
                    '& .MuiDrawer-paper': {
                        boxSizing: 'border-box',
                        width: drawerWidth,
                        borderRight: (theme) => `1px solid ${theme.palette.divider}` // Subtle border
                    },
                }}
                open // Permanent drawer is always open
            >
                {drawerContent}
            </Drawer>
        </Box>
    );
};

export default Sidebar;
// ----- End File: src\components\Common\Sidebar.jsx -----

// ----- End File: src\components\Common\Sidebar.jsx -----

// ----- File: src\components\Comparison\ComparisonItem.jsx -----

// ----- File: src\components\Comparison\ComparisonItem.jsx -----
import React from 'react';
import { Paper, Box, Typography } from '@mui/material';
import HistoryRouteVisualizer from './HistoryRouteVisualizer';

// This component acts as a container for a single historical trace within the comparison view.
const ComparisonItem = ({ trace: route }) => {
    // route prop comes from ComparisonPage, which is historical data
    if (!route) return null;

    return (
        // Use Paper for consistent styling with other sections
        // Set height to 100% to fill Grid item space if needed for alignment
        <Paper
            elevation={2}
            sx={{
                p: { xs: 1.5, sm: 2 }, // Responsive padding
                mb: 3,
                height: '100%', // Fill height of the grid container
                display: 'flex', // Allow flex column layout
                flexDirection: 'column'
            }}
        >
            {/* Optional Header: Display basic info, kept minimal */}
            {/* <Box sx={{ mb: 1, pb: 1, borderBottom: 1, borderColor: 'divider' }}>
                <Typography variant="caption" color="text.secondary">
                    Trace ID: {route.id} | {route.user?.username || 'N/A'} | {formatTimestamp(route.timestamp, 'short')}
                </Typography>
            </Box> */}

            {/* The main visualizer for the historical route */}
            <HistoryRouteVisualizer route={route} />
        </Paper>
    );
};

export default ComparisonItem;

// ----- End File: src\components\Comparison\ComparisonItem.jsx -----

// ----- File: src\components\Comparison\ComparisonSelector.jsx -----

// ----- File: src\components\Comparison\ComparisonSelector.jsx -----
import React from 'react';
import { Autocomplete, TextField, Checkbox, Box, Typography, Chip, Stack, Paper } from '@mui/material';
import CheckBoxOutlineBlankIcon from '@mui/icons-material/CheckBoxOutlineBlank';
import CheckBoxIcon from '@mui/icons-material/CheckBox';
import { formatTimestamp } from '../../utils/formatters';

const icon = <CheckBoxOutlineBlankIcon fontSize="small" />;
const checkedIcon = <CheckBoxIcon fontSize="small" />;

const ComparisonSelector = ({ availableRoutes, selectedIds, onChange }) => {

    // Find the full route objects corresponding to the selected IDs for the Autocomplete value prop
    const selectedRoutes = availableRoutes.filter(route => selectedIds.includes(route.id));

    // Sort available routes: Create a copy first! Sort newest first.
    const sortedOptions = [...availableRoutes].sort((a, b) => {
        const dateA = a.timestamp ? new Date(a.timestamp) : 0;
        const dateB = b.timestamp ? new Date(b.timestamp) : 0;
        if (isNaN(dateA) && isNaN(dateB)) return 0;
        if (isNaN(dateA)) return 1;
        if (isNaN(dateB)) return -1;
        return dateB - dateA; // Newest first
    });

    const getOptionLabel = (option) => {
        // Label primarily used for filtering/searching, keep it concise
        const user = option.user ? `${option.user.username}` : 'N/A';
        return `${option.source || 'N/A'} -> ${option.destination || 'N/A'} (${user}, ${option.id})`;
    };

    const handleChange = (event, newValue) => {
        // Extract just the IDs from the selected route objects
        const newSelectedIds = newValue.map(route => route.id);
        onChange(newSelectedIds);
    };

    return (
        <Paper elevation={1} sx={{ p: 2, mb: 3 }}>
            <Typography variant="h6" gutterBottom sx={{ mb: 2 }}>
                Select Historical Traces to Compare
            </Typography>
            <Autocomplete
                multiple
                id="route-comparison-selector"
                options={sortedOptions} // Use the sorted COPY
                value={selectedRoutes} // Pass the selected route *objects*
                getOptionLabel={getOptionLabel} // Function for text value and filtering
                isOptionEqualToValue={(option, value) => option.id === value.id} // Crucial for matching objects
                onChange={handleChange}
                disableCloseOnSelect // Keep dropdown open when selecting multiple items
                renderOption={(props, option, { selected }) => (
                    // Use the li element provided by props for accessibility
                    <li {...props} key={option.id} style={{ display: 'flex', alignItems: 'flex-start', padding: '8px 16px' }}>
                        <Checkbox
                            icon={icon}
                            checkedIcon={checkedIcon}
                            style={{ marginRight: 8, marginTop: -6 }} // Align checkbox nicely
                            checked={selected}
                            size="small"
                        />
                        {/* Use Stack for better layout of option details */}
                        <Stack spacing={0.5} sx={{ flexGrow: 1 }}>
                             {/* Main route identifier with Chips */}
                             <Typography variant="body2" sx={{ display: 'flex', alignItems: 'center', gap: 0.5, flexWrap: 'wrap' }}>
                                <Chip label="Src" size="small" color="primary" variant="outlined" sx={{ height: 'auto', '& .MuiChip-label': { px: 0.8, py: 0.2, fontSize: '0.7rem' } }} />
                                <Typography component="span" sx={{ fontWeight: 500, wordBreak: 'break-all' }}>{option.source || '?'}</Typography>
                                <Typography component="span" sx={{ mx: 0.5 }}>→</Typography>
                                <Chip label="Dst" size="small" color="secondary" variant="outlined" sx={{ height: 'auto', '& .MuiChip-label': { px: 0.8, py: 0.2, fontSize: '0.7rem' } }} />
                                <Typography component="span" sx={{ fontWeight: 500, wordBreak: 'break-all' }}>{option.destination || '?'}</Typography>
                             </Typography>
                             {/* Secondary details: Timestamp, User, ID */}
                             <Typography variant="caption" color="text.secondary">
                                {formatTimestamp(option.timestamp, 'PPp')} {/* More readable format */}
                                {option.user ? ` • ${option.user.username}` : ''}
                                <span style={{ marginLeft: '8px', opacity: 0.7 }}>(ID: {option.id})</span>
                             </Typography>
                        </Stack>
                    </li>
                )}
                renderInput={(params) => (
                    <TextField
                        {...params}
                        variant="outlined"
                        label="Search or Select Traces"
                        placeholder={selectedRoutes.length > 0 ? `${selectedRoutes.length} selected` : "Select from history..."}
                        InputLabelProps={{ shrink: true }} // Keep label shrunk
                    />
                )}
                sx={{ width: '100%' }} // Make Autocomplete full width
            />
            {selectedRoutes.length > 0 && (
                <Typography variant="caption" display="block" sx={{ mt: 1, color: 'text.secondary' }}>
                    Currently comparing {selectedRoutes.length} trace{selectedRoutes.length > 1 ? 's' : ''}.
                </Typography>
            )}
        </Paper>
    );
};

export default ComparisonSelector;

// ----- End File: src\components\Comparison\ComparisonSelector.jsx -----

// ----- File: src\components\Comparison\HistoryRouteVisualizer.jsx -----

// ----- File: src\components\Comparison\HistoryRouteVisualizer.jsx -----
import React from 'react';
import { Box, Typography, Stack, Paper, Accordion, AccordionSummary, AccordionDetails, Chip, Divider } from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import InfoIcon from '@mui/icons-material/Info'; // Keep info icon for consistency
import DeviceUnknownIcon from '@mui/icons-material/DeviceUnknown'; // Keep icon for device info
import AccountTreeIcon from '@mui/icons-material/AccountTree';
import HopDisplay from '../RouteTrace/HopDisplay'; // Reuse the hop display component
import { formatTimestamp } from '../../utils/formatters';

const HistoryRouteVisualizer = ({ route }) => {
    if (!route) return <Typography color="error">Invalid route data provided.</Typography>;

    const { id, source, destination, timestamp, routeData, deviceInfo, user } = route;

    // Validate data (assuming routeData is parsed array from historySlice)
    const hasValidRouteData = Array.isArray(routeData) && routeData.length > 0;
    const hasDeviceInfo = deviceInfo && typeof deviceInfo === 'object' && Object.keys(deviceInfo).length > 0;

    return (
        <Box sx={{ flexGrow: 1, display: 'flex', flexDirection: 'column' }}> {/* Allow vertical growth */}
            {/* Header Info - More compact and aligned */}
            <Paper elevation={0} variant="outlined" sx={{ p: 1.5, mb: 2 }}>
                 <Stack
                    direction={{ xs: 'column', sm: 'row' }}
                    justifyContent="space-between"
                    alignItems={{ xs: 'flex-start', sm: 'center' }}
                    spacing={{ xs: 1, sm: 2 }}
                    flexWrap="wrap"
                 >
                    {/* Source/Destination */}
                    <Box sx={{ minWidth: 0 }}> {/* Prevent text overflow issues */}
                        <Typography variant="body2" sx={{ display: 'flex', alignItems: 'center', flexWrap: 'wrap', gap: 0.5 }}>
                             <Chip label="Src" size="small" color="primary" variant="outlined" sx={{ height: 'auto', '& .MuiChip-label': { px: 0.8, py: 0.2, fontSize: '0.7rem' } }} />
                             <Typography component="span" sx={{ wordBreak: 'break-all', fontWeight: 500 }}>{source || 'N/A'}</Typography>
                             <Typography component="span" sx={{ mx: 1 }}>→</Typography>
                             <Chip label="Dst" size="small" color="secondary" variant="outlined" sx={{ height: 'auto', '& .MuiChip-label': { px: 0.8, py: 0.2, fontSize: '0.7rem' } }} />
                             <Typography component="span" sx={{ wordBreak: 'break-all', fontWeight: 500 }}>{destination || 'N/A'}</Typography>
                        </Typography>
                    </Box>
                     {/* Timestamp/User/ID */}
                     <Stack direction="column" alignItems={{ xs: 'flex-start', sm: 'flex-end' }} sx={{ textAlign: { xs: 'left', sm: 'right' } }}>
                         {user && (
                            <Typography variant="caption" color="text.secondary" sx={{ lineHeight: 1.3 }}>
                                User: {user.username}
                            </Typography>
                         )}
                         <Typography variant="caption" color="text.secondary" sx={{ lineHeight: 1.3 }}>
                             {formatTimestamp(timestamp, 'PPp')} {/* Readable format */}
                         </Typography>
                         <Typography variant="caption" color="text.secondary" sx={{ fontSize: '0.65rem', opacity: 0.7, lineHeight: 1.3 }}>
                            (ID: {id})
                         </Typography>
                    </Stack>
                </Stack>
            </Paper>

            {/* Device Info Accordion (Conditional) */}
            {hasDeviceInfo && (
                 <Accordion
                    elevation={0} variant="outlined" // Subtle look
                    sx={{ mb: 1 }}
                    slotProps={{ transition: { unmountOnExit: true } }} // More performant transition
                  >
                     <AccordionSummary
                        expandIcon={<ExpandMoreIcon />}
                        aria-controls={`panel-deviceinfo-${id}-content`}
                        id={`panel-deviceinfo-${id}-header`}
                        sx={{ minHeight: '40px', '&.Mui-expanded': { minHeight: '40px' }, '& .MuiAccordionSummary-content': { my: 0.5 } }}
                     >
                         <DeviceUnknownIcon sx={{ mr: 1, color: 'action.active', fontSize: '1.2rem' }}/>
                         <Typography variant="caption" fontWeight="medium">Additional Device Info</Typography>
                     </AccordionSummary>
                     <AccordionDetails sx={{ bgcolor: 'action.hover', p: 1, borderTop: 1, borderColor: 'divider' }}>
                         {/* Use pre for formatted JSON, ensure it's scrollable */}
                         <pre style={{
                             fontSize: '0.75rem',
                             margin: 0,
                             padding: '8px',
                             borderRadius: '4px',
                             overflowX: 'auto',
                             whiteSpace: 'pre-wrap',
                             wordBreak: 'break-all',
                             maxHeight: '200px', // Limit height
                             backgroundColor: (theme) => theme.palette.background.default, // Match background
                             }}>
                             {JSON.stringify(deviceInfo, null, 2)}
                         </pre>
                     </AccordionDetails>
                 </Accordion>
            )}

            {/* Route Trace Accordion */}
            <Accordion
                defaultExpanded // Keep hops expanded by default
                elevation={0} variant="outlined" // Consistent subtle look
                slotProps={{ transition: { unmountOnExit: true } }}
                sx={{ flexGrow: 1, display: 'flex', flexDirection: 'column' }} // Allow accordion to fill space
             >
                 <AccordionSummary
                    expandIcon={<ExpandMoreIcon />}
                    aria-controls={`panel-routedata-${id}-content`}
                    id={`panel-routedata-${id}-header`}
                     sx={{ minHeight: '48px', '&.Mui-expanded': { minHeight: '48px' }, '& .MuiAccordionSummary-content': { my: 1 } }}
                 >
                     <AccountTreeIcon sx={{ mr: 1, color: 'action.active' }} />
                     <Typography variant="subtitle2">Detailed Hops ({routeData?.length ?? 0})</Typography>
                 </AccordionSummary>
                 <AccordionDetails sx={{ p: 1, flexGrow: 1, overflow: 'hidden', display: 'flex' }}> {/* Let details grow and manage overflow */}
                    {hasValidRouteData ? (
                        <Box // Wrapper to handle overflow for the Stack
                            sx={{
                                overflowX: 'auto',
                                width: '100%', // Take full width of details area
                                py: 1,
                                px: 0.5,
                                // Optional border removed, Accordion border is sufficient
                                // border: '1px dashed', borderColor: 'divider', borderRadius: 1,
                            }}
                        >
                            <Stack
                                direction="row"
                                spacing={0} // Spacing handled by HopDisplay arrows
                                alignItems="center" // Align hops vertically
                                sx={{
                                    minWidth: 'max-content', // Ensure stack takes at least content width
                                    minHeight: 100, // Ensure minimum height
                                    pb: 1, // Padding bottom for scrollbar space if needed
                                }}
                            >
                                {routeData.map((hop, index) => (
                                    <HopDisplay
                                        key={`${hop.device_id || hop.ip || hop.mac || `hop-${hop.hop}`}-${index}`} // More robust key
                                        hopData={hop}
                                        isFirst={index === 0}
                                        isLast={index === routeData.length - 1}
                                    />
                                ))}
                            </Stack>
                        </Box>
                    ) : (
                        <Typography color="text.secondary" sx={{ p: 2, textAlign: 'center', fontStyle: 'italic', alignSelf: 'center' }}>
                            No detailed route hops available in this history entry.
                        </Typography>
                    )}
                </AccordionDetails>
            </Accordion>

        </Box>
    );
};

export default HistoryRouteVisualizer;

// ----- End File: src\components\Comparison\HistoryRouteVisualizer.jsx -----

// ----- File: src\components\History\HistoryItem.jsx -----

// ----- File: src\components\History\HistoryItem.jsx -----
import React, { useState } from 'react';
import {
    ListItem,
    ListItemText,
    Collapse,
    IconButton,
    Typography,
    Box,
    Paper,
    Stack,
    Chip,
    Accordion,
    AccordionSummary,
    AccordionDetails,
    Divider,
    useTheme, // Import useTheme hook
} from '@mui/material';
import ExpandLess from '@mui/icons-material/ExpandLess';
import ExpandMore from '@mui/icons-material/ExpandMore'; // <-- Correct import name is ExpandMore
import DeviceUnknownIcon from '@mui/icons-material/DeviceUnknown';
import AccountTreeIcon from '@mui/icons-material/AccountTree';
import CodeIcon from '@mui/icons-material/Code'; // Icon for Raw Data
import HopDisplay from '../RouteTrace/HopDisplay';
import { formatTimestamp } from '../../utils/formatters';

const HistoryItem = ({ route }) => {
  const [open, setOpen] = useState(false);
  const theme = useTheme(); // Access theme for colors/spacing
  const { id, source, destination, timestamp, routeData, deviceInfo, user } = route;

  const handleClick = () => {
    setOpen(!open);
  };

  // Check if routeData is valid (should be parsed array)
  const hasValidRouteData = Array.isArray(routeData) && routeData.length > 0;
  // Check if there's raw route data to display (string format and not successfully parsed/empty)
  const hasRawRouteString = typeof route.route === 'string' && route.route.trim() !== '' && !hasValidRouteData;
  const hasDeviceInfo = deviceInfo && typeof deviceInfo === 'object' && Object.keys(deviceInfo).length > 0;

  // Determine if there's any expandable content
  const hasDetails = hasValidRouteData || hasDeviceInfo || hasRawRouteString;

  return (
    <>
      {/* Main List Item Header */}
      <ListItem
         // Use button prop only if there are details to expand
         button={hasDetails}
         onClick={hasDetails ? handleClick : undefined} // Only allow click if expandable
         divider
         aria-expanded={open}
         aria-controls={hasDetails ? `history-item-details-${id}` : undefined}
         sx={{
             alignItems: 'flex-start', // Align items to top for multi-line content
             '&:hover': hasDetails ? {} : { bgcolor: 'transparent', cursor: 'default' }, // No hover effect if not clickable
            }}
      >
        <ListItemText
          disableTypography // Allow custom typography components
          primary={
              <Stack
                direction={{ xs: 'column', sm: 'row' }}
                justifyContent="space-between"
                alignItems={{ xs: 'flex-start', sm: 'center' }}
                spacing={{ xs: 0.5, sm: 2 }}
                sx={{ width: '100%', mb: 0.5 }} // Ensure stack takes full width
              >
                  {/* Source -> Destination */}
                  <Typography variant="body1" sx={{ display: 'flex', alignItems: 'center', flexWrap: 'wrap', gap: 0.5, minWidth: 0, flexGrow: 1 }}>
                      <Chip label="Src" size="small" color="primary" variant="outlined" sx={{ height: 'auto', '& .MuiChip-label': { px: 0.8, py: 0.2, fontSize: '0.7rem' } }} />
                      <Typography component="span" sx={{ wordBreak: 'break-all', fontWeight: 500 }}>{source || 'N/A'}</Typography>
                      <Typography component="span" sx={{ mx: 1 }}>→</Typography>
                      <Chip label="Dst" size="small" color="secondary" variant="outlined" sx={{ height: 'auto', '& .MuiChip-label': { px: 0.8, py: 0.2, fontSize: '0.7rem' } }} />
                      <Typography component="span" sx={{ wordBreak: 'break-all', fontWeight: 500 }}>{destination || 'N/A'}</Typography>
                  </Typography>
                  {/* User/Timestamp/ID */}
                  <Stack direction="column" alignItems={{ xs: 'flex-start', sm: 'flex-end' }} sx={{ minWidth: '160px', textAlign: {xs: 'left', sm: 'right'} }}>
                     {user && <Typography variant="caption" color="text.secondary" sx={{ lineHeight: 1.3 }}>User: {user.username}</Typography>}
                     <Typography variant="caption" color="text.secondary" sx={{ lineHeight: 1.3 }}>{formatTimestamp(timestamp, 'PPp')}</Typography> {/* Readable format */}
                     <Typography variant="caption" color="text.secondary" sx={{ fontSize: '0.65rem', opacity: 0.7, lineHeight: 1.3 }}>(ID: {id})</Typography>
                  </Stack>
             </Stack>
            }
            // Optional: Secondary text for brief summary if needed
            // secondary={ ... }
        />
        {/* Show expand icon only if details exist */}
        {hasDetails && (
            <IconButton size="small" sx={{ mt: 1 }}> {/* Align icon vertically */}
                {open ? <ExpandLess /> : <ExpandMore />}
            </IconButton>
        )}
      </ListItem>

      {/* Collapsible Details Section */}
      <Collapse in={open} timeout="auto" unmountOnExit id={`history-item-details-${id}`}>
        {/* Use Box with padding instead of Paper for less visual weight */}
        <Box sx={{ px: 2, py: 1, bgcolor: 'action.hover' }}>
            {/* Device Info Accordion (Conditional) */}
            {hasDeviceInfo && (
                 <Accordion elevation={0} variant="outlined" sx={{ mb: 1 }} slotProps={{ transition: { unmountOnExit: true } }}>
                     <AccordionSummary
                        expandIcon={<ExpandMore />} 
                        aria-controls={`panel-deviceinfo-${id}-content`}
                        id={`panel-deviceinfo-${id}-header`}
                        sx={{ minHeight: '40px', '&.Mui-expanded': { minHeight: '40px' }, '& .MuiAccordionSummary-content': { my: 0.5 } }}
                     >
                         <DeviceUnknownIcon sx={{ mr: 1, color: 'action.active', fontSize: '1.2rem' }}/>
                         <Typography variant="caption" fontWeight="medium">Additional Device Info</Typography>
                     </AccordionSummary>
                     <AccordionDetails sx={{ bgcolor: 'background.default', p: 1, borderTop: 1, borderColor: 'divider' }}>
                         <pre style={{ fontSize: '0.75rem', margin: 0, padding: '8px', borderRadius: '4px', overflowX: 'auto', whiteSpace: 'pre-wrap', wordBreak: 'break-all', maxHeight: '200px' }}>
                             {JSON.stringify(deviceInfo, null, 2)}
                         </pre>
                     </AccordionDetails>
                 </Accordion>
            )}

            {/* Route Trace Accordion (Conditional) */}
            {hasValidRouteData && (
                <Accordion defaultExpanded elevation={0} variant="outlined" sx={{ mb: hasRawRouteString ? 1 : 0 }} slotProps={{ transition: { unmountOnExit: true } }}>
                     <AccordionSummary
                        expandIcon={<ExpandMore />} 
                        aria-controls={`panel-routedata-${id}-content`}
                        id={`panel-routedata-${id}-header`}
                        sx={{ minHeight: '48px', '&.Mui-expanded': { minHeight: '48px' }, '& .MuiAccordionSummary-content': { my: 1 } }}
                     >
                         <AccountTreeIcon sx={{ mr: 1, color: 'action.active' }} />
                         <Typography variant="subtitle2">Detailed Route Hops ({routeData.length})</Typography>
                     </AccordionSummary>
                     <AccordionDetails sx={{ p: 1, overflow: 'hidden', display: 'flex' }}>
                         <Box sx={{ overflowX: 'auto', width: '100%', py: 1, px: 0.5 }}>
                             <Stack
                                 direction="row"
                                 spacing={0}
                                 alignItems="center"
                                 sx={{ minWidth: 'max-content', minHeight: 100, pb: 1 }}
                             >
                                 {routeData.map((hop, index) => (
                                     <HopDisplay
                                         key={`${hop.device_id || hop.ip || hop.mac || `hop-${hop.hop}`}-${index}`} // More robust key
                                         hopData={hop}
                                         isFirst={index === 0}
                                         isLast={index === routeData.length - 1}
                                     />
                                 ))}
                             </Stack>
                         </Box>
                    </AccordionDetails>
                </Accordion>
            )}

            {/* Raw Route Data Accordion (Conditional) */}
             {hasRawRouteString && (
                  <Accordion elevation={0} variant="outlined" slotProps={{ transition: { unmountOnExit: true } }}>
                    <AccordionSummary
                        expandIcon={<ExpandMore />} 
                        aria-controls={`panel-raw-${id}-content`}
                        id={`panel-raw-${id}-header`}
                        sx={{ minHeight: '40px', '&.Mui-expanded': { minHeight: '40px' }, '& .MuiAccordionSummary-content': { my: 0.5 } }}
                    >
                         <CodeIcon sx={{ mr: 1, color: 'action.active', fontSize: '1.2rem' }}/>
                        <Typography variant="caption" fontWeight="medium">Raw Route Data (Parsing Failed or Empty)</Typography>
                    </AccordionSummary>
                    <AccordionDetails sx={{ bgcolor: 'background.default', p: 1, borderTop: 1, borderColor: 'divider' }}>
                        <pre style={{ fontSize: '0.75rem', margin: 0, padding: '8px', borderRadius: '4px', overflowX: 'auto', whiteSpace: 'pre-wrap', wordBreak: 'break-all', maxHeight: '200px' }}>
                            {route.route} {/* Display the raw string */}
                        </pre>
                    </AccordionDetails>
                  </Accordion>
             )}

            {/* Message if no details at all */}
            {!hasDetails && ( // Should not happen if button logic is correct, but as fallback
                 <Typography color="text.secondary" sx={{ p: 2, textAlign: 'center', fontStyle: 'italic' }}>
                    No details available for this entry.
                 </Typography>
            )}
        </Box>
      </Collapse>
    </>
  );
};

export default HistoryItem;
// ----- End File: src\components\History\HistoryItem.jsx -----

// ----- End File: src\components\History\HistoryItem.jsx -----

// ----- File: src\components\History\HistoryList.jsx -----

// ----- File: src\components\History\HistoryList.jsx -----
import React from 'react';
import { List, Typography, Paper, Box, Alert } from '@mui/material';
import HistoryIcon from '@mui/icons-material/History';
import HistoryItem from './HistoryItem';

const HistoryList = ({ routes, title = "Route History" }) => {
  const hasRoutes = routes && routes.length > 0;

  return (
    <Paper elevation={2} sx={{ mt: 2, overflow: 'hidden' }}> {/* Hide overflow for clean corners */}
        <Box sx={{ display: 'flex', alignItems: 'center', p: 2, borderBottom: 1, borderColor: 'divider', bgcolor: 'background.paper' }}>
            <HistoryIcon sx={{ mr: 1.5, color: 'primary.main' }} />
            <Typography variant="h6" component="h2">{title}</Typography>
        </Box>

        {!hasRoutes ? (
            <Alert severity="info" sx={{ m: 2, mt: 0, borderTopLeftRadius: 0, borderTopRightRadius: 0 }}>
                No history records found matching the criteria.
            </Alert>
        ) : (
            // Disable padding on List to allow HistoryItem full width for its divider
            <List component="nav" aria-label="route history" disablePadding>
                {routes.map((route) => (
                    <HistoryItem key={route.id} route={route} />
                ))}
            </List>
        )}
    </Paper>
  );
};

export default HistoryList;

// ----- End File: src\components\History\HistoryList.jsx -----

// ----- File: src\components\RouteTrace\DirectRouteTraceInputForm.jsx -----

// ----- File: src\components\RouteTrace\DirectRouteTraceInputForm.jsx -----
// ----- File: src\components\RouteTrace\DirectRouteTraceInputForm.jsx -----
import React from 'react';
import { useDispatch } from 'react-redux';
import { TextField, Button, Box, Grid, CircularProgress, Tooltip, Typography, Paper } from '@mui/material'; // Added Paper
import NetworkCheckIcon from '@mui/icons-material/NetworkCheck';
import { updateDirectTraceInput, performDirectRouteTrace } from '../../store/slices/directRouteSlice';
import ErrorMessage from '../Common/ErrorMessage';

const DirectRouteTraceInputForm = ({ trace }) => {
  const dispatch = useDispatch();
  const {
    id: traceId,
    sourceDg, destinationDg, vrf,
    traceStatus, error
  } = trace;

  const handleInputChange = (field) => (event) => {
    dispatch(updateDirectTraceInput({ traceId, field, value: event.target.value }));
  };

  const handleTrace = () => {
    if (!sourceDg || !destinationDg || !vrf) {
        return;
    }
    dispatch(performDirectRouteTrace({ traceId, sourceDg, destinationDg, vrf }));
  };

  const isTracing = traceStatus === 'loading';
  const traceError = error && traceStatus === 'failed';

  // Validation checks for visual error state and button disabling
  const canTrace = sourceDg && destinationDg && vrf && !isTracing;
  const vrfError = (!vrf && (sourceDg || destinationDg)) || (!!error && error.includes("VRF Name"));
  const sourceDgError = !!error && error.includes("Source Gateway IP");
  const destDgError = !!error && error.includes("Destination Gateway IP");

  // Use a consistent helper text space or remove it entirely if not needed often
  const defaultHelperText = " "; // Reserve space even when no text

  return (
    // Wrap form content in Paper for visual grouping like the image
    <Paper elevation={0} variant="outlined" sx={{ p: { xs: 2, sm: 3 }, borderRadius: 1.5, backgroundColor: 'action.hover' }}>
        <Box component="form" noValidate autoComplete="off" onSubmit={(e) => { e.preventDefault(); if(canTrace) handleTrace(); }}>
            {/* Display general trace errors inside the Paper, above the inputs */}
            {traceError && <ErrorMessage error={error} title="Trace Error" />}

            {/* Grid container for Source/Destination Gateway side-by-side */}
            <Grid container spacing={{ xs: 2, md: 3 }} sx={{ mb: 2 }}> {/* Add bottom margin */}
                {/* Source Gateway Column */}
                <Grid item xs={12} md={6}>
                    <Typography variant="subtitle2" gutterBottom sx={{ color: 'primary.main', fontWeight: 'medium' }}>
                        Source Gateway
                    </Typography>
                    <TextField
                        label="Source Gateway IP *" // Add asterisk in label
                        value={sourceDg}
                        onChange={handleInputChange('sourceDg')}
                        variant="outlined"
                        fullWidth
                        required // HTML5 required (though validation mainly in JS/Thunk)
                        disabled={isTracing}
                        margin="dense"
                        error={sourceDgError}
                        helperText={sourceDgError ? "Required" : "Enter the starting Gateway IP for the trace"}
                    />
                </Grid>

                {/* Destination Gateway Column */}
                <Grid item xs={12} md={6}>
                    <Typography variant="subtitle2" gutterBottom sx={{ color: 'secondary.main', fontWeight: 'medium' }}>
                        Destination Gateway
                    </Typography>
                    <TextField
                        label="Destination Gateway IP *" // Add asterisk in label
                        value={destinationDg}
                        onChange={handleInputChange('destinationDg')}
                        variant="outlined"
                        fullWidth
                        required
                        disabled={isTracing}
                        margin="dense"
                        error={destDgError}
                        helperText={destDgError ? "Required" : "Enter the ending Gateway IP for the trace"}
                    />
                </Grid>
            </Grid>

            {/* VRF Input - Full width below the gateway columns */}
            <Box sx={{ mb: 3 }}> {/* Add bottom margin before button */}
                <Typography variant="subtitle2" gutterBottom sx={{ fontWeight: 'medium' }}>
                     VRF Name
                </Typography>
                <TextField
                    label="VRF Name *" // Add asterisk in label
                    value={vrf || ''}
                    onChange={handleInputChange('vrf')}
                    variant="outlined"
                    fullWidth
                    required
                    disabled={isTracing}
                    margin="dense"
                    error={vrfError}
                    helperText={vrfError ? "Required" : "Specify the VRF context for this trace (Required)"}
                />
            </Box>

            {/* Trace Button - Centered */}
            <Box sx={{ display: 'flex', justifyContent: 'center' }}>
                <Tooltip title={!canTrace ? "Please fill in all required fields (Source/Dest Gateway IP, VRF)" : "Run direct trace"}>
                    <span> {/* Wrap button for tooltip when disabled */}
                        <Button
                            variant="contained"
                            color="primary"
                            size="large"
                            startIcon={isTracing ? <CircularProgress size={20} color="inherit" /> : <NetworkCheckIcon />}
                            onClick={handleTrace}
                            disabled={!canTrace}
                            type="submit" // Allow form submission via Enter key
                            sx={{ minWidth: 180 }} // Give button a minimum width
                        >
                            {isTracing ? 'Tracing...' : 'Trace Direct Route'}
                        </Button>
                    </span>
                </Tooltip>
            </Box>
        </Box>
    </Paper>
  );
};

export default DirectRouteTraceInputForm;
// ----- End File: src\components\RouteTrace\DirectRouteTraceInputForm.jsx -----

// ----- End File: src\components\RouteTrace\DirectRouteTraceInputForm.jsx -----

// ----- File: src\components\RouteTrace\DirectRouteTraceSection.jsx -----

// ----- File: src\components\RouteTrace\DirectRouteTraceSection.jsx -----
// ----- File: src\components\RouteTrace\DirectRouteTraceSection.jsx -----
import React from 'react';
import { Paper, Box, IconButton, Tooltip, Divider } from '@mui/material';
import CloseIcon from '@mui/icons-material/Close';
import DirectRouteTraceInputForm from './DirectRouteTraceInputForm';
import DirectRouteVisualizer from './DirectRouteVisualizer';
import { useDispatch } from 'react-redux';
import { removeDirectTraceSection } from '../../store/slices/directRouteSlice';

const DirectRouteTraceSection = ({ trace, canRemove }) => {
  const dispatch = useDispatch();

  const handleRemove = () => {
      if (canRemove) {
          dispatch(removeDirectTraceSection(trace.id));
      }
  }

  return (
    <Paper
        elevation={3} // Slightly more pronounced elevation
        sx={{
            p: { xs: 2, sm: 3 }, // Responsive padding
            mb: 3,
            position: 'relative',
            borderRadius: 2, // Softer corners
            // Add a subtle border
            // border: (theme) => `1px solid ${theme.palette.divider}`
        }}
    >
        {canRemove && (
            <Tooltip title="Remove this trace section">
                <IconButton
                    onClick={handleRemove}
                    size="small"
                    aria-label="Remove trace section"
                    sx={{
                        position: 'absolute',
                        top: 8,
                        right: 8,
                        color: 'action.active',
                        '&:hover': { color: 'error.main' }
                    }}
                >
                    <CloseIcon fontSize="small" />
                </IconButton>
            </Tooltip>
        )}

        {/* Input Form */}
        <DirectRouteTraceInputForm trace={trace} />

        {/* Divider before results (only if trace has started or finished) */}
        {(trace.traceStatus !== 'idle' || trace.error) && (
            <Divider sx={{ my: 3 }} />
        )}

        {/* Visualizer */}
        <DirectRouteVisualizer trace={trace} />
    </Paper>
  );
};

export default DirectRouteTraceSection;

// ----- End File: src\components\RouteTrace\DirectRouteTraceSection.jsx -----

// ----- End File: src\components\RouteTrace\DirectRouteTraceSection.jsx -----

// ----- File: src\components\RouteTrace\DirectRouteVisualizer.jsx -----

// ----- File: src\components\RouteTrace\DirectRouteVisualizer.jsx -----
// ----- File: src\components\RouteTrace\DirectRouteVisualizer.jsx -----
import React from 'react';
import { Box, Typography, Stack, Paper, Chip, Divider } from '@mui/material';
import LoadingSpinner from '../Common/LoadingSpinner';
import ErrorMessage from '../Common/ErrorMessage';
import HopDisplay from './HopDisplay';

const DirectRouteVisualizer = ({ trace }) => {
  const {
    // sourceIp, destinationIp removed
    sourceDg, destinationDg, vrf, // Using Gateway IPs now
    traceResult, // This should hold the List[DetailedHop] from the backend
    traceStatus,
    error
  } = trace;

  const isLoading = traceStatus === 'loading';
  // Dg fetch errors are removed
  const isTraceError = error && traceStatus === 'failed';
  const displayError = isTraceError; // Only display trace error here

  // Use traceResult which holds the array of hops
  const hasResults = traceResult && traceResult.length > 0;

  // Don't render anything in idle state unless there's an error already
  if (traceStatus === 'idle' && !error) {
    return null; // Input form shows initial state message
  }

  return (
    <Box sx={{ mt: traceStatus !== 'idle' ? 2 : 0 }}> {/* Add margin top only if not idle */}
      <Typography variant="h6" gutterBottom align="center" sx={{ mb: 2 }}>
          Trace Results
      </Typography>

       {/* Display VRF if specified */}
       {vrf && (
            <Chip
                label={`VRF: ${vrf}`}
                size="small"
                variant="outlined"
                sx={{ display: 'block', mx: 'auto', mb: 2, width: 'fit-content' }}
            />
       )}

      {isLoading && <LoadingSpinner message="Performing direct route trace..." />}

      {/* Display specific trace error */}
      {displayError && <ErrorMessage error={error} title="Direct Route Trace Error" />}

      {/* Display results container only if not loading and no specific trace error */}
      {!isLoading && !displayError && (
        <Paper elevation={0} variant="outlined" sx={{ p: { xs: 1.5, sm: 2 } }}>
          {/* Header: Source Gateway -> Destination Gateway */}
          <Stack
             direction={{ xs: 'column', sm: 'row' }}
             justifyContent="space-around"
             alignItems="stretch" // Stretch items to equal height
             spacing={2}
             sx={{ mb: 2, textAlign: 'center' }}
          >
              {/* Source Gateway Box */}
              <Paper elevation={0} sx={{ p: 1.5, flexGrow: 1, border: 1, borderColor: 'primary.light', borderRadius: 1 }}>
                  <Typography variant="overline" display="block" sx={{ lineHeight: 1.2, color: 'primary.main' }}>Source Gateway</Typography>
                  {/* Display Source Gateway IP */}
                  <Typography variant="body2" sx={{ wordBreak: 'break-all', fontWeight: 500 }}>{sourceDg || 'N/A'}</Typography>
                   {/* Removed original source IP display */}
              </Paper>

              <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                 <Typography variant="h5" sx={{ color: 'text.secondary', transform: { xs: 'rotate(90deg)', sm: 'none'} }}>→</Typography>
              </Box>

              {/* Destination Gateway Box */}
              <Paper elevation={0} sx={{ p: 1.5, flexGrow: 1, border: 1, borderColor: 'secondary.light', borderRadius: 1 }}>
                  <Typography variant="overline" display="block" sx={{ lineHeight: 1.2, color: 'secondary.main' }}>Destination Gateway</Typography>
                  {/* Display Destination Gateway IP */}
                  <Typography variant="body2" sx={{ wordBreak: 'break-all', fontWeight: 500 }}>{destinationDg || 'N/A'}</Typography>
                   {/* Removed original destination IP display */}
              </Paper>
          </Stack>

          {/* Divider before hops */}
          <Divider sx={{ my: 2 }} />

          {/* Display Hops */}
          {hasResults ? (
             <Box sx={{ overflowX: 'auto', width: '100%', py: 1, px: 0.5 }}>
                <Stack
                  direction="row"
                  spacing={0} // Handled by HopDisplay arrows
                  alignItems="center"
                  sx={{
                    minWidth: 'max-content', // Ensure stack takes at least content width
                    minHeight: 100, // Minimum height for visual consistency
                    pb: 1 // Padding for scrollbar space
                  }}
                >
                  {traceResult.map((hop, index) => (
                    <HopDisplay
                      key={`${hop.device_id || hop.ip || hop.mac || `hop-${hop.hop}`}-${index}`} // More robust key
                      hopData={hop}
                      isFirst={index === 0}
                      isLast={index === traceResult.length - 1}
                    />
                  ))}
                </Stack>
             </Box>
          ) : (
             // Show message only if trace succeeded but returned no hops
             traceStatus === 'succeeded' && (
                <Typography align="center" color="text.secondary" sx={{ my: 3, fontStyle: 'italic' }}>
                    No route trace hops were returned between the specified gateways in VRF '{vrf}'.
                </Typography>
             )
          )}
        </Paper>
      )}
    </Box>
  );
};

export default DirectRouteVisualizer;

// ----- End File: src\components\RouteTrace\DirectRouteVisualizer.jsx -----

// ----- End File: src\components\RouteTrace\DirectRouteVisualizer.jsx -----

// ----- File: src\components\RouteTrace\HopDisplay.jsx -----

// ----- File: src\components\RouteTrace\HopDisplay.jsx -----
import React, { useState } from 'react';
import PropTypes from 'prop-types'; // Recommended for component documentation and validation
import {
    Paper,
    Typography,
    Box,
    Chip,
    IconButton,
    Popover,
    List,
    ListItem,
    ListItemText,
    Divider,
    Tooltip,
    Stack, // Use Stack for better internal layout
} from '@mui/material';
import ArrowForwardIcon from '@mui/icons-material/ArrowForward';
import InfoOutlinedIcon from '@mui/icons-material/InfoOutlined';
import NetworkWifiIcon from '@mui/icons-material/NetworkWifi'; // Keep for potential future use or different types
import RouterIcon from '@mui/icons-material/Router';
import ComputerIcon from '@mui/icons-material/Computer';
import DeviceUnknownIcon from '@mui/icons-material/DeviceUnknown'; // Default icon
import SettingsEthernetIcon from '@mui/icons-material/SettingsEthernet'; // Switch/Bridge icon
import SecurityIcon from '@mui/icons-material/Security'; // Potential Firewall icon

// Helper to format keys for display in Popover (improved robustness)
const formatDetailKey = (key) => {
    if (typeof key !== 'string' || !key) return '';
    return key
        .replace(/_/g, ' ') // Replace underscores with spaces
        .replace(/([A-Z])/g, ' $1') // Add space before capitals (for camelCase)
        .replace(/^./, (str) => str.toUpperCase()) // Capitalize first letter
        .trim(); // Remove potential leading/trailing whitespace
};

// Helper to get an icon based on hop type (enhanced with more types and map)
const getTypeIcon = (type) => {
    const lowerType = type?.toLowerCase() || '';

    // Map for clearer association and easier extension
    const iconMap = {
        router: <RouterIcon fontSize="inherit" sx={{ verticalAlign: 'middle' }} />,
        gateway: <RouterIcon fontSize="inherit" sx={{ verticalAlign: 'middle' }} />,
        firewall: <SecurityIcon fontSize="inherit" sx={{ verticalAlign: 'middle' }} />, // Dedicated FW icon
        host: <ComputerIcon fontSize="inherit" sx={{ verticalAlign: 'middle' }} />,
        endpoint: <ComputerIcon fontSize="inherit" sx={{ verticalAlign: 'middle' }} />,
        server: <ComputerIcon fontSize="inherit" sx={{ verticalAlign: 'middle' }} />, // Alias for host/endpoint
        switch: <SettingsEthernetIcon fontSize="inherit" sx={{ verticalAlign: 'middle' }} />,
        bridge: <SettingsEthernetIcon fontSize="inherit" sx={{ verticalAlign: 'middle' }} />,
        'l3 switch': <SettingsEthernetIcon fontSize="inherit" sx={{ verticalAlign: 'middle' }} />, // Handle multi-word types
        wifi: <NetworkWifiIcon fontSize="inherit" sx={{ verticalAlign: 'middle' }} />, // Example for Wifi type
        // Add more specific checks based on your network device types
    };

    // Find the first matching key in the map
    const matchedKey = Object.keys(iconMap).find(key => lowerType.includes(key));

    return matchedKey ? iconMap[matchedKey] : <DeviceUnknownIcon fontSize="inherit" sx={{ verticalAlign: 'middle' }} />;
};

/**
 * Displays information for a single hop in a network trace visualization.
 * Shows primary identifier (hostname/IP/MAC), secondary info (IP/MAC/Type),
 * and provides a popover for detailed information.
 */
const HopDisplay = ({ hopData, isFirst, isLast }) => {
    const [anchorEl, setAnchorEl] = useState(null);

    const handlePopoverOpen = (event) => {
        setAnchorEl(event.currentTarget);
    };

    const handlePopoverClose = () => {
        setAnchorEl(null);
    };

    const open = Boolean(anchorEl);

    // --- Validate hopData ---
    if (!hopData) {
        // Optionally return null or a placeholder if data is missing
        console.warn('HopDisplay received null or undefined hopData.');
        return null; // Or render an error/placeholder state
    }

    // --- Extract Data ---
    // Destructure known fields and collect the rest
    const {
        hop, // Required: The hop number
        ip,
        type,
        hostname,
        destination_network,
        vrf,
        destination_dg_ip,
        mpls_label,
        passed_firewall,
        device_id,
        destination_mac,
        next_hop_interface,
        nexthop_int_ip,
        mac,
        rtt, // Example: Include round-trip time if available
        // Collect any other properties passed in hopData
        ...otherDetails
    } = hopData;

    // Ensure hop number is present, default if necessary (though ideally it should always exist)
    const hopNumber = typeof hop === 'number' ? hop : '?';

    // --- Prepare Details for Popover ---
    // Combine explicitly listed fields (for order/importance) with other details
    const allDetails = {
        // Explicitly list fields likely to be useful in popover, controlling order
        IP: ip,
        MAC: mac,
        Type: type,
        Hostname: hostname,
        RTT: rtt ? `${rtt} ms` : undefined, // Format RTT if present
        Device_ID: device_id,
        VRF: vrf,
        Destination_Network: destination_network,
        Next_Hop_Interface: next_hop_interface,
        Nexthop_Interface_IP: nexthop_int_ip,
        Destination_MAC: destination_mac,
        Destination_DG_IP: destination_dg_ip,
        MPLS_Label: mpls_label,
        Passed_Firewall: passed_firewall, // Booleans will be handled later
        ...otherDetails, // Include any other non-null/empty fields dynamically
    };

    // Filter out null, undefined, or empty string values
    const detailsToShow = Object.entries(allDetails)
        .filter(([key, value]) => value !== null && value !== undefined && value !== '');


    // --- Determine Display Text ---
    // Primary: Hostname > IP > MAC > 'Unknown Device'
    const primaryDisplay = hostname || ip || mac || 'Unknown Device';
    // Secondary:
    // - If hostname is primary: Show IP or MAC
    // - If IP/MAC is primary: Show Type if available
    // - Otherwise: null
    let secondaryDisplay = null;
    if (hostname && (ip || mac)) {
        secondaryDisplay = ip || mac; // Show IP first if both exist
    } else if ((ip || mac) && type) {
        secondaryDisplay = type;
    }

    // Unique ID for ARIA attributes
    const popoverId = open ? `hop-popover-${hopNumber}-${ip || mac || 'unknown'}` : undefined;

    return (
        <Box sx={{ display: 'flex', alignItems: 'center', position: 'relative' }}>
            {/* Arrow Connector (conditionally rendered) */}
            {!isFirst && (
                <ArrowForwardIcon
                    aria-hidden="true" // Decorative element
                    sx={{
                        mx: { xs: 0.5, sm: 1 }, // Responsive margin
                        color: 'text.secondary',
                        fontSize: { xs: '1rem', sm: '1.2rem' }, // Responsive size
                        flexShrink: 0, // Prevent arrow from shrinking
                    }}
                />
            )}

            {/* Hop Information Paper */}
            <Paper
                elevation={1}
                variant="outlined"
                sx={{
                    p: 1.5,
                    minWidth: 180,
                    maxWidth: 250,
                    textAlign: 'center',
                    position: 'relative', // For absolute positioning of button
                    borderRadius: 1.5, // Slightly more rounded corners
                    flexShrink: 0, // Prevent paper from shrinking excessively
                    overflow: 'hidden', // Ensure content fits
                }}
            >
                {/* Details Button (only show if there are details) */}
                {detailsToShow.length > 0 && (
                    <Tooltip title="Show Details">
                        {/* Position wrapper for Tooltip when button is disabled */}
                        <span>
                            <IconButton
                                aria-label={`Show details for hop ${hopNumber}`}
                                size="small"
                                onClick={handlePopoverOpen}
                                aria-describedby={popoverId}
                                // disabled={detailsToShow.length === 0} // Disabled state handled by conditional render
                                sx={{
                                    position: 'absolute',
                                    top: 4,
                                    right: 4,
                                    p: '2px',
                                    color: 'action.active', // Use theme color
                                    '&:hover': {
                                        // Optional: slightly darker on hover
                                        // backgroundColor: 'action.hover',
                                    },
                                }}
                            >
                                <InfoOutlinedIcon fontSize="inherit" />
                            </IconButton>
                        </span>
                    </Tooltip>
                )}

                {/* Stack for vertical layout of hop info */}
                <Stack spacing={0.5} alignItems="center" sx={{ pt: detailsToShow.length > 0 ? 1.5 : 0 }}> {/* Add padding top if info icon exists */}
                    {/* Hop Number Chip */}
                    <Chip
                        label={`Hop ${hopNumber}`}
                        size="small"
                        variant="outlined"
                        color="primary" // Add subtle color
                        sx={{ mb: 0.5, height: 20, fontSize: '0.7rem', fontWeight: 'medium' }}
                    />

                    {/* Primary Display (Hostname or IP/MAC) */}
                    <Tooltip title={primaryDisplay} enterDelay={1000}>
                        <Typography
                            variant="body2"
                            sx={{
                                fontWeight: 500,
                                wordBreak: 'break-all', // Important for long names/IPs
                                lineHeight: 1.3,
                                // Optional: Add ellipsis for overflow if preferred
                                // whiteSpace: 'nowrap',
                                // overflow: 'hidden',
                                // textOverflow: 'ellipsis',
                                // maxWidth: '100%', // Needed for ellipsis
                            }}
                        >
                            {primaryDisplay}
                        </Typography>
                    </Tooltip>

                    {/* Secondary Display (IP/MAC or Type) */}
                    {secondaryDisplay && (
                        <Tooltip title={secondaryDisplay} enterDelay={1000}>
                            <Typography
                                variant="caption"
                                sx={{
                                    color: 'text.secondary',
                                    display: 'block',
                                    wordBreak: 'break-all',
                                    lineHeight: 1.2,
                                    // Optional: Ellipsis for secondary display too
                                    // whiteSpace: 'nowrap',
                                    // overflow: 'hidden',
                                    // textOverflow: 'ellipsis',
                                    // maxWidth: '100%',
                                }}
                            >
                                {secondaryDisplay}
                            </Typography>
                        </Tooltip>
                    )}

                    {/* Chip for Type (if type exists and wasn't shown as secondary) */}
                    {type && secondaryDisplay !== type && (
                        <Chip
                            icon={getTypeIcon(type)}
                            label={type}
                            size="small"
                            variant="filled" // Filled emphasizes type info
                            color="default" // Or another appropriate color
                            sx={{
                                mt: 0.5,
                                fontSize: '0.7rem',
                                height: 'auto', // Auto height for variable content
                                maxWidth: 'calc(100% - 16px)', // Prevent chip overflowing Paper padding
                                '& .MuiChip-icon': { fontSize: '0.8rem', ml: 0.5 },
                                '& .MuiChip-label': {
                                    px: 0.8,
                                    py: 0.2,
                                    whiteSpace: 'nowrap',
                                    overflow: 'hidden',
                                    textOverflow: 'ellipsis',
                                    display: 'block', // Ensure label respects width
                                }
                            }}
                        />
                    )}
                </Stack>
            </Paper>

            {/* Popover for Additional Details */}
            <Popover
                id={popoverId}
                open={open}
                anchorEl={anchorEl}
                onClose={handlePopoverClose}
                anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
                transformOrigin={{ vertical: 'top', horizontal: 'center' }}
                slotProps={{
                    paper: {
                        elevation: 4,
                        sx: {
                            maxWidth: 350,
                            p: 0, // Padding handled by ListItems
                            borderRadius: 1.5,
                            border: (theme) => `1px solid ${theme.palette.divider}`, // Subtle border
                        }
                    }
                }}
            >
                {/* Box containing Popover content */}
                <Box>
                    <Typography variant="subtitle2" sx={{ px: 2, pt: 1.5, pb: 1, fontWeight: 'bold' }}>
                        Hop {hopNumber} Details
                    </Typography>
                    <Divider />
                    <List dense disablePadding sx={{ maxHeight: 350, overflowY: 'auto' }}> {/* Increased max height */}
                        {detailsToShow.map(([key, value]) => (
                            <ListItem key={key} dense divider sx={{ py: 0.8, alignItems: 'flex-start' }}> {/* Align items start for long secondary text */}
                                <ListItemText
                                    primary={formatDetailKey(key)}
                                    secondary={
                                        // Handle boolean display explicitly
                                        typeof value === 'boolean' ? (value ? 'Yes' : 'No') : String(value) // Ensure value is string for display
                                    }
                                    primaryTypographyProps={{
                                        variant: 'caption',
                                        fontWeight: 'medium',
                                        color: 'text.secondary',
                                        component: 'div', // Allow wrapping if needed
                                    }}
                                    secondaryTypographyProps={{
                                        variant: 'body2',
                                        color: 'text.primary',
                                        sx: {
                                            whiteSpace: 'pre-wrap', // Preserve whitespace and wrap
                                            wordBreak: 'break-all', // Break long strings
                                            lineHeight: 1.3, // Adjust line height for readability
                                        }
                                    }}
                                    sx={{ my: 0 }} // Reset default margins
                                />
                            </ListItem>
                        ))}
                        {/* Fallback message if filtering somehow removed all details (unlikely with current logic) */}
                        {detailsToShow.length === 0 && (
                            <ListItem dense>
                                <ListItemText secondary="No additional details available." secondaryTypographyProps={{ variant: 'caption', fontStyle: 'italic', textAlign: 'center' }} />
                            </ListItem>
                        )}
                    </List>
                </Box>
            </Popover>
        </Box>
    );
};

// Define PropTypes for type checking and documentation
HopDisplay.propTypes = {
    /**
     * The data object for the hop. Requires at least a 'hop' number.
     * Other fields like 'ip', 'hostname', 'type', etc., are used if present.
     */
    hopData: PropTypes.shape({
        hop: PropTypes.number.isRequired,
        ip: PropTypes.string,
        mac: PropTypes.string,
        hostname: PropTypes.string,
        type: PropTypes.string,
        rtt: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
        // Add other expected fields as needed
    }).isRequired,
    /**
     * Flag indicating if this is the first hop in the sequence (hides the preceding arrow).
     */
    isFirst: PropTypes.bool,
    /**
     * Flag indicating if this is the last hop in the sequence (currently unused but good practice).
     */
    isLast: PropTypes.bool,
};

// Default props for flags
HopDisplay.defaultProps = {
    isFirst: false,
    isLast: false,
};


export default HopDisplay;

// ----- End File: src\components\RouteTrace\HopDisplay.jsx -----

// ----- File: src\components\RouteTrace\MacTraceDisplay.jsx -----

// ----- File: src\components\RouteTrace\MacTraceDisplay.jsx -----
import React from 'react';
import { Paper, Typography, Box, Stack, Chip, Divider } from '@mui/material';
import CompareArrowsIcon from '@mui/icons-material/CompareArrows';
import LoadingSpinner from '../Common/LoadingSpinner';
import ErrorMessage from '../Common/ErrorMessage';
import HopDisplay from './HopDisplay';

const MacTraceDisplay = ({ label, hops, isLoading, error }) => {
  // hops is an array of DetailedHop objects or null/undefined

  const hasHops = hops && hops.length > 0;

  return (
    // Use outlined Paper for a lighter look, integrate into the main visualizer flow
    <Paper elevation={0} variant="outlined" sx={{ p: 1.5, my: 1.5, bgcolor: 'action.hover' }}>
      <Stack direction="row" alignItems="center" justifyContent="center" spacing={1} sx={{ mb: 1.5 }}>
        <CompareArrowsIcon fontSize="small" color="action" />
        <Typography variant="caption" fontWeight="medium" sx={{ color: 'text.secondary' }}>{label}</Typography>
      </Stack>

      {isLoading && <LoadingSpinner size={25} message="Tracing MAC path..." />}
      {error && <ErrorMessage error={error} title="MAC Trace Error" />}

      {!isLoading && !error && (
        <>
          {hops === null || hops === undefined ? (
            <Typography variant="caption" display="block" align="center" sx={{ fontStyle: 'italic', color: 'text.disabled' }}>
                MAC Trace not initiated.
            </Typography>
          ) : !hasHops ? (
            <Typography variant="caption" display="block" align="center" sx={{ fontStyle: 'italic', color: 'text.secondary' }}>
                No MAC trace hops found.
            </Typography>
          ) : (
            <Box sx={{ overflowX: 'auto', width: '100%', pb: 1 }}>
                <Stack
                  direction="row"
                  spacing={0} // Spacing handled by arrows in HopDisplay
                  alignItems="center" // Center items vertically
                  sx={{
                    minWidth: 'max-content', // Fit content width
                    py: 1,
                    px: 0.5,
                    minHeight: 80, // Ensure minimum height even with few hops
                  }}
                >
                  {hops.map((hop, index) => (
                    <HopDisplay
                      // Use a more robust key including MAC if available
                      key={`${hop.device_id || hop.ip || hop.mac || `hop-${hop.hop}`}-${index}`}
                      hopData={hop} // Pass the full detailed hop object
                      isFirst={index === 0}
                      isLast={index === hops.length - 1}
                    />
                  ))}
                </Stack>
            </Box>
          )}
        </>
      )}
    </Paper>
  );
};

export default MacTraceDisplay;

// ----- End File: src\components\RouteTrace\MacTraceDisplay.jsx -----

// ----- File: src\components\RouteTrace\MacTraceInputForm.jsx -----

// ----- File: src\components\RouteTrace\MacTraceInputForm.jsx -----
// Update Grid component to use Grid v2 API
import React from 'react';
import { useDispatch } from 'react-redux';
import { TextField, Button, Box, Grid, CircularProgress, Tooltip, IconButton, InputAdornment, Typography } from '@mui/material';
import SettingsEthernetIcon from '@mui/icons-material/SettingsEthernet';
import SyncIcon from '@mui/icons-material/Sync';
import SyncProblemIcon from '@mui/icons-material/SyncProblem';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import EditIcon from '@mui/icons-material/Edit';
import { updateMacTraceInput, fetchMacDefaultGateway, performMacTrace } from '../../store/slices/macTraceSlice';
import ErrorMessage from '../Common/ErrorMessage';

const MacTraceInputForm = ({ trace }) => {
  const dispatch = useDispatch();
  const {
    id: traceId,
    ip, // Endpoint IP
    dg, // Endpoint Default Gateway
    dgStatus,
    traceStatus,
    error
  } = trace;

  const handleInputChange = (field) => (event) => {
    dispatch(updateMacTraceInput({ traceId, field, value: event.target.value }));
  };

  const handleFetchDg = () => {
    if (ip) {
      dispatch(fetchMacDefaultGateway({ ip, traceId }));
    }
  };

  const handleTrace = () => {
    dispatch(performMacTrace({ traceId, ip, dg }));
  };

  const isFetchingDg = dgStatus === 'loading';
  const isTracing = traceStatus === 'loading';
  const dgDisabled = isFetchingDg; // Only disable DG field if actively fetching it

  const renderDgStatusIcon = () => {
    switch (dgStatus) {
      case 'loading':
        return <InputAdornment position="end"><CircularProgress size={20} sx={{ mr: 1 }} /></InputAdornment>;
      case 'succeeded':
        return <InputAdornment position="end"><Tooltip title="Gateway automatically fetched"><CheckCircleIcon color="success" sx={{ mr: 1 }} /></Tooltip></InputAdornment>;
      case 'failed':
        return (
            <InputAdornment position="end">
                <Tooltip title="Failed to fetch gateway. Click to retry.">
                     <IconButton onClick={handleFetchDg} size="small" disabled={!ip || isTracing} sx={{ mr: 0.5 }}>
                        <SyncProblemIcon color="error" />
                    </IconButton>
                </Tooltip>
            </InputAdornment>
        );
      case 'manual':
         return <InputAdornment position="end"><Tooltip title="Gateway manually entered"><EditIcon color="action" sx={{ mr: 1 }} /></Tooltip></InputAdornment>;
      default: // idle
        return ( // Show refresh button when idle and IP exists
             ip ? <InputAdornment position="end">
                 <Tooltip title="Fetch Gateway">
                     <IconButton onClick={handleFetchDg} size="small" disabled={isTracing} sx={{ mr: 0.5 }}> <SyncIcon /> </IconButton>
                 </Tooltip>
             </InputAdornment> : null
        );
    }
  };

  // Check for specific errors
  const dgFetchError = error && dgStatus === 'failed';
  const traceError = error && traceStatus === 'failed' && !dgFetchError;

  const canTrace = ip && dg && !isTracing && !isFetchingDg;

  return (
    <Box component="form" noValidate autoComplete="off" onSubmit={(e) => { e.preventDefault(); if(canTrace) handleTrace(); }}>
        {dgFetchError && <ErrorMessage error={error} title="Gateway Fetch Error" />}
        {traceError && <ErrorMessage error={error} title="MAC Trace Error" />}

        {/* Grid v2: No 'item' prop, use direct breakpoint props */}
        <Grid container spacing={2} alignItems="flex-start">
            {/* Endpoint IP */}
            {/* Removed 'item' prop */}
            <Grid xs={12} sm={6}>
                 <Typography variant="subtitle2" gutterBottom sx={{ color: 'text.primary' }}>Endpoint</Typography>
                <TextField
                    label="Endpoint IP Address"
                    value={ip}
                    onChange={handleInputChange('ip')}
                    onBlur={handleFetchDg} // Fetch DG when IP field loses focus
                    variant="outlined"
                    fullWidth
                    required
                    disabled={isTracing}
                    margin="dense"
                    error={!!dgFetchError} // Highlight if related DG fetch failed
                />
            </Grid>

             {/* Default Gateway (DG) */}
             {/* Removed 'item' prop */}
            <Grid xs={12} sm={6}>
                <Typography variant="subtitle2" gutterBottom sx={{ color: 'text.primary' }}>Gateway</Typography>
                 <TextField
                    label="Endpoint Default Gateway"
                    value={dg}
                    onChange={handleInputChange('dg')}
                    variant="outlined"
                    fullWidth
                    required
                    disabled={dgDisabled || isTracing}
                    margin="dense"
                    InputProps={{
                        endAdornment: renderDgStatusIcon(),
                    }}
                    error={!!dgFetchError} // Highlight if DG fetch failed
                    helperText={dgStatus === 'failed' ? "Check IP and network connectivity" : "Enter DG or fetch automatically"}
                 />
            </Grid>
        </Grid>

        {/* Trace Button */}
        <Box sx={{ display: 'flex', justifyContent: 'center', mt: 3, mb: 1 }}>
            <Button
                variant="contained"
                color="primary"
                size="large"
                startIcon={isTracing ? <CircularProgress size={20} color="inherit" /> : <SettingsEthernetIcon />}
                onClick={handleTrace}
                disabled={!canTrace}
                type="submit" // Allow form submission via Enter key
            >
                {isTracing ? 'Tracing...' : 'Trace MAC Path'}
            </Button>
        </Box>
    </Box>
  );
};

export default MacTraceInputForm;
// ----- End File: src\components\RouteTrace\MacTraceInputForm.jsx -----

// ----- End File: src\components\RouteTrace\MacTraceInputForm.jsx -----

// ----- File: src\components\RouteTrace\MacTraceSection.jsx -----

// ----- File: src\components\RouteTrace\MacTraceSection.jsx -----
import React from 'react';
import { Paper, Box, IconButton, Tooltip, Divider } from '@mui/material';
import CloseIcon from '@mui/icons-material/Close';
import MacTraceInputForm from './MacTraceInputForm';
import MacTraceVisualizer from './MacTraceVisualizer';
import { useDispatch } from 'react-redux';
import { removeMacTraceSection } from '../../store/slices/macTraceSlice';

const MacTraceSection = ({ trace, canRemove }) => {
  const dispatch = useDispatch();

  const handleRemove = () => {
      if (canRemove) {
          dispatch(removeMacTraceSection(trace.id));
      }
  }

  return (
    <Paper
        elevation={3}
        sx={{
            p: { xs: 2, sm: 3 }, // Responsive padding
            mb: 3,
            position: 'relative',
            borderRadius: 2, // Softer corners
        }}
    >
        {canRemove && (
            <Tooltip title="Remove this trace section">
                <IconButton
                    onClick={handleRemove}
                    size="small"
                    aria-label="Remove MAC trace section"
                    sx={{
                        position: 'absolute',
                        top: 8,
                        right: 8,
                        color: 'action.active',
                        '&:hover': { color: 'error.main' }
                    }}
                >
                    <CloseIcon fontSize="small" />
                </IconButton>
            </Tooltip>
        )}

        {/* Input Form */}
        <MacTraceInputForm trace={trace} />

        {/* Divider before results (only if trace has started or finished) */}
        {(trace.traceStatus !== 'idle' || trace.error) && (
            <Divider sx={{ my: 3 }} />
        )}

        {/* Visualizer */}
        <MacTraceVisualizer trace={trace} />
    </Paper>
  );
};

export default MacTraceSection;

// ----- End File: src\components\RouteTrace\MacTraceSection.jsx -----

// ----- File: src\components\RouteTrace\MacTraceVisualizer.jsx -----

// ----- File: src\components\RouteTrace\MacTraceVisualizer.jsx -----
import React from 'react';
import { Box, Typography, Stack, Paper, Divider } from '@mui/material';
import LoadingSpinner from '../Common/LoadingSpinner';
import ErrorMessage from '../Common/ErrorMessage';
import HopDisplay from './HopDisplay'; // Reuse HopDisplay

const MacTraceVisualizer = ({ trace }) => {
  const {
    ip, // Endpoint IP
    dg, // Default Gateway
    traceResult, // Array of DetailedHop objects
    traceStatus,
    error
  } = trace;

  const isLoading = traceStatus === 'loading';
  // Separate DG fetch errors from trace errors
  const isDgError = error && trace.dgStatus === 'failed';
  const isTraceError = error && traceStatus === 'failed' && !isDgError;
  const displayError = isTraceError; // Only display trace error here

  const hasResults = traceResult && traceResult.length > 0;

  // Don't render anything in idle state unless there's an error already
   if (traceStatus === 'idle' && !error) {
      return null; // Input form shows initial state message
   }

  return (
     <Box sx={{ mt: traceStatus !== 'idle' ? 2 : 0 }}>
      <Typography variant="h6" gutterBottom align="center" sx={{ mb: 2 }}>
          MAC Trace Results
      </Typography>

      {isLoading && <LoadingSpinner message="Performing MAC trace..." />}

      {/* Display specific trace error */}
      {displayError && <ErrorMessage error={error} title="MAC Trace Error" />}

      {/* Display results container only if not loading and no specific trace error */}
      {!isLoading && !displayError && (
        <Paper elevation={0} variant="outlined" sx={{ p: { xs: 1.5, sm: 2 } }}>
            {/* Header: Endpoint <-> Gateway */}
            <Stack
                direction={{ xs: 'column', sm: 'row' }}
                justifyContent="space-around"
                alignItems="stretch"
                spacing={2}
                sx={{ mb: 2, textAlign: 'center' }}
            >
                 {/* Endpoint Box */}
                 <Paper elevation={0} sx={{ p: 1.5, flexGrow: 1, border: 1, borderColor: 'primary.light', borderRadius: 1 }}>
                    <Typography variant="overline" display="block" sx={{ lineHeight: 1.2, color: 'primary.main' }}>Endpoint</Typography>
                    <Typography variant="body1" sx={{ wordBreak: 'break-all', fontWeight: 500 }}>{ip || 'N/A'}</Typography>
                 </Paper>

                <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                   <Typography variant="h5" sx={{ color: 'text.secondary', transform: { xs: 'rotate(90deg)', sm: 'none'} }}>↔</Typography>
                </Box>

                 {/* Gateway Box */}
                 <Paper elevation={0} sx={{ p: 1.5, flexGrow: 1, border: 1, borderColor: 'grey.400', borderRadius: 1 }}>
                    <Typography variant="overline" display="block" sx={{ lineHeight: 1.2 }}>Gateway</Typography>
                    <Typography variant="body1" sx={{ wordBreak: 'break-all', fontWeight: 500 }}>{dg || 'N/A'}</Typography>
                 </Paper>
            </Stack>

            {/* Divider before hops */}
            <Divider sx={{ my: 2 }} />

          {/* Display Hops */}
          {hasResults ? (
             <Box sx={{ overflowX: 'auto', width: '100%', py: 1, px: 0.5 }}>
                <Stack
                  direction="row"
                  spacing={0} // Handled by HopDisplay
                  alignItems="center"
                  sx={{
                    minWidth: 'max-content',
                    minHeight: 100,
                    pb: 1,
                  }}
                >
                  {traceResult.map((hop, index) => (
                    <HopDisplay
                      key={`${hop.device_id || hop.ip || hop.mac || `hop-${hop.hop}`}-${index}`} // Robust key
                      hopData={hop}
                      isFirst={index === 0}
                      isLast={index === traceResult.length - 1}
                    />
                  ))}
                </Stack>
             </Box>
          ) : (
             // Show message only if trace succeeded but returned no hops
             traceStatus === 'succeeded' && (
                <Typography align="center" color="text.secondary" sx={{ my: 3, fontStyle: 'italic' }}>
                    No MAC trace hops were returned. The gateway might be directly connected or unreachable at Layer 2.
                </Typography>
             )
          )}
        </Paper>
      )}
    </Box>
  );
};

export default MacTraceVisualizer;

// ----- End File: src\components\RouteTrace\MacTraceVisualizer.jsx -----

// ----- File: src\components\RouteTrace\RouteComparisonContainer.jsx -----

// ----- File: src\components\RouteTrace\RouteComparisonContainer.jsx -----
// Update Grid component to use Grid v2 API
import React from 'react';
import { Box, Grid, Alert } from '@mui/material';
import ErrorOutlineIcon from '@mui/icons-material/ErrorOutline';

// Generic container for side-by-side comparison of trace sections
const RouteComparisonContainer = ({ traces = [], SectionComponent }) => {
  // Check if a valid SectionComponent was provided
  if (!SectionComponent) {
    console.error("RouteComparisonContainer requires a valid SectionComponent prop.");
    return (
        <Alert severity="error" icon={<ErrorOutlineIcon />} sx={{ mt: 2 }}>
            Configuration Error: Cannot display comparison items. SectionComponent is missing.
        </Alert>
    );
  }

  // Determine if the remove button should be shown in child sections
  const canRemove = traces.length > 1;

  // Define responsive grid sizing using Grid v2 direct props
  let columnProps = {};
  if (traces.length === 1) {
      columnProps = { xs: 12 }; // Full width if only one
  } else if (traces.length === 2) {
      columnProps = { xs: 12, md: 6 }; // 2 columns on medium screens and up
  } else if (traces.length === 3) {
      columnProps = { xs: 12, md: 6, lg: 4 }; // 3 columns on large screens and up
  } else { // 4 or more
      columnProps = { xs: 12, sm: 6, md: 4, lg: 3 }; // Max 4 columns on large screens
  }


  return (
    <Box sx={{ flexGrow: 1 }}>
      {/* Use Grid container with appropriate spacing */}
      {/* No 'item' prop needed on the container */}
      <Grid container spacing={{ xs: 2, md: 3 }}>
        {traces.map((trace) => (
          // Child Grid components now use breakpoint props directly
          // Removed the 'item' prop
          <Grid {...columnProps} key={trace.id}>
             {/* Render the provided SectionComponent, passing the trace data and canRemove flag */}
             {/* Ensure SectionComponent handles height/layout internally (e.g., height: '100%') */}
             <SectionComponent trace={trace} canRemove={canRemove} />
          </Grid>
        ))}
      </Grid>
    </Box>
  );
};

export default RouteComparisonContainer;
// ----- End File: src\components\RouteTrace\RouteComparisonContainer.jsx -----

// ----- End File: src\components\RouteTrace\RouteComparisonContainer.jsx -----

// ----- File: src\components\RouteTrace\RouteInputForm.jsx -----

// ----- File: src\components\RouteTrace\RouteInputForm.jsx -----
// Update Grid component to use Grid v2 API
import React from 'react';
import { useDispatch } from 'react-redux';
import { TextField, Button, Box, Grid, CircularProgress, Tooltip, IconButton, InputAdornment, Typography } from '@mui/material';
import TravelExploreIcon from '@mui/icons-material/TravelExplore';
import SyncIcon from '@mui/icons-material/Sync';
import SyncProblemIcon from '@mui/icons-material/SyncProblem';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import EditIcon from '@mui/icons-material/Edit';
import { updateTraceInput, fetchDefaultGateway, performFullTrace } from '../../store/slices/routeTraceSlice';
import ErrorMessage from '../Common/ErrorMessage';

const RouteInputForm = ({ trace }) => {
  const dispatch = useDispatch();
  const {
    id: traceId,
    sourceIp, destinationIp, sourceDg, destinationDg,
    sourceDgStatus, destinationDgStatus, traceStatus, error
  } = trace;

  const handleInputChange = (field) => (event) => {
    dispatch(updateTraceInput({ traceId, field, value: event.target.value }));
  };

  const handleFetchDg = (type) => () => {
    const ip = type === 'source' ? sourceIp : destinationIp;
    if (ip) {
      dispatch(fetchDefaultGateway({ ip, type, traceId }));
    }
  };

  const handleTrace = () => {
    dispatch(performFullTrace({ traceId, sourceIp, destinationIp, sourceDg, destinationDg }));
  };

  const isFetchingSourceDg = sourceDgStatus === 'loading';
  const isFetchingDestDg = destinationDgStatus === 'loading';
  const isTracing = traceStatus === 'loading';

  // Disable DG field only when actively fetching that specific DG
  const sourceDgDisabled = isFetchingSourceDg;
  const destDgDisabled = isFetchingDestDg;

  const renderDgStatusIcon = (status, type) => {
    const ip = type === 'source' ? sourceIp : destinationIp;
    const handleRetry = handleFetchDg(type);

    switch (status) {
      case 'loading':
        return <InputAdornment position="end"><CircularProgress size={20} sx={{ mr: 1 }} /></InputAdornment>;
      case 'succeeded':
        return <InputAdornment position="end"><Tooltip title="Gateway automatically fetched"><CheckCircleIcon color="success" sx={{ mr: 1 }} /></Tooltip></InputAdornment>;
      case 'failed':
        return (
            <InputAdornment position="end">
                <Tooltip title="Failed to fetch gateway. Click to retry.">
                     <IconButton onClick={handleRetry} size="small" disabled={!ip || isTracing} sx={{ mr: 0.5 }}>
                        <SyncProblemIcon color="error" />
                    </IconButton>
                </Tooltip>
            </InputAdornment>
        );
      case 'manual':
         return <InputAdornment position="end"><Tooltip title="Gateway manually entered"><EditIcon color="action" sx={{ mr: 1 }} /></Tooltip></InputAdornment>;
      default: // idle
        return ( // Show refresh button when idle and IP exists
             ip ? <InputAdornment position="end">
                 <Tooltip title="Fetch Gateway">
                     <IconButton onClick={handleRetry} size="small" disabled={isTracing} sx={{ mr: 0.5 }}> <SyncIcon /> </IconButton>
                 </Tooltip>
             </InputAdornment> : null
        );
    }
  };

  // Check for specific errors
  const dgFetchError = error && (sourceDgStatus === 'failed' || destinationDgStatus === 'failed');
  const traceError = error && (traceStatus === 'failed' || traceStatus === 'partial_success') && !dgFetchError;

  const canTrace = sourceIp && destinationIp && sourceDg && destinationDg && !isTracing && !isFetchingSourceDg && !isFetchingDestDg;

  return (
    <Box component="form" noValidate autoComplete="off" onSubmit={(e) => { e.preventDefault(); if(canTrace) handleTrace(); }}>
        {/* Display DG fetch errors prominently */}
        {dgFetchError && <ErrorMessage error={error} title="Gateway Fetch Error" />}
        {/* Display general trace errors separately */}
        {traceError && <ErrorMessage error={error} title="Trace Error" />}

        {/* Grid v2: No 'item' prop, use direct breakpoint props */}
        <Grid container spacing={2} alignItems="flex-start">
            {/* Source Column */}
            {/* Removed 'item' prop */}
            <Grid xs={12} md={6}>
                <Typography variant="subtitle2" gutterBottom sx={{ color: 'primary.main' }}>Source</Typography>
                <TextField
                    label="Source IP Address"
                    value={sourceIp}
                    onChange={handleInputChange('sourceIp')}
                    onBlur={handleFetchDg('source')}
                    variant="outlined"
                    fullWidth
                    required
                    disabled={isTracing}
                    margin="dense"
                    error={!!(dgFetchError && sourceDgStatus === 'failed')}
                />
                <TextField
                    label="Source Default Gateway"
                    value={sourceDg}
                    onChange={handleInputChange('sourceDg')}
                    variant="outlined"
                    fullWidth
                    required
                    disabled={sourceDgDisabled || isTracing}
                    margin="dense"
                    InputProps={{
                        endAdornment: renderDgStatusIcon(sourceDgStatus, 'source'),
                    }}
                    error={!!(dgFetchError && sourceDgStatus === 'failed')}
                    helperText={sourceDgStatus === 'failed' ? "Check IP and network connectivity" : "Enter DG or fetch automatically"}
                />
            </Grid>

            {/* Destination Column */}
             {/* Removed 'item' prop */}
            <Grid xs={12} md={6}>
                 <Typography variant="subtitle2" gutterBottom sx={{ color: 'secondary.main' }}>Destination</Typography>
                 <TextField
                    label="Destination IP Address"
                    value={destinationIp}
                    onChange={handleInputChange('destinationIp')}
                    onBlur={handleFetchDg('destination')}
                    variant="outlined"
                    fullWidth
                    required
                    disabled={isTracing}
                    margin="dense"
                    error={!!(dgFetchError && destinationDgStatus === 'failed')}
                 />
                 <TextField
                    label="Destination Default Gateway"
                    value={destinationDg}
                    onChange={handleInputChange('destinationDg')}
                    variant="outlined"
                    fullWidth
                    required
                    disabled={destDgDisabled || isTracing}
                    margin="dense"
                    InputProps={{
                         endAdornment: renderDgStatusIcon(destinationDgStatus, 'destination'),
                    }}
                    error={!!(dgFetchError && destinationDgStatus === 'failed')}
                    helperText={destinationDgStatus === 'failed' ? "Check IP and network connectivity" : "Enter DG or fetch automatically"}
                />
            </Grid>
        </Grid>

        {/* Trace Button */}
        <Box sx={{ display: 'flex', justifyContent: 'center', mt: 3, mb: 1 }}>
            <Button
                variant="contained"
                color="primary"
                size="large"
                startIcon={isTracing ? <CircularProgress size={20} color="inherit" /> : <TravelExploreIcon />}
                onClick={handleTrace}
                disabled={!canTrace}
                type="submit" // Allow form submission via Enter key
            >
                {isTracing ? 'Tracing...' : 'Trace Full Route'}
            </Button>
        </Box>
    </Box>
  );
};

export default RouteInputForm;
// ----- End File: src\components\RouteTrace\RouteInputForm.jsx -----

// ----- End File: src\components\RouteTrace\RouteInputForm.jsx -----

// ----- File: src\components\RouteTrace\RouteTraceSection.jsx -----

// ----- File: src\components\RouteTrace\RouteTraceSection.jsx -----
import React from 'react';
import { Paper, Box, IconButton, Tooltip, Divider } from '@mui/material';
import CloseIcon from '@mui/icons-material/Close';
import RouteInputForm from './RouteInputForm';
import RouteVisualizer from './RouteVisualizer';
import { useDispatch } from 'react-redux';
import { removeTraceSection } from '../../store/slices/routeTraceSlice'; // Assuming this exists if comparison is needed

// NOTE: This component seems designed for comparison, but the associated
// RouteTracePage and routeTraceSlice were simplified to handle only *one* trace.
// If comparison is needed for the *Combined Trace*, the slice and page need refactoring.
// For now, this component assumes it *might* be used in a comparison context,
// but the remove functionality won't work with the current single-trace slice.

const RouteTraceSection = ({ trace, canRemove }) => {
  const dispatch = useDispatch();

  const handleRemove = () => {
      // This dispatch will likely cause an error or do nothing with the current
      // single-trace routeTraceSlice. Refactor slice if removal is needed.
      if (canRemove) {
        //   dispatch(removeTraceSection(trace.id)); // Requires slice modification
          console.warn("RemoveTraceSection action requires routeTraceSlice to handle multiple traces.");
      }
  }

  return (
     <Paper
        elevation={3}
        sx={{
            p: { xs: 2, sm: 3 },
            mb: 3,
            position: 'relative',
            borderRadius: 2,
        }}
    >
        {/* Conditionally render remove button - requires slice changes to work */}
        {canRemove && (
            <Tooltip title="Remove this trace section (Requires Slice Update)">
                <IconButton
                    onClick={handleRemove}
                    size="small"
                    aria-label="Remove combined trace section"
                     sx={{
                        position: 'absolute',
                        top: 8,
                        right: 8,
                        color: 'action.active',
                        '&:hover': { color: 'error.main' }
                    }}
                    // disabled // Disable until slice supports removal
                >
                    <CloseIcon fontSize="small" />
                </IconButton>
            </Tooltip>
        )}

        {/* Input Form */}
        <RouteInputForm trace={trace} />

         {/* Divider before results (only if trace has started or finished) */}
         {(trace.traceStatus !== 'idle' || trace.error) && (
             <Divider sx={{ my: 3 }} />
         )}

        {/* Visualizer */}
        <RouteVisualizer trace={trace} />
    </Paper>
  );
};

export default RouteTraceSection;

// ----- End File: src\components\RouteTrace\RouteTraceSection.jsx -----

// ----- File: src\components\RouteTrace\RouteVisualizer.jsx -----

// ----- File: src\components\RouteTrace\RouteVisualizer.jsx -----
import React from 'react';
import { Box, Typography, Stack, Paper, Divider, Chip } from '@mui/material';
import ArrowDownwardIcon from '@mui/icons-material/ArrowDownward';
import LoadingSpinner from '../Common/LoadingSpinner';
import ErrorMessage from '../Common/ErrorMessage';
import HopDisplay from './HopDisplay';
import MacTraceDisplay from './MacTraceDisplay';

const RouteVisualizer = ({ trace }) => {
  const {
    sourceIp, destinationIp, sourceDg, destinationDg,
    mainRouteTrace,
    sourceMacTrace,
    destinationMacTrace,
    traceStatus,
    error
  } = trace;

  const isLoading = traceStatus === 'loading';
  // Separate DG fetch errors from trace/partial errors
  const isDgError = error && (trace.sourceDgStatus === 'failed' || trace.destinationDgStatus === 'failed');
  const isTraceError = error && (traceStatus === 'failed' || traceStatus === 'partial_success') && !isDgError;
  const displayError = isTraceError; // Only display trace/partial error here

  const hasMainHops = mainRouteTrace && mainRouteTrace.length > 0;

  // Don't render anything in idle state unless there's an error already
  if (traceStatus === 'idle' && !error) {
    return null; // Input form shows initial state message
  }

  return (
    <Box sx={{ mt: traceStatus !== 'idle' ? 2 : 0 }}>
      <Typography variant="h6" gutterBottom align="center" sx={{ mb: 2 }}>
          Combined Trace Results
      </Typography>

      {isLoading && <LoadingSpinner message="Performing full trace..." />}

      {/* Display specific trace error or partial success message */}
      {displayError && <ErrorMessage error={error} title={traceStatus === 'partial_success' ? "Partial Trace Success" : "Trace Error"} />}

      {/* Display results container only if not loading and no critical DG error prevented trace */}
      {!isLoading && !isDgError && (
        <Box>
          {/* 1. Source IP Box */}
           <Paper elevation={1} variant='outlined' sx={{ p: 1.5, mb: 1, textAlign: 'center', borderColor: 'primary.light' }}>
              <Typography variant="overline" display="block" sx={{ lineHeight: 1.2, color: 'primary.main' }}>Source</Typography>
              <Typography variant="body1" sx={{ wordBreak: 'break-all', fontWeight: 500 }}>{sourceIp || 'N/A'}</Typography>
           </Paper>
           <Box textAlign="center"><ArrowDownwardIcon fontSize="small" color="action" /></Box>

          {/* 2. Source MAC Trace */}
          <MacTraceDisplay
            label={`${sourceIp || 'Src'} ↔ ${sourceDg || 'DG'}`}
            hops={sourceMacTrace}
            isLoading={false} // Loading handled globally
            // Pass specific error message if only this part failed in partial success
            error={traceStatus === 'partial_success' && !sourceMacTrace ? "Source MAC trace failed or returned no data." : null}
           />
           <Box textAlign="center"><ArrowDownwardIcon fontSize="small" color="action" /></Box>

           {/* 3. Source DG Box */}
           <Paper elevation={1} variant='outlined' sx={{ p: 1.5, my: 1, textAlign: 'center' }}>
              <Typography variant="overline" display="block" sx={{ lineHeight: 1.2 }}>Source DG</Typography>
              <Typography variant="body1" sx={{ wordBreak: 'break-all', fontWeight: 500 }}>{sourceDg || 'N/A'}</Typography>
           </Paper>
           <Box textAlign="center"><ArrowDownwardIcon fontSize="small" color="action" /></Box>


          {/* 4. Main Route Hops */}
          <Paper elevation={0} variant="outlined" sx={{ p: { xs: 1, sm: 1.5 }, my: 1.5 }}>
              <Typography variant="caption" fontWeight="medium" display="block" align="center" sx={{ color: 'text.secondary', mb: 1 }}>
                  Main Route Path (IP Hops)
              </Typography>
              <Divider sx={{ mb: 1 }}/>
              {hasMainHops ? (
                <Box sx={{ overflowX: 'auto', width: '100%', py: 1, px: 0.5 }}>
                    <Stack
                      direction="row"
                      spacing={0} // Handled by HopDisplay
                      alignItems="center"
                      sx={{
                        minWidth: 'max-content',
                        minHeight: 100,
                        pb: 1,
                      }}
                    >
                      {mainRouteTrace.map((hop, index) => (
                        <HopDisplay
                           key={`${hop.device_id || hop.ip || hop.mac || `hop-${hop.hop}`}-${index}`}
                           hopData={hop}
                          isFirst={index === 0}
                          isLast={index === mainRouteTrace.length - 1}
                        />
                      ))}
                    </Stack>
                </Box>
              ) : (
                 // Show message only if trace finished (success/partial) but no hops
                 (traceStatus === 'succeeded' || traceStatus === 'partial_success') && (
                    <Typography align="center" color="text.secondary" sx={{ my: 3, fontStyle: 'italic' }}>
                        {mainRouteTrace === null ? 'Main route trace did not run or failed.' : 'No hops returned for the main route path.'}
                    </Typography>
                 )
              )}
          </Paper>
           <Box textAlign="center"><ArrowDownwardIcon fontSize="small" color="action" /></Box>

           {/* 5. Destination DG Box */}
           <Paper elevation={1} variant='outlined' sx={{ p: 1.5, my: 1, textAlign: 'center' }}>
              <Typography variant="overline" display="block" sx={{ lineHeight: 1.2 }}>Destination DG</Typography>
              <Typography variant="body1" sx={{ wordBreak: 'break-all', fontWeight: 500 }}>{destinationDg || 'N/A'}</Typography>
           </Paper>
           <Box textAlign="center"><ArrowDownwardIcon fontSize="small" color="action" /></Box>

          {/* 6. Destination MAC Trace */}
          <MacTraceDisplay
            label={`${destinationDg || 'DG'} ↔ ${destinationIp || 'Dst'}`}
            hops={destinationMacTrace}
            isLoading={false} // Loading handled globally
            error={traceStatus === 'partial_success' && !destinationMacTrace ? "Destination MAC trace failed or returned no data." : null}
           />
           <Box textAlign="center"><ArrowDownwardIcon fontSize="small" color="action" /></Box>

            {/* 7. Destination IP Box */}
           <Paper elevation={1} variant='outlined' sx={{ p: 1.5, mt: 1, textAlign: 'center', borderColor: 'secondary.light' }}>
              <Typography variant="overline" display="block" sx={{ lineHeight: 1.2, color: 'secondary.main' }}>Destination</Typography>
              <Typography variant="body1" sx={{ wordBreak: 'break-all', fontWeight: 500 }}>{destinationIp || 'N/A'}</Typography>
           </Paper>

        </Box>
      )}

    </Box>
  );
};

export default RouteVisualizer;

// ----- End File: src\components\RouteTrace\RouteVisualizer.jsx -----

// ----- File: src\hooks\useAuth.js -----

import { useSelector } from 'react-redux';

export const useAuth = () => {
  const { user, isAuthenticated, loading, error } = useSelector((state) => state.auth);
  return { user, isAuthenticated, loading, error };
};

// ----- End File: src\hooks\useAuth.js -----

// ----- File: src\index.css -----

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}


// ----- End File: src\index.css -----

// ----- File: src\index.js -----

// ----- File: src\index.js -----
import React from 'react';
import ReactDOM from 'react-dom/client';
import { Provider } from 'react-redux';
import { BrowserRouter } from 'react-router-dom';
// ThemeProvider and CssBaseline are now applied within App.js
import App from './App';
import store from './store/store';
// Import global CSS AFTER MUI baseline if needed for overrides,
// but prefer MUI styling methods (sx prop, styled-components).
import './index.css';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <Provider store={store}>
      <BrowserRouter>
          {/* App now contains ThemeProvider and CssBaseline */}
          <App />
      </BrowserRouter>
    </Provider>
  </React.StrictMode>
);

// ----- End File: src\index.js -----

// ----- File: src\pages\AllRoutesPage.jsx -----

// ----- File: src\pages\AllRoutesPage.jsx -----
import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { Typography, Box } from '@mui/material';
import HistoryList from '../components/History/HistoryList';
import LoadingSpinner from '../components/Common/LoadingSpinner';
import ErrorMessage from '../components/Common/ErrorMessage';
import { fetchAllHistory, resetHistoryError } from '../store/slices/historySlice';

const AllRoutesPage = () => {
  const dispatch = useDispatch();
  // Select relevant state from history slice
  const { allHistory, allHistoryStatus, error } = useSelector((state) => state.history);

  // Fetch data when component mounts if status is idle
  useEffect(() => {
    if (allHistoryStatus === 'idle') {
      dispatch(fetchAllHistory());
    }
     // Clear errors when component unmounts or dependencies change
     return () => {
        // Only reset if the status indicates a completed fetch (or error)
        // to avoid resetting during loading or initial idle state.
        // if (allHistoryStatus === 'succeeded' || allHistoryStatus === 'failed') {
        //     dispatch(resetHistoryError()); // Consider if resetting error on unmount is desired UX
        // }
    }
  }, [allHistoryStatus, dispatch]);

  // Handle loading state
  if (allHistoryStatus === 'loading') {
      return <LoadingSpinner message="Loading all routes history..." />;
  }

  return (
    <Box>
        <Typography variant="h4" component="h1" gutterBottom sx={{ mb: 3 }}>
            All User Routes History
        </Typography>

        {/* Display error if fetching failed */}
        {allHistoryStatus === 'failed' && (
            <ErrorMessage
                error={error}
                title="Could Not Load History"
             />
        )}

        {/* Display the history list if loading succeeded */}
        {/* HistoryList component handles the case of empty routes internally */}
        {allHistoryStatus === 'succeeded' && (
            <HistoryList
                routes={allHistory}
                title="All Recorded Traces" // More specific title
            />
        )}
    </Box>
  );
};

export default AllRoutesPage;

// ----- End File: src\pages\AllRoutesPage.jsx -----

// ----- File: src\pages\ComparisonPage.jsx -----

// ----- File: src\pages\ComparisonPage.jsx -----
import React, { useState, useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { Box, Typography, Alert, Paper } from '@mui/material';
import CompareArrowsIcon from '@mui/icons-material/CompareArrows';
import ComparisonSelector from '../components/Comparison/ComparisonSelector';
import RouteComparisonContainer from '../components/RouteTrace/RouteComparisonContainer';
import ComparisonItem from '../components/Comparison/ComparisonItem';
import LoadingSpinner from '../components/Common/LoadingSpinner';
import ErrorMessage from '../components/Common/ErrorMessage';
import { fetchAllHistory, resetHistoryError } from '../store/slices/historySlice';

const ComparisonPage = () => {
    const dispatch = useDispatch();
    const { allHistory, allHistoryStatus, error: historyError } = useSelector((state) => state.history);
    // Store IDs of the routes selected for comparison
    const [selectedRouteIds, setSelectedRouteIds] = useState([]);

    // Fetch all history if it hasn't been fetched yet
    useEffect(() => {
        if (allHistoryStatus === 'idle') {
            dispatch(fetchAllHistory());
        }
        // Optional: Reset error on unmount
        return () => {
            // dispatch(resetHistoryError());
        };
    }, [allHistoryStatus, dispatch]);

    // Handler for when the selection in ComparisonSelector changes
    const handleSelectionChange = (selectedIds) => {
        setSelectedRouteIds(selectedIds);
    };

    // Filter the full history data based on the selected IDs
    // This derived state will be passed to the comparison container
    const selectedRoutesData = allHistory.filter(route => selectedRouteIds.includes(route.id));

    // Show loading spinner while fetching history
    if (allHistoryStatus === 'loading') {
        return <LoadingSpinner message="Loading route history..." />;
    }

    return (
        <Box>
            <Typography variant="h4" component="h1" gutterBottom sx={{ mb: 3 }}>
                Compare Historical Traces
            </Typography>

            {/* Display error if history fetching failed */}
            {allHistoryStatus === 'failed' && (
                <ErrorMessage error={historyError} title="Could not load route history" />
            )}

            {/* Render selector and comparison container only if history loaded successfully */}
            {allHistoryStatus === 'succeeded' && (
                <>
                    {/* Component to select routes from the available history */}
                    <ComparisonSelector
                        availableRoutes={allHistory}
                        selectedIds={selectedRouteIds}
                        onChange={handleSelectionChange}
                    />

                    {/* Display the comparison container if routes are selected */}
                    {selectedRoutesData.length > 0 ? (
                         <Box sx={{ mt: 3 }}>
                             {/* Container responsible for laying out the comparison items */}
                             <RouteComparisonContainer
                                traces={selectedRoutesData} // Pass the filtered historical data
                                SectionComponent={ComparisonItem} // Specify the component to render each trace
                             />
                         </Box>
                    ) : (
                        // Show an informational message if no routes are selected yet
                         <Alert
                            severity="info"
                            icon={<CompareArrowsIcon />}
                            variant="outlined" // Use outlined for less emphasis
                            sx={{ mt: 3 }}
                         >
                            Select two or more routes from the list above to compare them side-by-side.
                         </Alert>
                    )}
                </>
            )}
        </Box>
    );
};

export default ComparisonPage;

// ----- End File: src\pages\ComparisonPage.jsx -----

// ----- File: src\pages\DirectRouteTracePage.jsx -----

// ----- File: src\pages\DirectRouteTracePage.jsx -----
// ----- File: src\pages\DirectRouteTracePage.jsx -----
import React from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { Button, Box, Typography, Tooltip } from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import RouteComparisonContainer from '../components/RouteTrace/RouteComparisonContainer';
import DirectRouteTraceSection from '../components/RouteTrace/DirectRouteTraceSection';
import { addDirectTraceSection } from '../store/slices/directRouteSlice';

const MAX_COMPARISON_SECTIONS = 4; // Define a max limit for comparison sections

const DirectRouteTracePage = () => {
    const dispatch = useDispatch();
    // Select the array of trace states from the directRoute slice
    const traces = useSelector((state) => state.directRoute.traces);

    const canAddMore = traces.length < MAX_COMPARISON_SECTIONS;

    const handleAddRoute = () => {
        if (canAddMore) {
            dispatch(addDirectTraceSection());
        }
    }

  return (
    <Box>
      <Typography variant="h4" component="h1" gutterBottom sx={{ mb: 3 }}>
        Trace Direct Network Route
      </Typography>
      <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
        Perform a direct route trace between two specified IP addresses using their respective default gateways. Add multiple sections to compare different traces side-by-side.
      </Typography>

      {/* Container to display one or more trace sections side-by-side */}
      <RouteComparisonContainer
            traces={traces}
            SectionComponent={DirectRouteTraceSection} // Pass the specific section component
        />

       {/* Button to add another trace section for comparison */}
       <Box sx={{ mt: 4, display: 'flex', justifyContent: 'center' }}>
            <Tooltip title={!canAddMore ? `Maximum ${MAX_COMPARISON_SECTIONS} comparison sections reached` : "Add another trace input section"}>
                {/* Span needed for tooltip when button is disabled */}
                <span>
                    <Button
                        variant="outlined"
                        startIcon={<AddIcon />}
                        onClick={handleAddRoute}
                        disabled={!canAddMore}
                        aria-label="Add trace section for comparison"
                    >
                        Add Trace for Comparison
                    </Button>
                </span>
            </Tooltip>
       </Box>
    </Box>
  );
};

export default DirectRouteTracePage;

// ----- End File: src\pages\DirectRouteTracePage.jsx -----

// ----- End File: src\pages\DirectRouteTracePage.jsx -----

// ----- File: src\pages\HistoryPage.jsx -----

// ----- File: src\pages\HistoryPage.jsx -----
import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { Typography, Box } from '@mui/material';
import HistoryList from '../components/History/HistoryList';
import LoadingSpinner from '../components/Common/LoadingSpinner';
import ErrorMessage from '../components/Common/ErrorMessage';
import { fetchUserHistory, resetHistoryError } from '../store/slices/historySlice';
import { useAuth } from '../hooks/useAuth'; // Import useAuth to get username

const HistoryPage = () => {
  const dispatch = useDispatch();
  const { user } = useAuth(); // Get current user info
  // Select relevant state from history slice
  const { userHistory, userHistoryStatus, error } = useSelector((state) => state.history);

  // Fetch data when component mounts if status is idle
  useEffect(() => {
    if (userHistoryStatus === 'idle') {
      dispatch(fetchUserHistory());
    }
    // Optional: Clear errors when component unmounts
    // return () => {
    //     dispatch(resetHistoryError());
    // };
  }, [userHistoryStatus, dispatch]);

  // Handle loading state
  if (userHistoryStatus === 'loading') {
      return <LoadingSpinner message="Loading your trace history..." />;
  }

  return (
    <Box>
      <Typography variant="h4" component="h1" gutterBottom sx={{ mb: 3 }}>
         My Trace History
      </Typography>

      {/* Display error if fetching failed */}
      {userHistoryStatus === 'failed' && (
            <ErrorMessage
                error={error}
                title="Could Not Load Your History"
            />
       )}

      {/* Display the history list if loading succeeded */}
      {userHistoryStatus === 'succeeded' && (
        <HistoryList
            routes={userHistory}
            title={user ? `${user.username}'s Traces` : "My Recorded Traces"} // Personalized title
        />
      )}
    </Box>
  );
};

export default HistoryPage;

// ----- End File: src\pages\HistoryPage.jsx -----

// ----- File: src\pages\LoginPage.jsx -----

import React from 'react';
import LoginForm from '../components/Auth/LoginForm';

const LoginPage = () => {
  // Optional: Add any surrounding layout or elements specific to the login page
  return <LoginForm />;
};

export default LoginPage;

// ----- End File: src\pages\LoginPage.jsx -----

// ----- File: src\pages\MacTracePage.jsx -----

// ----- File: src\pages\MacTracePage.jsx -----
import React from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { Button, Box, Typography, Tooltip } from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import RouteComparisonContainer from '../components/RouteTrace/RouteComparisonContainer';
import MacTraceSection from '../components/RouteTrace/MacTraceSection';
import { addMacTraceSection } from '../store/slices/macTraceSlice';

const MAX_COMPARISON_SECTIONS = 4; // Define a max limit

const MacTracePage = () => {
    const dispatch = useDispatch();
    // Select the array of trace states from the macTrace slice
    const traces = useSelector((state) => state.macTrace.traces);

    const canAddMore = traces.length < MAX_COMPARISON_SECTIONS;

    const handleAddRoute = () => {
       if (canAddMore) {
           dispatch(addMacTraceSection());
       }
    }

  return (
    <Box>
      <Typography variant="h4" component="h1" gutterBottom sx={{ mb: 3 }}>
        Trace MAC Path (Endpoint ↔ Gateway)
      </Typography>
       <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
        Perform a Layer 2 MAC address trace between an endpoint IP and its default gateway. Add multiple sections to compare different MAC traces.
      </Typography>

      {/* Container to display one or more trace sections side-by-side */}
      <RouteComparisonContainer
            traces={traces}
            SectionComponent={MacTraceSection} // Pass the specific section component
      />

       {/* Button to add another trace section for comparison */}
       <Box sx={{ mt: 4, display: 'flex', justifyContent: 'center' }}>
           <Tooltip title={!canAddMore ? `Maximum ${MAX_COMPARISON_SECTIONS} comparison sections reached` : "Add another MAC trace input section"}>
                <span> {/* Span for tooltip on disabled button */}
                    <Button
                        variant="outlined"
                        startIcon={<AddIcon />}
                        onClick={handleAddRoute}
                        disabled={!canAddMore}
                        aria-label="Add MAC trace section for comparison"
                    >
                        Add Trace for Comparison
                    </Button>
                </span>
            </Tooltip>
       </Box>
    </Box>
  );
};

export default MacTracePage;

// ----- End File: src\pages\MacTracePage.jsx -----

// ----- File: src\pages\NotFoundPage.jsx -----

// ----- File: src\pages\NotFoundPage.jsx -----
import React from 'react';
import { Typography, Box, Button, Paper } from '@mui/material';
import { Link as RouterLink } from 'react-router-dom';
import ErrorOutlineIcon from '@mui/icons-material/ErrorOutline'; // Icon for visual cue

const NotFoundPage = () => (
  <Box
    sx={{
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        minHeight: 'calc(100vh - 120px)', // Adjust height calculation based on AppBar/Toolbar
        textAlign: 'center',
        px: 2,
    }}
   >
    <Paper elevation={3} sx={{ p: { xs: 3, sm: 5 }, borderRadius: 2 }}>
        <ErrorOutlineIcon sx={{ fontSize: 60, color: 'warning.main', mb: 2 }} />
        <Typography variant="h4" component="h1" fontWeight="bold" gutterBottom>
            404 - Page Not Found
        </Typography>
        <Typography variant="body1" color="text.secondary" sx={{ mb: 4 }}>
            Oops! The page you are looking for doesn't exist or may have been moved.
        </Typography>
        <Button
            variant="contained"
            component={RouterLink}
            to="/" // Link to the main dashboard or relevant starting page
            size="large"
        >
            Go to Homepage
        </Button>
    </Paper>
  </Box>
);

export default NotFoundPage;

// ----- End File: src\pages\NotFoundPage.jsx -----

// ----- File: src\pages\RouteTracePage.jsx -----

// ----- File: src\pages\RouteTracePage.jsx -----
// No changes needed here based on the new warnings, re-providing corrected version from previous step.
import React from 'react';
import { useSelector } from 'react-redux';
import { Box, Typography, Paper, Divider } from '@mui/material';
import RouteInputForm from '../components/RouteTrace/RouteInputForm';
import RouteVisualizer from '../components/RouteTrace/RouteVisualizer';
import LoadingSpinner from '../components/Common/LoadingSpinner'; // LoadingSpinner import confirmed

// This page handles the *single* combined trace scenario.
// It uses the `routeTrace` slice which manages only one trace state object.
const RouteTracePage = () => {
    // Select the single trace state object directly from the slice
    const trace = useSelector((state) => state.routeTrace.trace);

    // Basic check if trace state exists (it should based on slice initial state)
    if (!trace) {
        // This state should ideally not be reachable if the slice initializes correctly
        return <LoadingSpinner message="Initializing trace state..." />;
    }

    return (
        <Box>
            <Typography variant="h4" component="h1" gutterBottom sx={{ mb: 3 }}>
                Trace Network Route (Combined)
            </Typography>
             <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
                Perform a comprehensive trace including Layer 2 (MAC) paths at source/destination and Layer 3 (IP) hops in between.
            </Typography>

            {/* Use a single Paper container for the form and results */}
            <Paper
                elevation={3}
                sx={{
                    p: { xs: 2, sm: 3 },
                    mb: 3,
                    borderRadius: 2,
                }}
            >
                {/* Input Form for the single trace */}
                <RouteInputForm trace={trace} />

                {/* Divider between form and results, shown only when results are pending/present */}
                {(trace.traceStatus !== 'idle' || trace.error) && (
                     <Divider sx={{ my: 3 }} />
                )}

                {/* Visualizer for the single trace results */}
                <RouteVisualizer trace={trace} />
            </Paper>

            {/* Comparison controls (Add/Remove buttons) are removed as this page handles a single trace */}

        </Box>
    );
};

export default RouteTracePage;
// ----- End File: src\pages\RouteTracePage.jsx -----

// ----- End File: src\pages\RouteTracePage.jsx -----

// ----- File: src\reportWebVitals.js -----

const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;


// ----- End File: src\reportWebVitals.js -----

// ----- File: src\services\api.js -----

import axios from 'axios';
import Cookies from 'js-cookie';

const API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:8000'; // Fallback

const apiClient = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Interceptor to add the auth token to requests
apiClient.interceptors.request.use(
  (config) => {
    const token = Cookies.get('authToken'); // Read token from cookie
    if (token) {
      // Assuming the backend expects the token in an 'Authorization: Bearer <token>' header
      // Adjust 'token' header name if backend expects something different (e.g., 'x-token')
      config.headers['token'] = token; // Use 'Authorization': `Bearer ${token}` if that's the standard used
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Optional: Interceptor to handle 401 Unauthorized errors globally
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response && error.response.status === 401) {
      // Token is invalid or expired
      Cookies.remove('authToken');
      // Optionally redirect to login or dispatch a logout action
      // window.location.href = '/login'; // Hard redirect
      // store.dispatch(logout()); // If you have a logout action
      console.error("Authentication Error: Token invalid or expired.");
    }
    return Promise.reject(error);
  }
);


export default apiClient;

// ----- End File: src\services\api.js -----

// ----- File: src\services\authService.js -----

import apiClient from './api';
import Cookies from 'js-cookie';

// Matches the Python UserG model
const login = async (username, password) => {
  try {
    // Backend endpoint: /verify-device-auth
    // Backend expects: { username: "user", password: "pw" } in the body
    const response = await apiClient.post('/verify-device-auth', { username, password });
    const token = response.data; // Assuming the backend returns the token directly in the data

    if (token) {
      // Store token in cookie - Secure flag should be true in production (HTTPS)
      Cookies.set('authToken', token, { expires: 1, path: '/' /*, secure: true, sameSite: 'strict' */ });
      // You might want to fetch user details here if needed, or decode the token if it's a JWT
      // For now, we just store the token. The presence of the token implies logged in status.
      return { success: true, user: { username } }; // Return basic user info
    } else {
      throw new Error('No token received from server');
    }
  } catch (error) {
    console.error('Login failed:', error.response?.data || error.message);
    throw new Error(error.response?.data?.detail || 'Login failed');
  }
};

const logout = () => {
    Cookies.remove('authToken', { path: '/' });
    // No API call needed unless backend has session invalidation
};

const authService = {
  login,
  logout,
};

export default authService;

// ----- End File: src\services\authService.js -----

// ----- File: src\services\routeService.js -----

// ----- File: src\services\routeService.js -----
import apiClient from './api';

// Corresponds to get_default_gateway(ip: str)
const getDefaultGateway = async (ip) => {
    try {
        // Adjust endpoint if needed, e.g. '/network/default-gateway'
        // Pass IP as a query parameter named 'ip'
        const response = await apiClient.get('/get-default-gateway', { params: { ip } });
        // Assuming the backend returns the gateway IP directly or in a specific field
        // Example: return response.data.gateway;
        return response.data; // Modify based on actual backend response structure
    } catch (error) {
        console.error(`Failed to get default gateway for ${ip}:`, error.response?.data || error.message);
        throw new Error(error.response?.data?.detail || `Failed to get DG for ${ip}`);
    }
};

// Corresponds to get_mac_trace(ip: str, dg: str)
const getMacTrace = async (ip, dg) => {
     try {
        // Adjust endpoint if needed
        // Pass ip and dg as query parameters
        const response = await apiClient.get('/get-mac-trace', { params: { ip, dg } });
        // Assuming backend returns the MAC trace data (e.g., list of hops)
        return response.data; // Modify based on actual backend response structure
    } catch (error) {
        console.error(`Failed to get MAC trace for ${ip} -> ${dg}:`, error.response?.data || error.message);
        throw new Error(error.response?.data?.detail || `Failed to get MAC trace`);
    }
};

// Corresponds to get_route_trace (or potentially get_tufin_route - clarify which one to use)
// Using get_route_trace based on code snippets provided
// This function now handles both the combined trace (DGs provided for MAC tracing)
// and the direct trace (DGs provided as start/end points, VRF optional)
const getRouteTrace = async (source_ip, destination_ip, source_dg = null, destination_dg = null, vrf = null) => {
    try {
        const params = {
            source_ip,
            destination_ip,
            // Add other params only if they have values (not null/undefined)
            ...(source_dg && { source_dg }),
            ...(destination_dg && { destination_dg }),
            ...(vrf && { vrf }),
        };
        // Endpoint should match the modified dummy backend or real backend
        const response = await apiClient.get('/get-route-trace', { params });
         // Backend saves automatically (in dummy/real logic), frontend just gets the result.
         // Assuming backend returns the full route trace data (e.g., list of hops)
        return response.data; // Modify based on actual backend response structure
    } catch (error) {
        console.error(`Failed to get route trace:`, error.response?.data || error.message);
        throw new Error(error.response?.data?.detail || `Failed to get route trace`);
    }
};


// Corresponds to get_user_routes() - uses POST in backend? Check method. Assuming POST for now.
const getUserRoutes = async () => {
    try {
        // Backend uses POST for get-user-routes, ensure token is sent via interceptor
        const response = await apiClient.post('/get-user-routes');
        // Assuming backend returns a list of routes
        // Response format likely: [{id, source, destination, route, timestamp, ...}, ...]
        return response.data; // Modify based on actual backend response structure
    } catch (error) {
        console.error(`Failed to get user routes:`, error.response?.data || error.message);
        throw new Error(error.response?.data?.detail || `Failed to get user routes`);
    }
};

// Corresponds to get_all_routes() - uses POST in backend? Check method. Assuming POST.
const getAllRoutes = async () => {
    try {
        // Backend uses POST for get-all-routes
        const response = await apiClient.post('/get-all-routes');
        // Assuming backend returns a list of all routes
        return response.data; // Modify based on actual backend response structure
    } catch (error) {
        console.error(`Failed to get all routes:`, error.response?.data || error.message);
        throw new Error(error.response?.data?.detail || `Failed to get all routes`);
    }
};


const routeService = {
    getDefaultGateway,
    getMacTrace,
    getRouteTrace,
    getUserRoutes,
    getAllRoutes,
};

export default routeService;

// ----- End File: src\services\routeService.js -----

// ----- End File: src\services\routeService.js -----

// ----- File: src\setupTests.js -----

// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';


// ----- End File: src\setupTests.js -----

// ----- File: src\store\slices\authSlice.js -----

import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import authService from '../../services/authService';
import Cookies from 'js-cookie';

// Async thunk for login
export const loginUser = createAsyncThunk(
  'auth/loginUser',
  async ({ username, password }, { rejectWithValue }) => {
    try {
      const data = await authService.login(username, password);
      return data; // Should return { success: true, user: { username } }
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// Initial state checks if a token exists in cookies
const initialState = {
  user: null,
  isAuthenticated: !!Cookies.get('authToken'), // Check cookie on initial load
  loading: false,
  error: null,
};

const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    logoutUser: (state) => {
      authService.logout(); // Clear cookie
      state.user = null;
      state.isAuthenticated = false;
      state.loading = false;
      state.error = null;
    },
    resetAuthError: (state) => {
        state.error = null;
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(loginUser.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(loginUser.fulfilled, (state, action) => {
        state.loading = false;
        state.isAuthenticated = true;
        state.user = action.payload.user; // Store user info from payload
        state.error = null;
      })
      .addCase(loginUser.rejected, (state, action) => {
        state.loading = false;
        state.isAuthenticated = false;
        state.user = null;
        state.error = action.payload; // Error message from rejectWithValue
      });
  },
});

export const { logoutUser, resetAuthError } = authSlice.actions;
export default authSlice.reducer;

// ----- End File: src\store\slices\authSlice.js -----

// ----- File: src\store\slices\directRouteSlice.js -----

// ----- File: src\store\slices\directRouteSlice.js -----
// ----- File: src\store\slices\directRouteSlice.js -----
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import routeService from '../../services/routeService';
import { v4 as uuidv4 } from 'uuid';

// Helper to create initial trace state for Direct Route trace (Simplified)
const createInitialDirectTraceState = () => ({
  id: uuidv4(),
  // sourceIp: '', // Removed
  // destinationIp: '', // Removed
  sourceDg: '', // Represents Source Gateway IP
  destinationDg: '', // Represents Destination Gateway IP
  vrf: '', // VRF is required
  // DgStatus fields removed as auto-fetch is removed
  traceStatus: 'idle', // 'idle', 'loading', 'succeeded', 'failed'
  traceResult: null, // Holds List[DetailedHop] for the direct route trace
  error: null, // Holds error message string or object
});

// --- Async Thunks ---

// Removed fetchDirectDefaultGateway thunk as it's no longer needed

export const performDirectRouteTrace = createAsyncThunk(
  'directRoute/performDirectRouteTrace',
  async ({ traceId, sourceDg, destinationDg, vrf }, { rejectWithValue }) => {
    // Input validation - VRF is now considered mandatory here
    // sourceDg and destinationDg are the primary inputs now
    if (!sourceDg || !destinationDg || !vrf || vrf.trim() === '') {
        return rejectWithValue({ message: "Source Gateway IP, Destination Gateway IP, and VRF Name are required.", traceId });
    }
    try {
      // Trim VRF just in case
      const traceVrf = vrf.trim();
      // Call the main routeService.getRouteTrace function.
      // Pass Gateway IPs as both endpoint IPs and gateway IPs for this trace type.
      const result = await routeService.getRouteTrace(
          sourceDg,       // Pass Source Gateway as source_ip
          destinationDg,  // Pass Dest Gateway as destination_ip
          sourceDg,       // Pass Source Gateway as source_dg
          destinationDg,  // Pass Dest Gateway as destination_dg
          traceVrf        // Pass VRF
      );
      // Assuming result is List[DetailedHop] or could be empty list
      return { traceId, result: result || [] }; // Ensure result is always an array
    } catch (error) {
      const errorMessage = error?.response?.data?.detail || error?.message || 'Direct route trace failed';
      return rejectWithValue({ message: errorMessage, traceId });
    }
  }
);

// --- Slice Definition ---

const initialState = {
  traces: [createInitialDirectTraceState()], // Start with one direct trace section
};

const directRouteSlice = createSlice({
  name: 'directRoute',
  initialState,
  reducers: {
    addDirectTraceSection: (state) => {
       const MAX_SECTIONS = 4; // Example limit
       if (state.traces.length < MAX_SECTIONS) {
         state.traces.push(createInitialDirectTraceState());
       }
    },
    removeDirectTraceSection: (state, action) => {
        const traceIdToRemove = action.payload;
        if (state.traces.length > 1) {
            state.traces = state.traces.filter(trace => trace.id !== traceIdToRemove);
        }
    },
    updateDirectTraceInput: (state, action) => {
      const { traceId, field, value } = action.payload;
      const traceIndex = state.traces.findIndex(t => t.id === traceId);
      if (traceIndex !== -1) {
        // Only update allowed fields: sourceDg, destinationDg, vrf
        if (['sourceDg', 'destinationDg', 'vrf'].includes(field)) {
            const trace = state.traces[traceIndex];
            trace[field] = value;

            // Reset status and results if relevant inputs change
            trace.traceStatus = 'idle';
            trace.traceResult = null;
            trace.error = null; // Clear general error on input change
        }
      }
    },
    resetDirectTraceState: (state) => {
        // Reset to the initial state with one empty trace section
        state.traces = [createInitialDirectTraceState()];
    }
  },
  extraReducers: (builder) => {
    builder
      // Removed fetchDirectDefaultGateway reducers

      // --- Direct Route Trace Execution Reducers ---
      .addCase(performDirectRouteTrace.pending, (state, action) => {
        const { traceId } = action.meta.arg;
        const trace = state.traces.find(t => t.id === traceId);
        if (trace) {
          trace.traceStatus = 'loading';
          trace.error = null; // Clear previous errors
          trace.traceResult = null; // Clear previous results
        }
      })
      .addCase(performDirectRouteTrace.fulfilled, (state, action) => {
        const { traceId, result } = action.payload;
        const trace = state.traces.find(t => t.id === traceId);
        if (trace) {
          trace.traceStatus = 'succeeded';
          trace.traceResult = result; // Store the List[DetailedHop]
          trace.error = null;
        }
      })
      .addCase(performDirectRouteTrace.rejected, (state, action) => {
        const { message, traceId } = action.payload;
        const trace = state.traces.find(t => t.id === traceId);
        if (trace) {
          trace.traceStatus = 'failed';
          trace.error = message; // Store the specific trace error
          trace.traceResult = null; // Ensure result is cleared on failure
        }
      });
  },
});

export const { addDirectTraceSection, removeDirectTraceSection, updateDirectTraceInput, resetDirectTraceState } = directRouteSlice.actions;
export default directRouteSlice.reducer;

// ----- End File: src\store\slices\directRouteSlice.js -----

// ----- End File: src\store\slices\directRouteSlice.js -----

// ----- File: src\store\slices\historySlice.js -----

// ----- File: src\store\slices\historySlice.js -----
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import routeService from '../../services/routeService';

// Enhanced JSON parsing to handle potential non-JSON strings gracefully
const safeParseJson = (jsonString, defaultValue = null) => {
  // If it's already an object (e.g., already parsed), return it directly
  if (typeof jsonString === 'object' && jsonString !== null) return jsonString;
  // If it's not a string, return the default value
  if (typeof jsonString !== 'string' || jsonString.trim() === '') return defaultValue;

  try {
    const parsed = JSON.parse(jsonString);
    // Basic check if parsed result is an array (for routeData)
    // Adjust check if other structures are expected
    if (Array.isArray(parsed)) {
        return parsed;
    } else if (typeof parsed === 'object' && parsed !== null) { // For deviceInfo
         return parsed;
    }
    // If parsed into something unexpected (e.g., a primitive), return default
    return defaultValue;
  } catch (e) {
    // Log parsing errors for debugging, but don't crash the app
    console.warn("Failed to parse JSON string:", jsonString, "Error:", e);
    return defaultValue; // Return default value on parsing failure
  }
};

// Helper to process raw route entries from the backend
const processRouteEntry = (route) => ({
    ...route,
    // Parse the 'route' field (expected List[DetailedHop] as JSON string)
    routeData: safeParseJson(route.route, []), // Default to empty array if parsing fails or invalid
    // Parse the 'device_additional_info' field (expected JSON object string or null)
    deviceInfo: safeParseJson(route.device_additional_info, null), // Default to null
    // Ensure user is an object or null
    user: (typeof route.user === 'object' && route.user !== null) ? route.user : null
});

// Async thunk for fetching user-specific route history
export const fetchUserHistory = createAsyncThunk(
  'history/fetchUserHistory',
  async (_, { rejectWithValue }) => {
    try {
      const rawRoutes = await routeService.getUserRoutes();
      // Process each route entry safely
      return rawRoutes.map(processRouteEntry);
    } catch (error) {
      const errorMessage = error?.response?.data?.detail || error?.message || 'Failed to fetch user history';
      return rejectWithValue(errorMessage);
    }
  }
);

// Async thunk for fetching all routes (admin perspective)
export const fetchAllHistory = createAsyncThunk(
  'history/fetchAllHistory',
  async (_, { rejectWithValue }) => {
    try {
      const rawRoutes = await routeService.getAllRoutes();
       // Process each route entry safely
       return rawRoutes.map(processRouteEntry);
    } catch (error) {
       const errorMessage = error?.response?.data?.detail || error?.message || 'Failed to fetch all routes history';
      return rejectWithValue(errorMessage);
    }
  }
);

const initialState = {
  userHistory: [],
  allHistory: [],
  userHistoryStatus: 'idle', // 'idle', 'loading', 'succeeded', 'failed'
  allHistoryStatus: 'idle', // 'idle', 'loading', 'succeeded', 'failed'
  error: null, // Holds error message string
};

const historySlice = createSlice({
  name: 'history',
  initialState,
  reducers: {
    // Action to explicitly reset any history-related errors
    resetHistoryError: (state) => {
        state.error = null;
    }
    // Potentially add reducers for clearing history, etc. if needed
  },
  extraReducers: (builder) => {
    builder
      // --- User History Fetching ---
      .addCase(fetchUserHistory.pending, (state) => {
        state.userHistoryStatus = 'loading';
        state.error = null; // Clear previous errors
      })
      .addCase(fetchUserHistory.fulfilled, (state, action) => {
        state.userHistoryStatus = 'succeeded';
        state.userHistory = action.payload; // Store processed routes
      })
      .addCase(fetchUserHistory.rejected, (state, action) => {
        state.userHistoryStatus = 'failed';
        state.error = action.payload; // Store error message
      })
      // --- All History Fetching ---
      .addCase(fetchAllHistory.pending, (state) => {
        state.allHistoryStatus = 'loading';
        state.error = null; // Clear previous errors
      })
      .addCase(fetchAllHistory.fulfilled, (state, action) => {
        state.allHistoryStatus = 'succeeded';
        state.allHistory = action.payload; // Store processed routes
      })
      .addCase(fetchAllHistory.rejected, (state, action) => {
        state.allHistoryStatus = 'failed';
        state.error = action.payload; // Store error message
      });
  },
});

export const { resetHistoryError } = historySlice.actions;
export default historySlice.reducer;

// ----- End File: src\store\slices\historySlice.js -----

// ----- File: src\store\slices\macTraceSlice.js -----

// ----- File: src\store\slices\macTraceSlice.js -----
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import routeService from '../../services/routeService';
import { v4 as uuidv4 } from 'uuid';

// Helper to create initial trace state for MAC trace
const createInitialMacTraceState = () => ({
  id: uuidv4(),
  ip: '', // Endpoint IP
  dg: '', // Default Gateway
  dgStatus: 'idle', // 'idle', 'loading', 'succeeded', 'failed', 'manual'
  traceStatus: 'idle', // 'idle', 'loading', 'succeeded', 'failed'
  traceResult: null, // Holds List[DetailedHop] for the MAC trace
  error: null, // Holds error message string or object
});

// --- Async Thunks ---

export const fetchMacDefaultGateway = createAsyncThunk(
  'macTrace/fetchDefaultGateway',
  async ({ ip, traceId }, { rejectWithValue }) => {
    if (!ip) return rejectWithValue({ message: "IP address is required to fetch gateway.", traceId });
    try {
      const gateway = await routeService.getDefaultGateway(ip);
      if (!gateway) throw new Error("No gateway address returned by the backend.");
      return { gateway, traceId };
    } catch (error) {
      const errorMessage = error?.response?.data?.detail || error?.message || 'Failed to fetch default gateway';
      return rejectWithValue({ message: errorMessage, traceId });
    }
  }
);

export const performMacTrace = createAsyncThunk(
  'macTrace/performMacTrace',
  async ({ traceId, ip, dg }, { rejectWithValue }) => {
    if (!ip || !dg) {
        return rejectWithValue({ message: "Endpoint IP and Default Gateway are required.", traceId });
    }
    try {
      const result = await routeService.getMacTrace(ip, dg);
      // Ensure result is always an array, even if backend returns null/undefined
      return { traceId, result: result || [] };
    } catch (error) {
      const errorMessage = error?.response?.data?.detail || error?.message || 'MAC trace failed';
      return rejectWithValue({ message: errorMessage, traceId });
    }
  }
);

// --- Slice Definition ---

const initialState = {
  traces: [createInitialMacTraceState()], // Start with one MAC trace section
};

const macTraceSlice = createSlice({
  name: 'macTrace',
  initialState,
  reducers: {
    addMacTraceSection: (state) => {
       const MAX_SECTIONS = 4; // Example limit
       if (state.traces.length < MAX_SECTIONS) {
         state.traces.push(createInitialMacTraceState());
       }
    },
    removeMacTraceSection: (state, action) => {
        const traceIdToRemove = action.payload;
        if (state.traces.length > 1) {
            state.traces = state.traces.filter(trace => trace.id !== traceIdToRemove);
        }
    },
    updateMacTraceInput: (state, action) => {
      const { traceId, field, value } = action.payload;
      const traceIndex = state.traces.findIndex(t => t.id === traceId);
      if (traceIndex !== -1) {
        const trace = state.traces[traceIndex];
        trace[field] = value;

        // Reset status and results on input change
        trace.traceStatus = 'idle';
        trace.traceResult = null;
        trace.error = null; // Clear general error

        // Handle DG status updates
        if (field === 'dg' && trace.dgStatus !== 'loading') {
            trace.dgStatus = 'manual'; // Mark as manual if user types DG
        }
        // Reset DG field and status if IP changes
        if (field === 'ip') {
            trace.dg = '';
            trace.dgStatus = 'idle';
        }
      }
    },
    resetMacTraceState: (state) => {
        state.traces = [createInitialMacTraceState()];
    }
  },
  extraReducers: (builder) => {
    builder
      // --- Default Gateway Fetching Reducers ---
      .addCase(fetchMacDefaultGateway.pending, (state, action) => {
        const { traceId } = action.meta.arg;
        const trace = state.traces.find(t => t.id === traceId);
        if (trace) {
          trace.dgStatus = 'loading';
          trace.error = null; // Clear previous errors
        }
      })
      .addCase(fetchMacDefaultGateway.fulfilled, (state, action) => {
        const { gateway, traceId } = action.payload;
        const trace = state.traces.find(t => t.id === traceId);
        if (trace) {
            trace.dg = gateway;
            trace.dgStatus = 'succeeded';
             // Clear error state if DG fetch was the cause
             if (trace.error?.includes('Failed to fetch default gateway')) {
                 trace.error = null;
             }
        }
      })
      .addCase(fetchMacDefaultGateway.rejected, (state, action) => {
        const { message, traceId } = action.payload;
        const trace = state.traces.find(t => t.id === traceId);
         if (trace) {
          trace.dgStatus = 'failed';
          trace.error = `Gateway Fetch Error: ${message}`; // Set specific error
          // trace.traceStatus = 'idle'; // Optional: Reset trace status?
        }
      })

      // --- MAC Trace Execution Reducers ---
      .addCase(performMacTrace.pending, (state, action) => {
        const { traceId } = action.meta.arg;
        const trace = state.traces.find(t => t.id === traceId);
        if (trace) {
          trace.traceStatus = 'loading';
          trace.error = null;
          trace.traceResult = null; // Clear previous result
        }
      })
      .addCase(performMacTrace.fulfilled, (state, action) => {
        const { traceId, result } = action.payload;
        const trace = state.traces.find(t => t.id === traceId);
        if (trace) {
          trace.traceStatus = 'succeeded';
          trace.traceResult = result; // Store the List[DetailedHop]
          trace.error = null;
        }
      })
      .addCase(performMacTrace.rejected, (state, action) => {
        const { message, traceId } = action.payload;
        const trace = state.traces.find(t => t.id === traceId);
        if (trace) {
          trace.traceStatus = 'failed';
          trace.error = message; // Store the specific trace error
          trace.traceResult = null; // Ensure result is cleared on failure
        }
      });
  },
});

export const { addMacTraceSection, removeMacTraceSection, updateMacTraceInput, resetMacTraceState } = macTraceSlice.actions;
export default macTraceSlice.reducer;

// ----- End File: src\store\slices\macTraceSlice.js -----

// ----- File: src\store\slices\routeTraceSlice.js -----

// ----- File: src\store\slices\routeTraceSlice.js -----
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import routeService from '../../services/routeService';
import { v4 as uuidv4 } from 'uuid'; // Ensure uuid is installed

// Helper to create the initial state for the single combined trace
const createInitialTraceState = () => ({
  id: uuidv4(), // Unique ID for this trace instance/session
  sourceIp: '',
  destinationIp: '',
  sourceDg: '',
  destinationDg: '',
  sourceDgStatus: 'idle', // 'idle', 'loading', 'succeeded', 'failed', 'manual'
  destinationDgStatus: 'idle',
  traceStatus: 'idle', // 'idle', 'loading', 'succeeded', 'failed', 'partial_success'
  sourceMacTrace: null, // Holds List[DetailedHop] or null
  destinationMacTrace: null, // Holds List[DetailedHop] or null
  mainRouteTrace: null, // Holds List[DetailedHop] or null
  error: null, // Holds error message string or potentially an object with details
});

// --- Async Thunks ---

// Fetch Default Gateway (Source or Destination)
export const fetchDefaultGateway = createAsyncThunk(
  'routeTrace/fetchDefaultGateway',
  async ({ ip, type, traceId }, { rejectWithValue, getState }) => {
    // Check if the action's traceId matches the current state's traceId
    const currentTraceId = getState().routeTrace.trace.id;
    if (traceId !== currentTraceId) {
         // This prevents updates if the user quickly changes inputs/navigates
         console.warn(`fetchDefaultGateway: Action traceId ${traceId} does not match current state traceId ${currentTraceId}. Ignoring.`);
         return { ignored: true }; // Signal that the action was ignored
    }

    if (!ip) return rejectWithValue({ message: "IP address is required to fetch gateway.", type, traceId });
    try {
      const gateway = await routeService.getDefaultGateway(ip);
      if (!gateway) throw new Error("No gateway address returned by the backend.");
      return { gateway, type, traceId };
    } catch (error) {
      const errorMessage = error?.response?.data?.detail || error?.message || 'Failed to fetch default gateway';
      return rejectWithValue({ message: errorMessage, type, traceId });
    }
  }
);

// Perform the Full Combined Trace (Main Route + Both MAC Traces)
export const performFullTrace = createAsyncThunk(
  'routeTrace/performFullTrace',
  async ({ traceId, sourceIp, destinationIp, sourceDg, destinationDg }, { rejectWithValue, getState }) => {
    // Check if the action's traceId matches the current state's traceId
     const currentTraceId = getState().routeTrace.trace.id;
     if (traceId !== currentTraceId) {
         console.warn(`performFullTrace: Action traceId ${traceId} does not match current state traceId ${currentTraceId}. Ignoring.`);
         return { ignored: true }; // Signal ignored action
     }

    // Input validation
    if (!sourceIp || !destinationIp || !sourceDg || !destinationDg) {
        return rejectWithValue({ message: "Source IP, Destination IP, Source DG, and Destination DG are required.", traceId });
    }
    try {
      // Perform the API calls concurrently for efficiency
      const results = await Promise.allSettled([
        routeService.getRouteTrace(sourceIp, destinationIp, sourceDg, destinationDg), // Main route
        routeService.getMacTrace(sourceIp, sourceDg),                             // Source MAC trace
        routeService.getMacTrace(destinationIp, destinationDg)                       // Destination MAC trace
      ]);

      const [mainRouteResult, sourceMacResult, destMacResult] = results;

      // Helper to extract value or null, ensuring arrays for trace results
      const getResultData = (promiseResult) =>
         promiseResult.status === 'fulfilled' ? (promiseResult.value || []) : null;

      // Extract data or null from settled promises
      const mainRouteTrace = getResultData(mainRouteResult);
      const sourceMacTrace = getResultData(sourceMacResult);
      const destinationMacTrace = getResultData(destMacResult);

      // Collect detailed error messages if any part failed
      const errors = results
        .filter(p => p.status === 'rejected')
        .map((p, index) => {
            const component = ['Main Route', 'Source MAC Trace', 'Destination MAC Trace'][index];
            const reason = p.reason?.response?.data?.detail || p.reason?.message || 'Unknown error';
            return `${component}: ${reason}`;
        });

      // Determine overall status based on results
      let finalStatus;
      if (mainRouteResult.status === 'rejected') {
          finalStatus = 'failed'; // Main route failure is a critical failure
      } else if (errors.length > 0) {
          finalStatus = 'partial_success'; // Main route succeeded, but MAC trace(s) failed
      } else {
          finalStatus = 'succeeded'; // All components succeeded
      }

      // Return combined results and status
      return {
        traceId,
        mainRouteTrace,
        sourceMacTrace,
        destinationMacTrace,
        status: finalStatus,
        // Join multiple errors for display, or return null if no errors
        error: errors.length > 0 ? errors.join('; ') : null
      };

    } catch (error) {
      // This catch block handles errors *before* the Promise.allSettled or if something unexpected happens
      const errorMessage = error?.response?.data?.detail || error?.message || 'Full trace operation failed unexpectedly';
      return rejectWithValue({ message: errorMessage, traceId });
    }
  }
);

// --- Slice Definition (Manages a single trace state) ---

const initialState = {
  // Contains only *one* trace state object
  trace: createInitialTraceState(),
};

const routeTraceSlice = createSlice({
  name: 'routeTrace',
  initialState,
  reducers: {
    // Update input fields for the single trace
    updateTraceInput: (state, action) => {
      const { traceId, field, value } = action.payload;
      // Ensure the update is for the currently active trace ID
      if (state.trace.id === traceId) {
          const trace = state.trace; // Direct reference
          trace[field] = value;

          // Reset status and results whenever an input changes
          trace.traceStatus = 'idle';
          trace.mainRouteTrace = null;
          trace.sourceMacTrace = null;
          trace.destinationMacTrace = null;
          trace.error = null; // Clear general error

          // Handle DG status logic
          if (field === 'sourceDg' && trace.sourceDgStatus !== 'loading') {
              trace.sourceDgStatus = 'manual';
          }
          if (field === 'destinationDg' && trace.destinationDgStatus !== 'loading') {
              trace.destinationDgStatus = 'manual';
          }
          if (field === 'sourceIp') {
              trace.sourceDg = '';
              trace.sourceDgStatus = 'idle';
          }
          if (field === 'destinationIp') {
              trace.destinationDg = '';
              trace.destinationDgStatus = 'idle';
          }
      } else {
           console.warn(`updateTraceInput: Mismatched traceId. State: ${state.trace.id}, Action: ${traceId}. Ignoring update.`);
      }
    },
    // Reset the entire trace state to its initial empty state
    resetTraceState: (state) => {
        state.trace = createInitialTraceState();
    }
    // Removed addTraceSection and removeTraceSection as this slice handles a single trace
  },
  extraReducers: (builder) => {
    builder
      // --- Default Gateway Fetching Reducers ---
      .addCase(fetchDefaultGateway.pending, (state, action) => {
        const { type, traceId } = action.meta.arg;
        if (state.trace.id === traceId) { // Check ID match
          if (type === 'source') state.trace.sourceDgStatus = 'loading';
          if (type === 'destination') state.trace.destinationDgStatus = 'loading';
          state.trace.error = null; // Clear previous errors
        }
      })
      .addCase(fetchDefaultGateway.fulfilled, (state, action) => {
         // Ignore if the action was signaled as ignored
         if (action.payload.ignored) return;
        const { gateway, type, traceId } = action.payload;
        if (state.trace.id === traceId) { // Check ID match
          if (type === 'source') {
            state.trace.sourceDg = gateway;
            state.trace.sourceDgStatus = 'succeeded';
          }
          if (type === 'destination') {
            state.trace.destinationDg = gateway;
            state.trace.destinationDgStatus = 'succeeded';
          }
           // Clear error state if DG fetch was the cause
           if (state.trace.error?.includes('Failed to fetch default gateway')) {
               state.trace.error = null;
           }
        }
      })
      .addCase(fetchDefaultGateway.rejected, (state, action) => {
        if (action.payload.ignored) return; // Ignore if signaled
        const { message, type, traceId } = action.payload;
        if (state.trace.id === traceId) { // Check ID match
          if (type === 'source') state.trace.sourceDgStatus = 'failed';
          if (type === 'destination') state.trace.destinationDgStatus = 'failed';
          state.trace.error = `Gateway Fetch Error (${type}): ${message}`; // Set specific error
          // state.trace.traceStatus = 'idle'; // Optional: Reset trace status on DG fail?
        }
      })

      // --- Full Trace Execution Reducers ---
      .addCase(performFullTrace.pending, (state, action) => {
        const { traceId } = action.meta.arg;
        if (state.trace.id === traceId) { // Check ID match
          state.trace.traceStatus = 'loading';
          state.trace.error = null;
          // Clear previous results
          state.trace.mainRouteTrace = null;
          state.trace.sourceMacTrace = null;
          state.trace.destinationMacTrace = null;
        }
      })
      .addCase(performFullTrace.fulfilled, (state, action) => {
         if (action.payload.ignored) return; // Ignore if signaled
        const { traceId, mainRouteTrace, sourceMacTrace, destinationMacTrace, status, error } = action.payload;
        if (state.trace.id === traceId) { // Check ID match
          state.trace.traceStatus = status; // 'succeeded', 'partial_success', or 'failed'
          state.trace.mainRouteTrace = mainRouteTrace;
          state.trace.sourceMacTrace = sourceMacTrace;
          state.trace.destinationMacTrace = destinationMacTrace;
          state.trace.error = error; // Store combined errors message or null
        }
      })
      .addCase(performFullTrace.rejected, (state, action) => {
        if (action.payload.ignored) return; // Ignore if signaled
        const { message, traceId } = action.payload;
        if (state.trace.id === traceId) { // Check ID match
          state.trace.traceStatus = 'failed';
          state.trace.error = message; // Store the primary error message
           // Explicitly clear results on fundamental failure
           state.trace.mainRouteTrace = null;
           state.trace.sourceMacTrace = null;
           state.trace.destinationMacTrace = null;
        }
      });
  },
});

// Export only the relevant actions for a single trace state
export const { updateTraceInput, resetTraceState } = routeTraceSlice.actions;
export default routeTraceSlice.reducer;

// ----- End File: src\store\slices\routeTraceSlice.js -----

// ----- File: src\store\store.js -----

// ----- File: src\store\store.js -----
// ----- File: src/store/store.js -----

import { configureStore } from '@reduxjs/toolkit';
import authReducer from './slices/authSlice';
import routeTraceReducer from './slices/routeTraceSlice'; // Combined trace
import macTraceReducer from './slices/macTraceSlice'; // MAC trace
import directRouteReducer from './slices/directRouteSlice'; // Direct route trace
import historyReducer from './slices/historySlice';

const store = configureStore({
  reducer: {
    auth: authReducer,
    routeTrace: routeTraceReducer, // State key for combined trace page
    macTrace: macTraceReducer,     // State key for MAC trace page
    directRoute: directRouteReducer, // State key for direct route trace page
    history: historyReducer,
  },
  // Middleware is automatically included by configureStore (e.g., thunk)
});

export default store;

// ----- End File: src/store/store.js -----
// ----- End File: src\store\store.js -----

// ----- End File: src\store\store.js -----

// ----- File: src\theme.js -----

// ----- File: src\theme.js -----
import { createTheme, alpha } from '@mui/material/styles';
import { grey, blue, purple, pink, green, orange, red } from '@mui/material/colors';

// Define base colors for reuse
const primaryLight = blue[300];
const primaryMain = blue[600];
const primaryDark = blue[800];

const secondaryLight = purple[300];
const secondaryMain = purple[500];
const secondaryDark = purple[700];

const errorLight = red[300];
const errorMain = red[600];
const errorDark = red[800];

const warningLight = orange[300];
const warningMain = orange[500];
const warningDark = orange[700];

const successLight = green[300];
const successMain = green[600];
const successDark = green[800];


const getDesignTokens = (mode) => ({
  palette: {
    mode, // 'light' or 'dark'
    primary: {
      light: mode === 'light' ? primaryLight : blue[400], // Lighter shade for dark mode contrast
      main: mode === 'light' ? primaryMain : blue[300],
      dark: mode === 'light' ? primaryDark : blue[200],
      contrastText: mode === 'light' ? grey[50] : grey[900],
    },
    secondary: {
      light: mode === 'light' ? secondaryLight : pink[300], // Using Pink for secondary in dark mode example
      main: mode === 'light' ? secondaryMain : pink[400],
      dark: mode === 'light' ? secondaryDark : pink[500],
      contrastText: mode === 'light' ? grey[50] : grey[900],
    },
    error: {
      light: mode === 'light' ? alpha(errorLight, 0.3) : alpha(errorLight, 0.2), // Lighter bg for alert
      main: mode === 'light' ? errorMain : errorLight,
      dark: mode === 'light' ? errorDark : errorMain,
      contrastText: mode === 'light' ? grey[900] : grey[50],
    },
     warning: {
      light: mode === 'light' ? alpha(warningLight, 0.3) : alpha(warningLight, 0.2),
      main: mode === 'light' ? warningMain : warningLight,
      dark: mode === 'light' ? warningDark : warningMain,
      contrastText: mode === 'light' ? grey[900] : grey[900], // Dark text usually better on orange
    },
     success: {
      light: mode === 'light' ? alpha(successLight, 0.3) : alpha(successLight, 0.2),
      main: mode === 'light' ? successMain : successLight,
      dark: mode === 'light' ? successDark : successMain,
      contrastText: mode === 'light' ? grey[900] : grey[900], // Dark text on green
    },
    grey: grey, // Expose grey palette
    ...(mode === 'light'
      ? {
          // --- Light Mode Specifics ---
          divider: alpha(grey[500], 0.2), // Lighter divider
          text: {
            primary: grey[900],
            secondary: grey[700],
            disabled: grey[500],
          },
          background: {
            default: grey[100], // Very light grey background
            paper: '#ffffff', // White paper
          },
          action: {
            active: grey[700],
            hover: alpha(grey[500], 0.08),
            selected: alpha(grey[500], 0.16),
            disabled: alpha(grey[500], 0.3),
            disabledBackground: alpha(grey[500], 0.12),
            focus: alpha(grey[500], 0.12),
          },
        }
      : {
          // --- Dark Mode Specifics ---
          divider: alpha(grey[500], 0.25), // Slightly more visible divider
          text: {
            primary: grey[50], // Almost white
            secondary: grey[400], // Lighter grey
            disabled: grey[600],
          },
          background: {
            default: '#121212', // Standard dark background
            paper: '#1e1e1e', // Slightly lighter paper/cards
            // paper: grey[900], // Alternative darker paper
          },
          action: {
            active: grey[300],
            hover: alpha(grey[500], 0.1), // Subtle hover
            selected: alpha(grey[500], 0.2), // Visible selection
            disabled: alpha(grey[500], 0.3),
            disabledBackground: alpha(grey[500], 0.12),
            focus: alpha(grey[500], 0.12),
          },
        }),
  },
  // --- Typography ---
  typography: {
      fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
      // Define font sizes, weights etc. if needed
      h4: {
          fontWeight: 500,
      },
      h5: {
          fontWeight: 500,
      },
      h6: {
           fontWeight: 500,
      },
      button: {
          textTransform: 'none', // Keep button text case as defined
          fontWeight: 500,
      }
  },
  // --- Shape ---
  shape: {
      borderRadius: 8, // Slightly more rounded corners globally
  },
  // --- Component Overrides ---
  components: {
      // Example: Default Paper elevation and variant
      MuiPaper: {
          defaultProps: {
              // elevation: 1, // Set default elevation if desired
          },
          styleOverrides: {
              // Example: Apply outline variant globally if preferred
              // root: ({ ownerState, theme }) => ({
              //   ...(ownerState.variant === 'outlined' && {
              //      borderColor: theme.palette.divider,
              //   }),
              // }),
          }
      },
       MuiAlert: {
            styleOverrides: {
                root: ({ ownerState, theme }) => ({
                    // Use standard alert styling provided by MUI based on severity
                    // Add custom border/background based on severity
                    ...(ownerState.severity === 'error' && {
                        backgroundColor: theme.palette.error.light, // Use light background from palette
                        color: theme.palette.getContrastText(theme.palette.error.light), // Ensure text contrast
                        border: `1px solid ${alpha(theme.palette.error.main, 0.5)}`,
                    }),
                     ...(ownerState.severity === 'warning' && {
                        backgroundColor: theme.palette.warning.light,
                        color: theme.palette.getContrastText(theme.palette.warning.light),
                        border: `1px solid ${alpha(theme.palette.warning.main, 0.5)}`,
                    }),
                     ...(ownerState.severity === 'info' && {
                        backgroundColor: theme.palette.info?.light || alpha(theme.palette.primary.light, 0.1), // Fallback if info not fully defined
                        color: theme.palette.info?.contrastText || theme.palette.text.primary,
                        border: `1px solid ${alpha(theme.palette.info?.main || theme.palette.primary.main, 0.5)}`,
                    }),
                     ...(ownerState.severity === 'success' && {
                        backgroundColor: theme.palette.success.light,
                        color: theme.palette.getContrastText(theme.palette.success.light),
                        border: `1px solid ${alpha(theme.palette.success.main, 0.5)}`,
                    }),
                }),
                standardError: { // Specific overrides for standard variant if needed
                    // backgroundColor: errorLight, ...
                },
                 standardWarning: {},
                 standardInfo: {},
                 standardSuccess: {},
            }
       },
      MuiButton: {
          defaultProps: {
              // disableElevation: true, // Flat buttons by default?
          },
          styleOverrides: {
               root: {
                   // Example: Slightly larger default padding
                   // padding: '8px 16px',
               }
          }
      },
      MuiTextField: {
            defaultProps: {
                variant: 'outlined', // Default variant
                size: 'small', // Default size
            },
      },
      MuiChip: {
          styleOverrides: {
              root: {
                  // Ensure chips don't get too large
                  // maxWidth: 180,
              }
          }
      },
      MuiTooltip: {
          defaultProps: {
              arrow: true, // Add arrow to tooltips by default
          },
      },
       MuiAccordion: {
            defaultProps: {
                 // disableGutters: true, // Remove default spacing if needed
                 elevation: 0, // Default to no shadow
                 variant: 'outlined' // Use outlined variant by default
            },
             styleOverrides: {
                root: ({theme}) => ({
                    // Control border between accordions
                     '&:not(:last-child)': {
                        borderBottom: 0, // Handled by individual accordion outlines
                     },
                     '&:before': { // Remove the default top border line
                         display: 'none',
                     },
                     '&.Mui-expanded': {
                        // margin: 'auto', // Remove default expansion margin if needed
                     },
                    // Slightly rounder corners if desired, matches global shape
                    // borderRadius: theme.shape.borderRadius,
                    // '&:first-of-type': {
                    //     borderTopLeftRadius: theme.shape.borderRadius,
                    //     borderTopRightRadius: theme.shape.borderRadius,
                    // },
                    // '&:last-of-type': {
                    //      borderBottomLeftRadius: theme.shape.borderRadius,
                    //      borderBottomRightRadius: theme.shape.borderRadius,
                    // }
                 }),
             }
       },
        MuiAccordionSummary: {
            styleOverrides: {
                root: {
                    minHeight: 48, // Consistent height
                     '&.Mui-expanded': {
                         minHeight: 48,
                     },
                },
                 content: {
                    margin: '12px 0', // Default vertical margin
                     '&.Mui-expanded': {
                         margin: '12px 0',
                     },
                 }
            }
        }
  },
});

export default getDesignTokens;

// ----- End File: src\theme.js -----

// ----- File: src\utils\formatters.js -----

// ----- File: src\utils\formatters.js -----
import { format, formatDistanceToNow, isValid } from 'date-fns'; // Using date-fns

/**
 * Formats a timestamp into a human-readable string.
 * @param {string | number | Date} timestamp - The timestamp to format (ISO string, epoch ms, or Date object).
 * @param {string} fmt - The date-fns format string (e.g., 'yyyy-MM-dd HH:mm:ss', 'PPp', 'short').
 *                       See: https://date-fns.org/v2.28.0/docs/format
 * @returns {string} The formatted date string or 'N/A' if invalid.
 */
export const formatTimestamp = (timestamp, fmt = 'yyyy-MM-dd HH:mm:ss') => {
  if (!timestamp) return 'N/A';

  try {
    const date = new Date(timestamp);

    // Check if the created date object is valid
    if (!isValid(date)) {
        console.warn(`Invalid timestamp provided for formatting: ${timestamp}`);
        // Attempt to return original if it looks somewhat readable, else 'Invalid Date'
        return typeof timestamp === 'string' ? timestamp : 'Invalid Date';
    }

    // Handle special format keywords
    if (fmt === 'relative') {
      return formatDistanceToNow(date, { addSuffix: true });
    }
    if (fmt === 'short') {
        fmt = 'MMM d, HH:mm'; // Example short format
    }

    return format(date, fmt);
  } catch (error) {
    console.error("Error formatting timestamp:", error, "Input:", timestamp);
    // Attempt to return original if it looks somewhat readable, else 'Formatting Error'
    return typeof timestamp === 'string' ? timestamp : 'Formatting Error';
  }
};

// Example usage:
// formatTimestamp('2023-10-27T10:30:00Z') -> "2023-10-27 10:30:00" (depends on local timezone)
// formatTimestamp('2023-10-27T10:30:00Z', 'PPp') -> "Oct 27, 2023, 10:30:00 AM"
// formatTimestamp(Date.now() - 60000, 'relative') -> "about 1 minute ago"
// formatTimestamp('invalid-date-string') -> "invalid-date-string" (or "Invalid Date")

// ----- End File: src\utils\formatters.js -----

