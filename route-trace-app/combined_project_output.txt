--- Project Tree ---

route-trace-app/
├── public
│   ├── index.html
│   ├── manifest.json
│   └── robots.txt
├── src
│   ├── components
│   │   ├── Auth
│   │   │   └── LoginForm.jsx
│   │   ├── Common
│   │   │   ├── ErrorMessage.jsx
│   │   │   ├── LoadingSpinner.jsx
│   │   │   ├── Navbar.jsx
│   │   │   └── Sidebar.jsx
│   │   ├── Comparison
│   │   │   ├── ComparisonItem.jsx
│   │   │   ├── ComparisonSelector.jsx
│   │   │   └── HistoryRouteVisualizer.jsx
│   │   ├── History
│   │   │   ├── HistoryItem.jsx
│   │   │   └── HistoryList.jsx
│   │   └── RouteTrace
│   │       ├── DirectRouteTraceInputForm.jsx
│   │       ├── DirectRouteTraceSection.jsx
│   │       ├── DirectRouteVisualizer.jsx
│   │       ├── HopDisplay.jsx
│   │       ├── MacTraceDisplay.jsx
│   │       ├── MacTraceInputForm.jsx
│   │       ├── MacTraceSection.jsx
│   │       ├── MacTraceVisualizer.jsx
│   │       ├── RouteComparisonContainer.jsx
│   │       ├── RouteInputForm.jsx
│   │       ├── RouteTraceSection.jsx
│   │       └── RouteVisualizer.jsx
│   ├── hooks
│   │   └── useAuth.js
│   ├── pages
│   │   ├── AllRoutesPage.jsx
│   │   ├── ComparisonPage.jsx
│   │   ├── DirectRouteTracePage.jsx
│   │   ├── HistoryPage.jsx
│   │   ├── LoginPage.jsx
│   │   ├── MacTracePage.jsx
│   │   ├── NotFoundPage.jsx
│   │   └── RouteTracePage.jsx
│   ├── services
│   │   ├── api.js
│   │   ├── authService.js
│   │   └── routeService.js
│   ├── store
│   │   ├── slices
│   │   │   ├── authSlice.js
│   │   │   ├── directRouteSlice.js
│   │   │   ├── historySlice.js
│   │   │   ├── macTraceSlice.js
│   │   │   └── routeTraceSlice.js
│   │   └── store.js
│   ├── utils
│   │   └── formatters.js
│   ├── App.css
│   ├── App.js
│   ├── App.test.js
│   ├── index.css
│   ├── index.js
│   ├── reportWebVitals.js
│   ├── setupTests.js
│   └── theme.js
├── .gitignore
├── combine_project.js
├── package.json
└── README.md


--- File Contents ---

// ----- File: .gitignore -----

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*


// ----- End File: .gitignore -----

// ----- File: README.md -----

# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: [https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

### Analyzing the Bundle Size

This section has moved here: [https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

### Making a Progressive Web App

This section has moved here: [https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

### Advanced Configuration

This section has moved here: [https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

### Deployment

This section has moved here: [https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

### `npm run build` fails to minify

This section has moved here: [https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)


// ----- End File: README.md -----

// ----- File: combine_project.js -----

const fs = require('fs');
const path = require('path');

// --- Configuration ---

// Directories to completely ignore
const EXCLUDED_DIRS = [
    'node_modules',
    '.git',
    'build',
    'coverage',
    '.vscode',
    '.idea',
    '. Caches' // Example for specific tools
];

// Specific files to ignore
const EXCLUDED_FILES = [
    'package-lock.json',
    'yarn.lock',
    '.env',
    '.DS_Store'
];

// File extensions to ignore (lower-cased)
const EXCLUDED_EXTENSIONS = [
    '.png', '.jpg', '.jpeg', '.gif', '.bmp', '.tiff', '.webp', // Images
    '.svg', // SVGs can be code, but often treated as assets in CRA
    '.ico', // Favicon
    '.woff', '.woff2', '.ttf', '.eot', // Fonts
    '.mp4', '.mov', '.avi', // Videos
    '.mp3', '.wav', // Audio
    '.map', // Source maps
    '.pdf', '.doc', '.docx', '.xls', '.xlsx', // Documents
    '.zip', '.gz', '.tar' // Archives
];

// File extensions to *include* (if not excluded elsewhere). Add more if needed.
// If empty, all non-excluded extensions will be included.
// Useful if you *only* want specific source types.
const INCLUDED_EXTENSIONS = [
    // '.js', '.jsx', '.ts', '.tsx', // Javascript/Typescript
    // '.css', '.scss', '.sass', '.less', '.module.css', // Stylesheets
    // '.json', // Config files, data
    // '.html', // HTML files (like public/index.html)
    // '.md' // Markdown
]; // Leave empty to include *all* non-excluded files

const OUTPUT_FILE = 'combined_project_output.txt';

// --- Helper Functions ---

function isExcluded(relativePath, stats) {
    const baseName = path.basename(relativePath);
    const ext = path.extname(baseName).toLowerCase();

    if (stats.isDirectory()) {
        return EXCLUDED_DIRS.includes(baseName);
    }

    if (EXCLUDED_FILES.includes(baseName)) {
        return true;
    }

    if (EXCLUDED_EXTENSIONS.includes(ext)) {
        return true;
    }

    // If INCLUDED_EXTENSIONS is specified, *only* include those
    if (INCLUDED_EXTENSIONS.length > 0 && !INCLUDED_EXTENSIONS.includes(ext)) {
        return true;
    }


    return false;
}

// --- Tree Generation ---

function generateTree(dir, rootDir, prefix = '', includedFiles) {
    let tree = '';
    try {
        const entries = fs.readdirSync(dir, { withFileTypes: true });
        const filteredEntries = entries
            .filter(entry => {
                 // Always check exclusion based on the *full* relative path from the root
                const entryRelativePath = path.relative(rootDir, path.join(dir, entry.name));
                const stats = fs.statSync(path.join(dir, entry.name)); // Need stats for isExcluded check
                 // Don't add excluded items to the tree *at all*
                return !isExcluded(entryRelativePath, stats);
            })
            .sort((a, b) => {
                // Directories first, then files, then alphabetically
                if (a.isDirectory() && !b.isDirectory()) return -1;
                if (!a.isDirectory() && b.isDirectory()) return 1;
                return a.name.localeCompare(b.name);
            });

        filteredEntries.forEach((entry, index) => {
            const isLast = index === filteredEntries.length - 1;
            const connector = isLast ? '└── ' : '├── ';
            const entryPath = path.join(dir, entry.name);
            const entryRelativePath = path.relative(rootDir, entryPath); // Path relative to project root

            tree += `${prefix}${connector}${entry.name}\n`;

            if (entry.isDirectory()) {
                const newPrefix = prefix + (isLast ? '    ' : '│   ');
                tree += generateTree(entryPath, rootDir, newPrefix, includedFiles);
            } else {
                // Optionally: Only add files to the tree that will be included in the content part
                 if (includedFiles.has(entryRelativePath)) {
                     // File already added during tree build if check is here
                 } else {
                    // If we want the tree to show *all* non-excluded files, even if INCLUDED_EXTENSIONS
                    // limits content, then we don't need the check above.
                    // Current implementation shows all non-excluded files/dirs in the tree.
                 }
            }
        });
    } catch (err) {
        console.error(`Error reading directory ${dir}: ${err.message}`);
        tree += `${prefix}└── [Error reading directory]\n`;
    }
    return tree;
}


// --- File Content Gathering ---

function gatherFileContents(dir, rootDir) {
    let filesToInclude = new Map(); // Using Map to store { relativePath: absolutePath }

    function traverse(currentDir) {
        try {
            const entries = fs.readdirSync(currentDir, { withFileTypes: true });

            for (const entry of entries) {
                const absolutePath = path.join(currentDir, entry.name);
                const relativePath = path.relative(rootDir, absolutePath);
                 // Use statSync here to check if it's a file or dir for exclusion
                let stats;
                 try {
                     stats = fs.statSync(absolutePath);
                 } catch (statErr) {
                     console.warn(`Warning: Could not stat ${absolutePath}. Skipping. Error: ${statErr.message}`);
                     continue; // Skip if stat fails (e.g., broken symlink)
                 }


                if (isExcluded(relativePath, stats)) {
                    // console.log(`Excluding: ${relativePath}`); // Uncomment for debugging exclusions
                    continue;
                }

                if (entry.isDirectory()) {
                    traverse(absolutePath);
                } else if (entry.isFile()) {
                    // console.log(`Including: ${relativePath}`); // Uncomment for debugging inclusions
                    filesToInclude.set(relativePath, absolutePath);
                }
            }
        } catch (err) {
            console.error(`Error reading directory ${currentDir}: ${err.message}`);
        }
    }

    traverse(dir);
    return filesToInclude; // Return the Map
}

// --- Main Execution ---

function main() {
    // Use current directory as default, or first command-line argument
    const projectDir = path.resolve(process.argv[2] || '.');
    const outputFilePath = path.join(projectDir, OUTPUT_FILE); // Output in the project dir

    console.log(`Scanning project directory: ${projectDir}`);
    console.log(`Output will be written to: ${outputFilePath}`);

    if (!fs.existsSync(projectDir) || !fs.statSync(projectDir).isDirectory()) {
        console.error(`Error: Project directory not found or is not a directory: ${projectDir}`);
        process.exit(1);
    }

    // 1. Gather all files first to know what will be included in the content
    const includedFilesMap = gatherFileContents(projectDir, projectDir); // Map { relativePath: absolutePath }
    const includedFileRelativePaths = new Set(includedFilesMap.keys()); // Set { relativePath } for quick lookup in tree generation

    // 2. Generate the project tree (pass the set of included files for potential filtering)
    console.log("Generating project tree...");
    const projectName = path.basename(projectDir);
    const projectTree = `${projectName}/\n` + generateTree(projectDir, projectDir, '', includedFileRelativePaths);


    // 3. Read and combine file contents
    console.log(`Reading content of ${includedFilesMap.size} files...`);
    let combinedContent = '';
    const sortedRelativePaths = Array.from(includedFilesMap.keys()).sort(); // Sort for consistent order

    for (const relativePath of sortedRelativePaths) {
        const absolutePath = includedFilesMap.get(relativePath);
        try {
            const content = fs.readFileSync(absolutePath, 'utf8');
            combinedContent += `// ----- File: ${relativePath} -----\n\n`;
            combinedContent += content;
            combinedContent += '\n\n// ----- End File: ' + relativePath + ' -----\n\n';
        } catch (err) {
            console.warn(`Warning: Could not read file ${absolutePath}. Skipping. Error: ${err.message}`);
            combinedContent += `// ----- File: ${relativePath} -----\n\n`;
            combinedContent += `// ***** Error reading file: ${err.message} *****\n\n`;
             combinedContent += '// ----- End File: ' + relativePath + ' -----\n\n';
        }
    }

    // 4. Combine tree and content
    const finalOutput = `--- Project Tree ---\n\n${projectTree}\n\n--- File Contents ---\n\n${combinedContent}`;

    // 5. Write to output file
    console.log(`Writing combined output to ${outputFilePath}...`);
    try {
        fs.writeFileSync(outputFilePath, finalOutput, 'utf8');
        console.log('Done!');
    } catch (err) {
        console.error(`Error writing output file ${outputFilePath}: ${err.message}`);
        process.exit(1);
    }
}

main();

// ----- End File: combine_project.js -----

// ----- File: package.json -----

{
  "name": "route-trace-app",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@mui/icons-material": "^7.0.2",
    "@mui/material": "^7.0.2",
    "@reduxjs/toolkit": "^2.6.1",
    "@testing-library/dom": "^10.4.0",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^13.5.0",
    "axios": "^1.8.4",
    "date-fns": "^4.1.0",
    "js-cookie": "^3.0.5",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "react-redux": "^9.2.0",
    "react-router-dom": "^7.5.0",
    "react-scripts": "5.0.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}


// ----- End File: package.json -----

// ----- File: public\index.html -----

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="RouteTrace Network Utility"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!-- Material UI Fonts -->
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
    />
    <title>RouteTrace</title>
    <!-- Remove inline body style -->
    <style>
      body {
        margin: 0;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
          'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
          sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        /* Background color will be set by MUI ThemeProvider + CssBaseline */
      }
    </style>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>

// ----- End File: public\index.html -----

// ----- File: public\manifest.json -----

{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}


// ----- End File: public\manifest.json -----

// ----- File: public\robots.txt -----

# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:


// ----- End File: public\robots.txt -----

// ----- File: src\App.css -----

.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}


// ----- End File: src\App.css -----

// ----- File: src\App.js -----

// ----- File: src/App.js -----

import React, { useState, useMemo } from 'react';
import { Routes, Route, Navigate, useLocation } from 'react-router-dom';
import {
    Box,
    CssBaseline,
    ThemeProvider,
    AppBar,
    Toolbar,
    IconButton,
    Typography,
    Container,
    createTheme
} from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import LoginPage from './pages/LoginPage';
import RouteTracePage from './pages/RouteTracePage'; // Combined Trace
import MacTracePage from './pages/MacTracePage'; // MAC Trace
import DirectRouteTracePage from './pages/DirectRouteTracePage'; // Direct Route Trace
import HistoryPage from './pages/HistoryPage';
import AllRoutesPage from './pages/AllRoutesPage';
import ComparisonPage from './pages/ComparisonPage'; // <-- Import the new Comparison Page
import NotFoundPage from './pages/NotFoundPage';
import Sidebar from './components/Common/Sidebar';
import { useAuth } from './hooks/useAuth';
import getDesignTokens from './theme';

const drawerWidth = 240;

function ProtectedRoute({ children }) {
  const { isAuthenticated } = useAuth();
  const location = useLocation();

  if (!isAuthenticated) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return children;
}

function App() {
  const { isAuthenticated } = useAuth();
  const [mobileOpen, setMobileOpen] = useState(false);
  const [mode, setMode] = useState(() => {
      const savedMode = localStorage.getItem('themeMode');
      return savedMode === 'dark' ? 'dark' : 'light';
  });

  const handleDrawerToggle = () => {
    setMobileOpen(!mobileOpen);
  };

  const colorMode = useMemo(
    () => ({
      toggleColorMode: () => {
        setMode((prevMode) => {
          const newMode = prevMode === 'light' ? 'dark' : 'light';
          localStorage.setItem('themeMode', newMode);
          return newMode;
        });
      },
    }),
    [],
  );

  const theme = useMemo(() => createTheme(getDesignTokens(mode)), [mode]);

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <Box sx={{ display: 'flex', minHeight: '100vh' }}>

        {isAuthenticated && (
          <Sidebar
            drawerWidth={drawerWidth}
            mobileOpen={mobileOpen}
            handleDrawerToggle={handleDrawerToggle}
            mode={mode}
            toggleColorMode={colorMode.toggleColorMode}
          />
        )}

        <Box
          component="main"
          sx={{
            flexGrow: 1,
            pt: isAuthenticated ? `calc(${theme.mixins.toolbar.minHeight}px + ${theme.spacing(3)})` : theme.spacing(3),
            pb: 3,
            px: 3,
            width: isAuthenticated ? { md: `calc(100% - ${drawerWidth}px)` } : '100%',
            ml: isAuthenticated ? { md: `${drawerWidth}px` } : 0,
            transition: theme.transitions.create(['margin', 'width'], {
                 easing: theme.transitions.easing.sharp,
                 duration: theme.transitions.duration.leavingScreen,
            }),
            // Ensure main content area can scroll if needed
            overflowY: 'auto',
          }}
        >
           {isAuthenticated && (
                <AppBar
                    position="fixed"
                    elevation={1}
                    sx={{
                        width: { md: `calc(100% - ${drawerWidth}px)` },
                        ml: { md: `${drawerWidth}px` },
                        display: { xs: 'block', md: 'none' }
                    }}
                >
                    <Toolbar>
                        <IconButton
                            color="inherit"
                            aria-label="open drawer"
                            edge="start"
                            onClick={handleDrawerToggle}
                            sx={{ mr: 2, display: { md: 'none' } }}
                        >
                            <MenuIcon />
                        </IconButton>
                        <Typography variant="h6" noWrap component="div">
                            RouteTrace
                        </Typography>
                    </Toolbar>
                </AppBar>
            )}

             <Routes>
                <Route path="/login" element={<LoginPage />} />
                <Route
                    path="/" // Combined Trace
                    element={
                    <ProtectedRoute>
                        <RouteTracePage />
                    </ProtectedRoute>
                    }
                />
                 <Route
                    path="/mac-trace" // MAC Trace
                    element={
                    <ProtectedRoute>
                        <MacTracePage />
                    </ProtectedRoute>
                    }
                />
                 <Route
                    path="/direct-route-trace" // Direct Route Trace
                    element={
                    <ProtectedRoute>
                        <DirectRouteTracePage />
                    </ProtectedRoute>
                    }
                />
                {/* Add the new Comparison Page route */}
                 <Route
                    path="/comparison"
                    element={
                    <ProtectedRoute>
                        <ComparisonPage />
                    </ProtectedRoute>
                    }
                />
                <Route
                    path="/history"
                    element={
                    <ProtectedRoute>
                        <HistoryPage />
                    </ProtectedRoute>
                    }
                />
                <Route
                    path="/all-routes"
                    element={
                    <ProtectedRoute>
                        <AllRoutesPage />
                    </ProtectedRoute>
                    }
                />
                <Route path="*" element={<NotFoundPage />} />
             </Routes>
        </Box>
      </Box>
    </ThemeProvider>
  );
}

export default App;

// ----- End File: src/App.js -----

// ----- End File: src\App.js -----

// ----- File: src\App.test.js -----

import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});


// ----- End File: src\App.test.js -----

// ----- File: src\components\Auth\LoginForm.jsx -----

import React, { useState, useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { useNavigate, useLocation } from 'react-router-dom';
import { TextField, Button, Box, Typography, CircularProgress, Alert } from '@mui/material';
import { loginUser, resetAuthError } from '../../store/slices/authSlice';

const LoginForm = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const dispatch = useDispatch();
  const navigate = useNavigate();
  const location = useLocation();
  const { loading, error, isAuthenticated } = useSelector((state) => state.auth);

  const from = location.state?.from?.pathname || "/"; // Redirect path after login

  // Redirect if already logged in
  useEffect(() => {
      if (isAuthenticated) {
          navigate(from, { replace: true });
      }
  }, [isAuthenticated, navigate, from]);

  // Clear error when component mounts or unmounts
  useEffect(() => {
      dispatch(resetAuthError());
      return () => {
          dispatch(resetAuthError());
      };
  }, [dispatch]);


  const handleSubmit = (e) => {
    e.preventDefault();
    if (!username || !password) return; // Basic validation
    dispatch(loginUser({ username, password }))
      .unwrap() // Allows chaining .then() and .catch() on the dispatch
      .then(() => {
        navigate(from, { replace: true }); // Redirect on successful login
      })
      .catch((err) => {
        // Error is already handled by the slice and displayed via useSelector
        console.error("Login failed:", err);
      });
  };

  return (
    <Box
      component="form"
      onSubmit={handleSubmit}
      sx={{
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        maxWidth: 400,
        margin: 'auto',
        mt: 8,
        p: 3,
        boxShadow: 3,
        borderRadius: 2,
        bgcolor: 'background.paper'
      }}
    >
      <Typography variant="h5" component="h1" gutterBottom>
        Login
      </Typography>
      {error && <Alert severity="error" sx={{ width: '100%', mb: 2 }}>{error}</Alert>}
      <TextField
        label="Username"
        variant="outlined"
        margin="normal"
        required
        fullWidth
        value={username}
        onChange={(e) => setUsername(e.target.value)}
        disabled={loading}
      />
      <TextField
        label="Password"
        type="password"
        variant="outlined"
        margin="normal"
        required
        fullWidth
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        disabled={loading}
      />
      <Button
        type="submit"
        variant="contained"
        color="primary"
        fullWidth
        disabled={loading}
        sx={{ mt: 3, mb: 2, position: 'relative' }}
      >
        {loading ? <CircularProgress size={24} sx={{
             position: 'absolute',
             top: '50%',
             left: '50%',
             marginTop: '-12px',
             marginLeft: '-12px',
        }}/> : 'Login'}
      </Button>
    </Box>
  );
};

export default LoginForm;

// ----- End File: src\components\Auth\LoginForm.jsx -----

// ----- File: src\components\Common\ErrorMessage.jsx -----

import React from 'react';
import { Alert, AlertTitle } from '@mui/material';

const ErrorMessage = ({ error, title = "Error" }) => {
  if (!error) return null;

  const message = typeof error === 'string' ? error : error.message || 'An unexpected error occurred.';

  return (
    <Alert severity="error" sx={{ mt: 2, mb: 2 }}>
      <AlertTitle>{title}</AlertTitle>
      {message}
    </Alert>
  );
};

export default ErrorMessage;

// ----- End File: src\components\Common\ErrorMessage.jsx -----

// ----- File: src\components\Common\LoadingSpinner.jsx -----

import React from 'react';
import { Box, CircularProgress } from '@mui/material';

const LoadingSpinner = ({ size = 40 }) => (
  <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', p: 2 }}>
    <CircularProgress size={size} />
  </Box>
);

export default LoadingSpinner;

// ----- End File: src\components\Common\LoadingSpinner.jsx -----

// ----- File: src\components\Common\Navbar.jsx -----

import React from 'react';
import { useDispatch } from 'react-redux';
import { Link as RouterLink, useNavigate } from 'react-router-dom';
import { AppBar, Toolbar, Typography, Button, Box, IconButton } from '@mui/material';
import AccountTreeIcon from '@mui/icons-material/AccountTree'; // Example icon
import { logoutUser } from '../../store/slices/authSlice';

const Navbar = () => {
  const dispatch = useDispatch();
  const navigate = useNavigate();

  const handleLogout = () => {
    dispatch(logoutUser());
    navigate('/login'); // Redirect to login after logout
  };

  return (
    <AppBar position="fixed">
      <Toolbar>
         <IconButton
          size="large"
          edge="start"
          color="inherit"
          aria-label="logo"
          component={RouterLink}
          to="/"
          sx={{ mr: 1 }}
        >
          <AccountTreeIcon />
        </IconButton>
        <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
          RouteTrace
        </Typography>
        <Box sx={{ '& button': { ml: 1 } }}>
             <Button color="inherit" component={RouterLink} to="/">
                 Trace Route
            </Button>
             <Button color="inherit" component={RouterLink} to="/history">
                 My History
            </Button>
              <Button color="inherit" component={RouterLink} to="/all-routes">
                 All Routes
            </Button>
            <Button color="inherit" onClick={handleLogout}>
                Logout
            </Button>
        </Box>
      </Toolbar>
    </AppBar>
  );
};

export default Navbar;

// ----- End File: src\components\Common\Navbar.jsx -----

// ----- File: src\components\Common\Sidebar.jsx -----

// ----- File: src/components/Common/Sidebar.jsx -----

import React from 'react';
import { useDispatch } from 'react-redux';
import { Link as RouterLink, useNavigate, useLocation } from 'react-router-dom';
import {
    Drawer, Box, List, ListItem, ListItemButton, ListItemIcon,
    ListItemText, Toolbar, Divider, Typography, IconButton, Tooltip
} from '@mui/material';
import AccountTreeIcon from '@mui/icons-material/AccountTree';
import RouteIcon from '@mui/icons-material/Route'; // Combined Trace
import SettingsEthernetIcon from '@mui/icons-material/SettingsEthernet'; // MAC Trace
import NetworkCheckIcon from '@mui/icons-material/NetworkCheck'; // Direct Route Trace
import CompareArrowsIcon from '@mui/icons-material/CompareArrows'; // <-- Icon for Comparison Page
import HistoryIcon from '@mui/icons-material/History'; // My History
import PeopleIcon from '@mui/icons-material/People'; // All Routes
import LogoutIcon from '@mui/icons-material/Logout';
import Brightness4Icon from '@mui/icons-material/Brightness4'; // Dark mode
import Brightness7Icon from '@mui/icons-material/Brightness7'; // Light mode
import { logoutUser } from '../../store/slices/authSlice';
import { useAuth } from '../../hooks/useAuth';

const Sidebar = ({ drawerWidth, mobileOpen, handleDrawerToggle, mode, toggleColorMode }) => {
    const dispatch = useDispatch();
    const navigate = useNavigate();
    const location = useLocation();
    const { user } = useAuth();

    const handleLogout = () => {
        dispatch(logoutUser());
        navigate('/login');
    };

    // Updated Menu Items including Comparison
    const menuItems = [
        { text: 'Combined Trace', icon: <RouteIcon />, path: '/' },
        { text: 'Direct Route Trace', icon: <NetworkCheckIcon />, path: '/direct-route-trace' },
        { text: 'MAC Trace', icon: <SettingsEthernetIcon />, path: '/mac-trace' },
        { text: 'Compare Traces', icon: <CompareArrowsIcon />, path: '/comparison' }, // <-- New Comparison Link
        { text: 'My History', icon: <HistoryIcon />, path: '/history' },
        { text: 'All Routes', icon: <PeopleIcon />, path: '/all-routes' },
    ];

    const drawerContent = (
        <Box sx={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
            <Toolbar sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 1 }}>
                <AccountTreeIcon fontSize="large" color="primary" />
                <Typography variant="h6" noWrap component="div" color="primary">
                    RouteTrace
                </Typography>
            </Toolbar>
            <Divider />
            <List sx={{ flexGrow: 1 }}>
                {menuItems.map((item) => (
                    <ListItem key={item.text} disablePadding>
                        <ListItemButton
                            component={RouterLink}
                            to={item.path}
                            selected={location.pathname === item.path}
                            onClick={handleDrawerToggle} // Close mobile drawer on item click
                        >
                            <ListItemIcon sx={{ minWidth: '40px' }}>{item.icon}</ListItemIcon>
                            <ListItemText primary={item.text} />
                        </ListItemButton>
                    </ListItem>
                ))}
            </List>
            <Divider />
            <List>
                 <ListItem disablePadding>
                      <ListItemText sx={{pl: 2}} primary={`User: ${user?.username || 'Unknown'}`} />
                      <Tooltip title={`Switch to ${mode === 'dark' ? 'light' : 'dark'} mode`}>
                        <IconButton onClick={toggleColorMode} color="inherit">
                            {mode === 'dark' ? <Brightness7Icon /> : <Brightness4Icon />}
                        </IconButton>
                      </Tooltip>
                 </ListItem>
                <ListItem disablePadding>
                    <ListItemButton onClick={handleLogout}>
                        <ListItemIcon sx={{ minWidth: '40px' }}>
                            <LogoutIcon />
                        </ListItemIcon>
                        <ListItemText primary="Logout" />
                    </ListItemButton>
                </ListItem>
            </List>
        </Box>
    );

    return (
        <Box
            component="nav"
            sx={{ width: { md: drawerWidth }, flexShrink: { md: 0 } }}
            aria-label="mailbox folders"
        >
            <Drawer
                variant="temporary"
                open={mobileOpen}
                onClose={handleDrawerToggle}
                ModalProps={{ keepMounted: true }}
                sx={{
                    display: { xs: 'block', md: 'none' },
                    '& .MuiDrawer-paper': { boxSizing: 'border-box', width: drawerWidth },
                }}
            >
                {drawerContent}
            </Drawer>
            <Drawer
                variant="permanent"
                sx={{
                    display: { xs: 'none', md: 'block' },
                    '& .MuiDrawer-paper': { boxSizing: 'border-box', width: drawerWidth },
                }}
                open
            >
                {drawerContent}
            </Drawer>
        </Box>
    );
};

export default Sidebar;

// ----- End File: src/components/Common/Sidebar.jsx -----

// ----- End File: src\components\Common\Sidebar.jsx -----

// ----- File: src\components\Comparison\ComparisonItem.jsx -----

// ----- File: src/components/Comparison/ComparisonItem.jsx -----

import React from 'react';
import { Paper, Box, IconButton, Tooltip, Typography } from '@mui/material';
import HistoryRouteVisualizer from './HistoryRouteVisualizer';
// import CloseIcon from '@mui/icons-material/Close'; // Removing close button for now, handled by selector

// This component acts as a wrapper for HistoryRouteVisualizer
// to fit into the structure expected by RouteComparisonContainer.
// RouteComparisonContainer passes 'trace' and 'canRemove'.
// We adapt the 'route' prop from ComparisonPage to the 'trace' prop name.
const ComparisonItem = ({ trace: route }) => {
    // The 'canRemove' prop from RouteComparisonContainer might not be directly used here.
    // Removal is handled by the ComparisonSelector.

    if (!route) return null;

    return (
        // We use Paper similar to other Section components for consistency
        <Paper elevation={2} sx={{ p: 2, mb: 3, position: 'relative', height: '100%' }}>
            {/* Optional: Add a header specific to the comparison item */}
            {/* <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1, borderBottom: 1, borderColor: 'divider', pb:1 }}>
                <Typography variant="subtitle1">Trace ID: {route.id}</Typography> */}
                {/* Add remove button here if needed, linking back to ComparisonPage state */}
            {/* </Box> */}

            <HistoryRouteVisualizer route={route} />
        </Paper>
    );
};

export default ComparisonItem;

// ----- End File: src/components/Comparison/ComparisonItem.jsx -----

// ----- End File: src\components\Comparison\ComparisonItem.jsx -----

// ----- File: src\components\Comparison\ComparisonSelector.jsx -----

// ----- File: src/components/Comparison/ComparisonSelector.jsx -----

import React from 'react';
import { Autocomplete, TextField, Checkbox, Box, Typography, Chip } from '@mui/material';
import CheckBoxOutlineBlankIcon from '@mui/icons-material/CheckBoxOutlineBlank';
import CheckBoxIcon from '@mui/icons-material/CheckBox';
import { formatTimestamp } from '../../utils/formatters';

const icon = <CheckBoxOutlineBlankIcon fontSize="small" />;
const checkedIcon = <CheckBoxIcon fontSize="small" />;

const ComparisonSelector = ({ availableRoutes, selectedIds, onChange }) => {

    // Find the route objects corresponding to the selected IDs
    const selectedRoutes = availableRoutes.filter(route => selectedIds.includes(route.id));

    // --- FIX: Create a copy before sorting ---
    // Use the spread syntax (...) to create a shallow copy of the array
    const sortedOptions = [...availableRoutes].sort((a, b) => {
        // Robust date comparison
        const dateA = a.timestamp ? new Date(a.timestamp) : 0;
        const dateB = b.timestamp ? new Date(b.timestamp) : 0;
        // Ensure valid dates are compared; handle potential invalid dates gracefully
        if (isNaN(dateA) && isNaN(dateB)) return 0;
        if (isNaN(dateA)) return 1; // Put invalid dates last
        if (isNaN(dateB)) return -1; // Put invalid dates last
        return dateB - dateA; // Sort newest first
    });
    // --- End FIX ---

    const getOptionLabel = (option) => {
        // Generate a descriptive label for each route in the dropdown
        const user = option.user ? `User: ${option.user.username}` : 'N/A';
        const time = formatTimestamp(option.timestamp, 'MMM d, HH:mm');
        return `${option.source || 'N/A'} → ${option.destination || 'N/A'} (${time}, ${user}, ID: ${option.id})`;
    };

    const handleChange = (event, newValue) => {
        // Extract just the IDs from the selected route objects
        const newSelectedIds = newValue.map(route => route.id);
        onChange(newSelectedIds);
    };

    return (
        <Box sx={{ mb: 2 }}>
            <Typography variant="h6" gutterBottom>Select Routes to Compare</Typography>
            <Autocomplete
                multiple
                id="route-comparison-selector"
                options={sortedOptions} // <-- Use the sorted COPY
                disableCloseOnSelect
                value={selectedRoutes} // Pass the selected route *objects* to Autocomplete
                getOptionLabel={getOptionLabel} // Function to display each option
                isOptionEqualToValue={(option, value) => option.id === value.id} // How to compare options
                onChange={handleChange} // Handle changes
                renderOption={(props, option, { selected }) => (
                    // Ensure the key is unique and stable if possible, using option.id
                    <li {...props} key={option.id} style={{ display: 'flex', alignItems: 'center' }}>
                        <Checkbox
                            icon={icon}
                            checkedIcon={checkedIcon}
                            style={{ marginRight: 8 }}
                            checked={selected}
                            // Add aria-labelledby or similar for accessibility if needed
                        />
                        <Box sx={{ display: 'flex', flexDirection: 'column', flexGrow: 1 }}>
                             {/* Main route identifier */}
                             <Typography variant="body2" sx={{ wordBreak: 'break-word', lineHeight: 1.3 }}>
                                <Chip label="Src" size="small" color="primary" sx={{ mr: 0.5, height: '18px', verticalAlign: 'middle' }} />
                                <Typography component="span" sx={{ fontWeight: 'medium', verticalAlign: 'middle' }}>{option.source || 'N/A'}</Typography>
                                <Typography component="span" sx={{ mx: 1, verticalAlign: 'middle' }}>→</Typography>
                                <Chip label="Dst" size="small" color="secondary" sx={{ mr: 0.5, height: '18px', verticalAlign: 'middle' }} />
                                <Typography component="span" sx={{ fontWeight: 'medium', verticalAlign: 'middle' }}>{option.destination || 'N/A'}</Typography>
                             </Typography>
                             {/* Secondary details: Timestamp, User, ID */}
                             <Typography variant="caption" color="text.secondary">
                                {formatTimestamp(option.timestamp)} {option.user ? `(${option.user.username})` : ''} (ID: {option.id})
                             </Typography>
                        </Box>
                    </li>
                )}
                renderInput={(params) => (
                    <TextField
                        {...params}
                        variant="outlined"
                        label="Search and Select Historical Traces"
                        placeholder="Select Routes..."
                        // InputLabelProps={{ shrink: true }} // Optional: always show label shrunk
                    />
                )}
                sx={{ width: '100%' }} // Make it full width
            />
        </Box>
    );
};

export default ComparisonSelector;

// ----- End File: src/components/Comparison/ComparisonSelector.jsx -----

// ----- End File: src\components\Comparison\ComparisonSelector.jsx -----

// ----- File: src\components\Comparison\HistoryRouteVisualizer.jsx -----

// ----- File: src/components/Comparison/HistoryRouteVisualizer.jsx -----

import React from 'react';
import { Box, Typography, Stack, Paper, Accordion, AccordionSummary, AccordionDetails, Chip, Divider } from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import InfoIcon from '@mui/icons-material/Info';
import AccountTreeIcon from '@mui/icons-material/AccountTree';
import DeviceUnknownIcon from '@mui/icons-material/DeviceUnknown';
import HopDisplay from '../RouteTrace/HopDisplay'; // Reuse the hop display component
import { formatTimestamp } from '../../utils/formatters';

const HistoryRouteVisualizer = ({ route }) => {
    const { id, source, destination, timestamp, routeData, deviceInfo, user } = route;

    // Check if routeData is valid (should be an array from historySlice parsing)
    const hasValidRouteData = Array.isArray(routeData) && routeData.length > 0;
    const hasDeviceInfo = deviceInfo && typeof deviceInfo === 'object' && Object.keys(deviceInfo).length > 0;

    return (
        <Box>
            {/* Header Info */}
            <Paper elevation={0} sx={{ p: 1, mb: 2, border: 1, borderColor: 'divider' }}>
                 <Stack direction="row" justifyContent="space-between" alignItems="center" spacing={1} flexWrap="wrap">
                    <Box>
                        <Typography variant="body2" sx={{ display: 'flex', alignItems: 'center', flexWrap: 'wrap', gap: 0.5 }}>
                            <Chip label="Src" size="small" color="primary" sx={{ mr: 0.5}} />
                            <Typography component="span" sx={{wordBreak: 'break-all'}}>{source || 'N/A'}</Typography>
                            <Typography component="span" sx={{ mx: 1 }}>→</Typography>
                            <Chip label="Dst" size="small" color="secondary" sx={{ mr: 0.5}} />
                            <Typography component="span" sx={{wordBreak: 'break-all'}}>{destination || 'N/A'}</Typography>
                        </Typography>
                    </Box>
                     <Stack direction="column" alignItems={'flex-end'} sx={{ minWidth: '120px' }}>
                         {user && <Typography variant="caption" color="text.secondary">User: {user.username}</Typography>}
                         <Typography variant="caption" color="text.secondary">{formatTimestamp(timestamp)}</Typography>
                         <Typography variant="caption" color="text.secondary" sx={{fontSize: '0.65rem'}}>(ID: {id})</Typography>
                    </Stack>
                </Stack>
            </Paper>

            {/* Device Info Accordion (if available) */}
            {hasDeviceInfo && (
                 <Accordion elevation={1} sx={{mb: 1}} TransitionProps={{ unmountOnExit: true }}>
                     <AccordionSummary
                        expandIcon={<ExpandMoreIcon />}
                        aria-controls={`panel-deviceinfo-${id}-content`}
                        id={`panel-deviceinfo-${id}-header`}
                        sx={{minHeight: '36px', '&.Mui-expanded': { minHeight: '36px' }}}
                     >
                         <DeviceUnknownIcon sx={{mr: 1, color: 'action.active', fontSize: '1.1rem'}}/>
                         <Typography variant="caption">Additional Device Info</Typography>
                     </AccordionSummary>
                     <AccordionDetails sx={{bgcolor: 'action.hover', p: 1}}>
                         <pre style={{fontSize: '0.75rem', margin: 0, padding: '5px', borderRadius: '4px', overflowX: 'auto', whiteSpace: 'pre-wrap', wordBreak: 'break-all'}}>
                             {JSON.stringify(deviceInfo, null, 2)}
                         </pre>
                     </AccordionDetails>
                 </Accordion>
            )}

            {/* Route Trace Accordion */}
            <Accordion defaultExpanded elevation={1} TransitionProps={{ unmountOnExit: true }}>
                 <AccordionSummary
                    expandIcon={<ExpandMoreIcon />}
                    aria-controls={`panel-routedata-${id}-content`}
                    id={`panel-routedata-${id}-header`}
                     sx={{minHeight: '48px', '&.Mui-expanded': { minHeight: '48px' }}}
                 >
                     <AccountTreeIcon sx={{mr: 1, color: 'action.active'}} />
                     <Typography variant="subtitle2">Detailed Hops ({routeData?.length ?? 0})</Typography>
                 </AccordionSummary>
                 <AccordionDetails sx={{ p: 1 }}>
                    {hasValidRouteData ? (
                        <Stack
                            direction="row"
                            spacing={0}
                            alignItems="center"
                            sx={{
                                overflowX: 'auto',
                                minWidth: 0,
                                maxWidth: '100%', // Adjust based on container
                                py: 1,
                                px: 1,
                                border: '1px dashed',
                                borderColor: 'divider',
                                borderRadius: 1,
                                minHeight: '90px',
                            }}
                        >
                            {routeData.map((hop, index) => (
                                <HopDisplay
                                    key={`${hop.device_id || hop.ip}-${hop.hop}-${index}`}
                                    hopData={hop}
                                    isFirst={index === 0}
                                    isLast={index === routeData.length - 1}
                                />
                            ))}
                        </Stack>
                    ) : (
                        <Typography color="text.secondary" sx={{ p: 2, textAlign: 'center', fontStyle: 'italic' }}>
                            No detailed route hops available in this history entry.
                        </Typography>
                    )}
                </AccordionDetails>
            </Accordion>


        </Box>
    );
};

export default HistoryRouteVisualizer;
// ----- End File: src/components/Comparison/HistoryRouteVisualizer.jsx -----

// ----- End File: src\components\Comparison\HistoryRouteVisualizer.jsx -----

// ----- File: src\components\History\HistoryItem.jsx -----

// src/components/History/HistoryItem.jsx
import React, { useState } from 'react';
import {
    ListItem,
    ListItemText,
    Collapse,
    IconButton,
    Typography,
    Box,
    Paper,
    Stack,
    Chip,
    Accordion,
    AccordionSummary,
    AccordionDetails,
    Divider
} from '@mui/material';
import ExpandLess from '@mui/icons-material/ExpandLess';
import ExpandMore from '@mui/icons-material/ExpandMore';
import DeviceUnknownIcon from '@mui/icons-material/DeviceUnknown';
import AccountTreeIcon from '@mui/icons-material/AccountTree';
import HopDisplay from '../RouteTrace/HopDisplay';
import { formatTimestamp } from '../../utils/formatters';


const HistoryItem = ({ route }) => {
  const [open, setOpen] = useState(false);
  const { id, source, destination, timestamp, routeData, deviceInfo, user } = route;

  const handleClick = () => {
    setOpen(!open);
  };

  const hasValidRouteData = Array.isArray(routeData) && routeData.length > 0;

  return (
    <>
      {/* Main List Item Header */}
      <ListItem button onClick={handleClick} divider>
        <ListItemText
          primary={
              <Stack direction={{ xs: 'column', sm: 'row' }} justifyContent="space-between" alignItems={{ xs: 'flex-start', sm: 'center' }} spacing={1}>
                  <Typography variant="body1" sx={{ display: 'flex', alignItems: 'center', flexWrap: 'wrap', gap: 0.5 }}>
                      <Chip label="Src" size="small" color="primary" sx={{ mr: 0.5}} />
                      <Typography component="span" sx={{wordBreak: 'break-all'}}>{source || 'N/A'}</Typography>
                      <Typography component="span" sx={{ mx: 1 }}>→</Typography>
                      <Chip label="Dst" size="small" color="secondary" sx={{ mr: 0.5}} />
                      <Typography component="span" sx={{wordBreak: 'break-all'}}>{destination || 'N/A'}</Typography>
                  </Typography>
                  <Stack direction="column" alignItems={{ xs: 'flex-start', sm: 'flex-end' }} sx={{ minWidth: '150px' }}>
                     {user && <Typography variant="caption" color="text.secondary">User: {user.username}</Typography>}
                     <Typography variant="caption" color="text.secondary">{formatTimestamp(timestamp)}</Typography>
                     <Typography variant="caption" color="text.secondary" sx={{fontSize: '0.65rem'}}>(ID: {id})</Typography>
                  </Stack>
             </Stack>
            }
        />
        {hasValidRouteData ? (open ? <ExpandLess /> : <ExpandMore />) : null }
      </ListItem>

      {/* Collapsible Details Section */}
      <Collapse in={open} timeout="auto" unmountOnExit>
        <Paper sx={{ p: 0, m: 1, bgcolor: 'background.default' }} elevation={0}>

            {/* Device Info Accordion (if available) */}
            {deviceInfo && typeof deviceInfo === 'object' && Object.keys(deviceInfo).length > 0 && (
                 <Accordion elevation={1} sx={{mb: 1}}>
                     <AccordionSummary
                        expandIcon={<ExpandMore />}
                        aria-controls={`panel-deviceinfo-${id}-content`}
                        id={`panel-deviceinfo-${id}-header`}
                     >
                         <DeviceUnknownIcon sx={{mr: 1, color: 'action.active'}}/>
                         <Typography variant="subtitle2">Additional Device Info</Typography>
                     </AccordionSummary>
                     <AccordionDetails sx={{bgcolor: 'grey.100', p: 1}}>
                         <pre style={{fontSize: '0.8rem', margin: 0, padding: '5px', borderRadius: '4px', overflowX: 'auto', whiteSpace: 'pre-wrap', wordBreak: 'break-all'}}>
                             {JSON.stringify(deviceInfo, null, 2)}
                         </pre>
                     </AccordionDetails>
                 </Accordion>
            )}

            {/* Route Trace Accordion */}
            {hasValidRouteData && (
                <Accordion defaultExpanded elevation={1}>
                     <AccordionSummary
                        expandIcon={<ExpandMore />}
                        aria-controls={`panel-routedata-${id}-content`}
                        id={`panel-routedata-${id}-header`}
                     >
                         <AccountTreeIcon sx={{mr: 1, color: 'action.active'}} />
                         <Typography variant="subtitle2">Detailed Route Hops ({routeData.length})</Typography>
                     </AccordionSummary>
                     <AccordionDetails sx={{ p: 1 }}>
                         <Stack
                             direction="row"
                             spacing={0}
                             alignItems="center"
                             sx={{
                                 overflowX: 'auto',
                                 minWidth: 0,         // <<<--- ADDED THIS LINE
                                 maxWidth: '70vw',    // <<<--- ADDED THIS LINE
                                 py: 1,
                                 px: 1,
                                 border: '1px dashed',
                                 borderColor: 'divider',
                                 borderRadius: 1,
                                 minHeight: '90px',
                                 // Optional: Center the stack if content is narrower than maxWidth
                                 // marginX: 'auto',
                             }}
                         >
                             {routeData.map((hop, index) => (
                                 <HopDisplay
                                     key={`${hop.device_id || hop.ip}-${hop.hop}-${index}`}
                                     hopData={hop}
                                     isFirst={index === 0}
                                     isLast={index === routeData.length - 1}
                                 />
                             ))}
                         </Stack>
                    </AccordionDetails>
                </Accordion>
            )}

            {/* Message if no valid route data */}
            {!hasValidRouteData && (
                 <Typography color="text.secondary" sx={{ p: 2, textAlign: 'center' }}>
                    No detailed route hops available for this history entry.
                 </Typography>
            )}

             {typeof route.route === 'string' && (!Array.isArray(routeData) || routeData.length === 0) && (
                  <Accordion elevation={1} sx={{mt: 1}}>
                    <AccordionSummary expandIcon={<ExpandMore />} aria-controls={`panel-raw-${id}-content`} id={`panel-raw-${id}-header`}>
                        <Typography variant="caption">Raw Route Data (Parsing Failed or Empty)</Typography>
                    </AccordionSummary>
                    <AccordionDetails sx={{bgcolor: 'grey.100', p: 1}}>
                        <pre style={{fontSize: '0.8rem', margin: 0, padding: '5px', borderRadius: '4px', overflowX: 'auto', whiteSpace: 'pre-wrap', wordBreak: 'break-all'}}>
                            {route.route}
                        </pre>
                    </AccordionDetails>
                  </Accordion>
             )}
        </Paper>
      </Collapse>
    </>
  );
};


export default HistoryItem;

// ----- End File: src/components/History/HistoryItem.jsx -----

// ----- End File: src\components\History\HistoryItem.jsx -----

// ----- File: src\components\History\HistoryList.jsx -----

import React from 'react';
import { List, Typography, Paper } from '@mui/material';
import HistoryItem from './HistoryItem';

const HistoryList = ({ routes, title = "Route History" }) => {
  if (!routes || routes.length === 0) {
    return <Typography sx={{ mt: 3, textAlign: 'center' }} color="text.secondary">No history found.</Typography>;
  }

  return (
    <Paper elevation={1} sx={{ mt: 2 }}>
        <Typography variant="h5" component="h2" sx={{ p: 2 }}>{title}</Typography>
        <List component="nav" aria-label="route history">
        {routes.map((route) => (
            <HistoryItem key={route.id} route={route} />
        ))}
        </List>
    </Paper>
  );
};

export default HistoryList;

// ----- End File: src\components\History\HistoryList.jsx -----

// ----- File: src\components\RouteTrace\DirectRouteTraceInputForm.jsx -----

// ----- File: src/components/RouteTrace/DirectRouteTraceInputForm.jsx -----

import React from 'react';
import { useDispatch } from 'react-redux';
import { TextField, Button, Box, Grid, CircularProgress, Tooltip, IconButton } from '@mui/material';
import NetworkCheckIcon from '@mui/icons-material/NetworkCheck';
import SyncIcon from '@mui/icons-material/Sync';
import SyncProblemIcon from '@mui/icons-material/SyncProblem';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import EditIcon from '@mui/icons-material/Edit';
import { updateDirectTraceInput, fetchDirectDefaultGateway, performDirectRouteTrace } from '../../store/slices/directRouteSlice'; // Use directRouteSlice actions
import ErrorMessage from '../Common/ErrorMessage';

const DirectRouteTraceInputForm = ({ trace }) => {
  const dispatch = useDispatch();
  const {
    id: traceId,
    sourceIp, destinationIp, sourceDg, destinationDg, vrf, // Added VRF
    sourceDgStatus, destinationDgStatus, traceStatus, error
  } = trace;

  const handleInputChange = (field) => (event) => {
    dispatch(updateDirectTraceInput({ traceId, field, value: event.target.value }));
  };

  const handleFetchDg = (type) => () => {
    const ip = type === 'source' ? sourceIp : destinationIp;
    if (ip) {
      // Pass traceId and type
      dispatch(fetchDirectDefaultGateway({ ip, type, traceId }));
    }
  };

  const handleTrace = () => {
    dispatch(performDirectRouteTrace({ traceId, sourceIp, destinationIp, sourceDg, destinationDg, vrf }));
  };

  const isFetchingSourceDg = sourceDgStatus === 'loading';
  const isFetchingDestDg = destinationDgStatus === 'loading';
  const isTracing = traceStatus === 'loading';

  const sourceDgDisabled = isFetchingSourceDg;
  const destDgDisabled = isFetchingDestDg;

  const renderDgStatusIcon = (status) => {
    switch (status) {
      case 'loading':
        return <CircularProgress size={20} />;
      case 'succeeded':
        return <Tooltip title="Gateway Fetched"><CheckCircleIcon color="success" /></Tooltip>;
      case 'failed':
        return <Tooltip title="Failed to Fetch Gateway"><SyncProblemIcon color="error" /></Tooltip>;
      case 'manual':
         return <Tooltip title="Manually Entered"><EditIcon color="action" /></Tooltip>;
      default: // idle
        return null;
    }
  };

  const dgError = error && (sourceDgStatus === 'failed' || destinationDgStatus === 'failed');

  return (
    <Box sx={{ mb: 3 }}>
        {dgError && <ErrorMessage error={error} title="Gateway Fetch Error" />}
        <Grid container spacing={2} alignItems="flex-start">
            {/* Source IP */}
            <Grid item xs={12} sm={6} md={3}>
                <TextField
                    label="Source IP"
                    value={sourceIp}
                    onChange={handleInputChange('sourceIp')}
                    onBlur={handleFetchDg('source')}
                    variant="outlined"
                    fullWidth
                    required
                    disabled={isTracing}
                />
            </Grid>

             {/* Source DG */}
            <Grid item xs={10} sm={5} md={2}>
                 <TextField
                    label="Source DG"
                    value={sourceDg}
                    onChange={handleInputChange('sourceDg')}
                    variant="outlined"
                    fullWidth
                    required
                    disabled={sourceDgDisabled || isTracing}
                    InputProps={{ endAdornment: renderDgStatusIcon(sourceDgStatus) }}
                 />
            </Grid>
            <Grid item xs={2} sm={1} md={1} sx={{display: 'flex', alignItems: 'center', height: '56px' }}>
                 <Tooltip title="Re-fetch Source Gateway">
                     <span>
                        <IconButton onClick={handleFetchDg('source')} disabled={!sourceIp || isFetchingSourceDg || isTracing} size="small"> <SyncIcon /> </IconButton>
                     </span>
                 </Tooltip>
            </Grid>

            {/* Destination IP */}
            <Grid item xs={12} sm={6} md={3}>
                <TextField
                    label="Destination IP"
                    value={destinationIp}
                    onChange={handleInputChange('destinationIp')}
                    onBlur={handleFetchDg('destination')}
                    variant="outlined"
                    fullWidth
                    required
                    disabled={isTracing}
                 />
            </Grid>

             {/* Destination DG */}
            <Grid item xs={10} sm={5} md={2}>
                 <TextField
                    label="Destination DG"
                    value={destinationDg}
                    onChange={handleInputChange('destinationDg')}
                    variant="outlined"
                    fullWidth
                    required
                    disabled={destDgDisabled || isTracing}
                    InputProps={{ endAdornment: renderDgStatusIcon(destinationDgStatus) }}
                />
            </Grid>
             <Grid item xs={2} sm={1} md={1} sx={{display: 'flex', alignItems: 'center', height: '56px'}}>
                 <Tooltip title="Re-fetch Destination Gateway">
                     <span>
                        <IconButton onClick={handleFetchDg('destination')} disabled={!destinationIp || isFetchingDestDg || isTracing} size="small"> <SyncIcon /> </IconButton>
                     </span>
                 </Tooltip>
            </Grid>

            {/* VRF Input */}
             <Grid item xs={12} sm={6} md={3}>
                <TextField
                    label="VRF (Optional)"
                    value={vrf || ''} // Ensure controlled component
                    onChange={handleInputChange('vrf')}
                    variant="outlined"
                    fullWidth
                    disabled={isTracing}
                    helperText="Specify VRF context if applicable"
                 />
            </Grid>

        </Grid>
        <Box sx={{ display: 'flex', justifyContent: 'center', mt: 3 }}>
            <Button
                variant="contained"
                color="primary"
                size="large"
                startIcon={isTracing ? <CircularProgress size={20} color="inherit" /> : <NetworkCheckIcon />}
                onClick={handleTrace}
                disabled={!sourceIp || !destinationIp || !sourceDg || !destinationDg || isTracing || isFetchingSourceDg || isFetchingDestDg}
            >
                {isTracing ? 'Tracing...' : 'Trace Direct Route'}
            </Button>
        </Box>
    </Box>
  );
};

export default DirectRouteTraceInputForm;

// ----- End File: src/components/RouteTrace/DirectRouteTraceInputForm.jsx -----

// ----- End File: src\components\RouteTrace\DirectRouteTraceInputForm.jsx -----

// ----- File: src\components\RouteTrace\DirectRouteTraceSection.jsx -----

// ----- File: src/components/RouteTrace/DirectRouteTraceSection.jsx -----

import React from 'react';
import { Paper, Box, IconButton, Tooltip } from '@mui/material';
import CloseIcon from '@mui/icons-material/Close';
import DirectRouteTraceInputForm from './DirectRouteTraceInputForm';
import DirectRouteVisualizer from './DirectRouteVisualizer';
import { useDispatch } from 'react-redux';
import { removeDirectTraceSection } from '../../store/slices/directRouteSlice'; // Use correct slice action

const DirectRouteTraceSection = ({ trace, canRemove }) => {
  const dispatch = useDispatch();

  const handleRemove = () => {
      if (canRemove) {
          dispatch(removeDirectTraceSection(trace.id));
      }
  }

  return (
    <Paper elevation={2} sx={{ p: 2, mb: 3, position: 'relative' }}>
        {canRemove && (
            <Tooltip title="Remove this trace section">
                <IconButton
                    onClick={handleRemove}
                    size="small"
                    sx={{ position: 'absolute', top: 8, right: 8 }}
                >
                    <CloseIcon />
                </IconButton>
            </Tooltip>
        )}
        <DirectRouteTraceInputForm trace={trace} />
        <DirectRouteVisualizer trace={trace} />
    </Paper>
  );
};

export default DirectRouteTraceSection;

// ----- End File: src/components/RouteTrace/DirectRouteTraceSection.jsx -----

// ----- End File: src\components\RouteTrace\DirectRouteTraceSection.jsx -----

// ----- File: src\components\RouteTrace\DirectRouteVisualizer.jsx -----

// ----- File: src/components/RouteTrace/DirectRouteVisualizer.jsx -----

import React from 'react';
import { Box, Typography, Stack, Paper } from '@mui/material';
import LoadingSpinner from '../Common/LoadingSpinner';
import ErrorMessage from '../Common/ErrorMessage';
import HopDisplay from './HopDisplay';

const DirectRouteVisualizer = ({ trace }) => {
  const {
    sourceIp, destinationIp, sourceDg, destinationDg, vrf,
    traceResult,
    traceStatus,
    error
  } = trace;

  if (traceStatus === 'loading') {
    return <LoadingSpinner />;
  }

  const displayError = error && traceStatus === 'failed';

  return (
    <Paper elevation={0} sx={{ mt: 3, p: { xs: 1, sm: 2 }, border: '1px solid', borderColor: 'divider', borderRadius: 1 }}>
      <Typography variant="h6" gutterBottom align="center">Direct Route Trace Results</Typography>
       {vrf && <Typography variant="caption" display="block" align="center" color="text.secondary" gutterBottom>VRF Context: {vrf}</Typography>}


      {displayError && <ErrorMessage error={error} title="Direct Route Trace Error" />}

      {(traceStatus === 'succeeded' || traceStatus === 'failed') && !displayError && (
        <Box>
          {/* Simple Header: Source IP/DG -> Dest IP/DG */}
          <Box sx={{ display: 'flex', justifyContent: 'space-around', alignItems: 'center', gap: 1, mb: 2, flexWrap: 'wrap' }}>
              <Paper elevation={1} sx={{ p: 1, textAlign: 'center', flexGrow: 1 }}>
                  <Typography variant="overline" sx={{lineHeight: 1.2}}>Source</Typography>
                  <Typography variant="body2" sx={{wordBreak: 'break-all'}}>{sourceIp}</Typography>
                  <Typography variant="caption" sx={{wordBreak: 'break-all'}}>DG: {sourceDg}</Typography>
              </Paper>
              <Typography variant="h5">→</Typography>
              <Paper elevation={1} sx={{ p: 1, textAlign: 'center', flexGrow: 1 }}>
                  <Typography variant="overline" sx={{lineHeight: 1.2}}>Destination</Typography>
                  <Typography variant="body2" sx={{wordBreak: 'break-all'}}>{destinationIp}</Typography>
                  <Typography variant="caption" sx={{wordBreak: 'break-all'}}>DG: {destinationDg}</Typography>
              </Paper>
          </Box>

          {/* Display Hops */}
          {traceResult && traceResult.length > 0 ? (
            <Stack
              direction="row"
              spacing={0}
              alignItems="center"
              sx={{
                overflowX: 'auto',
                minWidth: 0,
                maxWidth: '70vw', // <<<--- ADDED THIS LINE
                py: 2,
                px: 1,
                borderTop: '1px dashed',
                borderBottom: '1px dashed',
                borderColor: 'divider',
                my: 2,
                minHeight: '100px',
                 // Optional: Center the stack if content is narrower than maxWidth
                // marginX: 'auto',
              }}
            >
              {traceResult.map((hop, index) => (
                <HopDisplay
                  key={`${hop.device_id || hop.ip}-${hop.hop}-${index}`}
                  hopData={hop}
                  isFirst={index === 0}
                  isLast={index === traceResult.length - 1}
                />
              ))}
            </Stack>
          ) : (
             traceStatus === 'succeeded' && (!traceResult || traceResult.length === 0) && (
                <Typography align="center" color="text.secondary" sx={{ my: 3 }}>
                    No route trace hops returned between the specified points.
                </Typography>
             )
          )}
        </Box>
      )}

      {/* Initial state message */}
      {traceStatus === 'idle' && !error && (
        <Typography align="center" color="text.secondary">Enter details and click 'Trace Direct Route' to see results.</Typography>
      )}
    </Paper>
  );
};

export default DirectRouteVisualizer;

// ----- End File: src/components/RouteTrace/DirectRouteVisualizer.jsx -----

// ----- End File: src\components\RouteTrace\DirectRouteVisualizer.jsx -----

// ----- File: src\components\RouteTrace\HopDisplay.jsx -----

// src/components/RouteTrace/HopDisplay.jsx
import React, { useState } from 'react';
import {
    Paper,
    Typography,
    Box,
    Chip,
    IconButton,
    Popover,
    List,
    ListItem,
    ListItemText,
    Divider,
    Tooltip
} from '@mui/material';
import ArrowForwardIcon from '@mui/icons-material/ArrowForward';
import InfoOutlinedIcon from '@mui/icons-material/InfoOutlined';

// Helper to format keys for display
const formatDetailKey = (key) => {
  return key
    .replace(/_/g, ' ') // Replace underscores with spaces
    .replace(/([A-Z])/g, ' $1') // Add space before capitals (for camelCase)
    .replace(/^./, (str) => str.toUpperCase()); // Capitalize first letter
};

const HopDisplay = ({ hopData, isFirst, isLast }) => {
  const [anchorEl, setAnchorEl] = useState(null);

  const handlePopoverOpen = (event) => {
    setAnchorEl(event.currentTarget);
  };

  const handlePopoverClose = () => {
    setAnchorEl(null);
  };

  const open = Boolean(anchorEl);
  const id = open ? `hop-popover-${hopData.hop}-${hopData.ip}` : undefined;

  // --- Extract Data ---
  // Destructure all potential fields from the DetailedHop model
  const {
    hop,
    ip,
    type,
    hostname,
    destination_network,
    vrf,
    destination_dg_ip,
    mpls_label,
    passed_firewall,
    device_id, // Note: comes from 'id_' alias in backend model
    destination_mac,
    next_hop_interface,
    nexthop_int_ip,
    ...otherDetails // Collect any unexpected extra fields
  } = hopData;

  // --- Prepare Details for Popover ---
  // Filter out null/undefined and primary display fields
  const detailsToShow = Object.entries({
    hostname, // Show hostname again in details if it exists
    destination_network,
    vrf,
    destination_dg_ip,
    mpls_label,
    passed_firewall,
    device_id,
    destination_mac,
    next_hop_interface,
    nexthop_int_ip,
    ...otherDetails
  }).filter(([key, value]) => value !== null && value !== undefined && value !== '');

  // Determine primary display text (Hostname if available, otherwise IP/MAC)
  const primaryDisplay = hostname || ip || 'N/A';
  const secondaryDisplay = hostname && ip ? ip : (type || 'Unknown Type'); // Show IP/MAC if hostname is primary, else show Type

  return (
    <Box sx={{ display: 'flex', alignItems: 'center', position: 'relative' }}>
      {!isFirst && <ArrowForwardIcon sx={{ mx: 0.5, color: 'text.secondary', fontSize: '1.2rem' }} />}
      <Paper
        elevation={2}
        sx={{
          p: 1, // Reduced padding slightly
          minWidth: 160, // Slightly wider min-width
          textAlign: 'center',
          position: 'relative', // Needed for absolute positioning of button
          mr: 0.5, // Margin between paper and next arrow
        }}
      >
        {/* Hop Number Chip */}
        <Chip label={`Hop ${hop}`} size="small" variant="outlined" sx={{ mb: 0.5 }} />

        {/* Primary Display (Hostname or IP/MAC) */}
        <Typography
          variant="body1"
          sx={{
            fontWeight: 'bold',
            wordBreak: 'break-all', // Break long hostnames/IPs
            lineHeight: 1.2,
            mb: 0.2,
          }}
        >
          {primaryDisplay}
        </Typography>

        {/* Secondary Display (IP/MAC or Type) */}
        <Typography
          variant="caption" // Smaller font for secondary info
          sx={{
            color: 'text.secondary',
            display: 'block',
            wordBreak: 'break-all',
            lineHeight: 1.1,
          }}
        >
          {secondaryDisplay}
        </Typography>

         {/* Chip for Type if not already shown */}
         {type && secondaryDisplay !== type && (
             <Chip label={type} size="small" sx={{ mt: 0.5, fontSize: '0.65rem', height: '18px' }} />
         )}


        {/* Details Button */}
        {detailsToShow.length > 0 && (
          <Tooltip title="Show Details">
            <IconButton
              aria-label="show details"
              size="small"
              onClick={handlePopoverOpen}
              aria-describedby={id}
              sx={{
                position: 'absolute',
                top: 0,
                right: 0,
                p: '2px', // Small padding
              }}
            >
              <InfoOutlinedIcon fontSize="inherit" sx={{ fontSize: '1rem' }} />
            </IconButton>
          </Tooltip>
        )}
      </Paper>

      {/* Popover for Details */}
      <Popover
        id={id}
        open={open}
        anchorEl={anchorEl}
        onClose={handlePopoverClose}
        anchorOrigin={{
          vertical: 'bottom',
          horizontal: 'center',
        }}
        transformOrigin={{
          vertical: 'top',
          horizontal: 'center',
        }}
        slotProps={{ // Use slotProps for Paper styling
             paper: {
                sx: { maxWidth: 350, p: 0 } // Padding handled by ListItems
             }
        }}
      >
        <Box sx={{ p: 1 }}>
            <Typography variant="subtitle2" sx={{ px: 2, pt: 1, pb: 0.5 }}>Hop {hop} Details</Typography>
            <Divider />
            <List dense disablePadding>
            {detailsToShow.map(([key, value]) => (
                <ListItem key={key} dense divider sx={{py: 0.5}}>
                    <ListItemText
                        primary={formatDetailKey(key)}
                        secondary={
                            // Handle boolean display
                            typeof value === 'boolean' ? (value ? 'Yes' : 'No') :
                            // Handle potentially long strings
                            (typeof value === 'string' && value.length > 50 ? `${value.substring(0, 50)}...` : value)
                        }
                        primaryTypographyProps={{ variant: 'caption', fontWeight: 'medium' }}
                        secondaryTypographyProps={{ variant: 'caption', color: 'text.primary', sx: { whiteSpace: 'pre-wrap', wordBreak: 'break-all' } }}
                        sx={{ my: 0 }}
                     />
                </ListItem>
            ))}
             {detailsToShow.length === 0 && (
                 <ListItem dense>
                     <ListItemText secondary="No additional details available." secondaryTypographyProps={{ variant: 'caption' }} />
                 </ListItem>
             )}
            </List>
        </Box>
      </Popover>
    </Box>
  );
};

export default HopDisplay;

// ----- End File: src\components\RouteTrace\HopDisplay.jsx -----

// ----- File: src\components\RouteTrace\MacTraceDisplay.jsx -----

// src/components/RouteTrace/MacTraceDisplay.jsx
// No changes needed - it passes the detailed hops to HopDisplay

import React from 'react';
import { Paper, Typography, Box, Stack } from '@mui/material';
import CompareArrowsIcon from '@mui/icons-material/CompareArrows';
import LoadingSpinner from '../Common/LoadingSpinner';
import ErrorMessage from '../Common/ErrorMessage';
import HopDisplay from './HopDisplay'; // HopDisplay now handles details

const MacTraceDisplay = ({ label, hops, isLoading, error }) => {
  // hops is now an array of DetailedHop objects

  return (
    <Paper elevation={0} sx={{ p: 1, my: 1, bgcolor: 'action.hover' }}> {/* Slightly different bg */}
      <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 1, mb: 1 }}>
        <CompareArrowsIcon fontSize="small" color="action" />
        <Typography variant="overline">{label}</Typography>
      </Box>

      {isLoading && <LoadingSpinner size={25} />}
      {error && <ErrorMessage error={error} title="MAC Trace Error" />}

      {!isLoading && !error && (
        <>
          {hops === null || hops === undefined ? (
            <Typography variant="caption" display="block" align="center">MAC Trace Pending</Typography>
          ) : hops.length === 0 ? (
            <Typography variant="caption" display="block" align="center">No MAC trace hops found.</Typography>
          ) : (
            <Stack
              direction="row"
              spacing={0} // Spacing handled by arrows in HopDisplay
              alignItems="center" // Center items vertically
              sx={{
                overflowX: 'auto', // Enable horizontal scrolling
                minWidth: 0, // <<<--- ADD THIS LINE TO PREVENT STACK FROM OVER-EXPANDING
                py: 1,
                px: 1,
                minHeight: '70px', // Ensure minimum height even with few hops
              }}
            >
              {hops.map((hop, index) => (
                <HopDisplay
                  // Use a more robust key if available (e.g., device_id + hop)
                  key={`${hop.device_id || hop.ip}-${hop.hop}-${index}`}
                  hopData={hop} // Pass the full detailed hop object
                  isFirst={index === 0}
                  isLast={index === hops.length - 1}
                />
              ))}
            </Stack>
          )}
        </>
      )}
    </Paper>
  );
};

export default MacTraceDisplay;

// ----- End File: src/components/RouteTrace/MacTraceDisplay.jsx -----

// ----- End File: src\components\RouteTrace\MacTraceDisplay.jsx -----

// ----- File: src\components\RouteTrace\MacTraceInputForm.jsx -----

// ----- File: src/components/RouteTrace/MacTraceInputForm.jsx -----

import React from 'react';
import { useDispatch } from 'react-redux';
import { TextField, Button, Box, Grid, CircularProgress, Tooltip, IconButton } from '@mui/material';
import SettingsEthernetIcon from '@mui/icons-material/SettingsEthernet';
import SyncIcon from '@mui/icons-material/Sync';
import SyncProblemIcon from '@mui/icons-material/SyncProblem';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import EditIcon from '@mui/icons-material/Edit';
import { updateMacTraceInput, fetchMacDefaultGateway, performMacTrace } from '../../store/slices/macTraceSlice'; // Use macTraceSlice actions
import ErrorMessage from '../Common/ErrorMessage';

const MacTraceInputForm = ({ trace }) => {
  const dispatch = useDispatch();
  const {
    id: traceId,
    ip, // MAC trace needs IP and DG
    dg,
    dgStatus, // Only one DG status needed
    traceStatus,
    error
  } = trace;

  const handleInputChange = (field) => (event) => {
    dispatch(updateMacTraceInput({ traceId, field, value: event.target.value }));
  };

  const handleFetchDg = () => {
    if (ip) {
      // Pass traceId for linking state updates
      dispatch(fetchMacDefaultGateway({ ip, traceId }));
    }
  };

  const handleTrace = () => {
    dispatch(performMacTrace({ traceId, ip, dg }));
  };

  const isFetchingDg = dgStatus === 'loading';
  const isTracing = traceStatus === 'loading';
  const dgDisabled = isFetchingDg;

  const renderDgStatusIcon = (status) => {
    switch (status) {
      case 'loading':
        return <CircularProgress size={20} />;
      case 'succeeded':
        return <Tooltip title="Gateway Fetched"><CheckCircleIcon color="success" /></Tooltip>;
      case 'failed':
        return <Tooltip title="Failed to Fetch Gateway"><SyncProblemIcon color="error" /></Tooltip>;
      case 'manual':
         return <Tooltip title="Manually Entered"><EditIcon color="action" /></Tooltip>;
      default: // idle
        return null;
    }
  };

  const dgError = error && dgStatus === 'failed';

  return (
    <Box sx={{ mb: 3 }}>
        {dgError && <ErrorMessage error={error} title="Gateway Fetch Error" />}
        <Grid container spacing={2} alignItems="flex-start">
            {/* Endpoint IP */}
            <Grid item xs={12} sm={6}>
                <TextField
                    label="Endpoint IP"
                    value={ip}
                    onChange={handleInputChange('ip')}
                    onBlur={handleFetchDg} // Trigger fetch on blur
                    variant="outlined"
                    fullWidth
                    required
                    disabled={isTracing}
                />
            </Grid>

             {/* Default Gateway (DG) */}
            <Grid item xs={10} sm={5}>
                 <TextField
                    label="Endpoint Default Gateway"
                    value={dg}
                    onChange={handleInputChange('dg')}
                    variant="outlined"
                    fullWidth
                    required
                    disabled={dgDisabled || isTracing}
                    InputProps={{
                        endAdornment: renderDgStatusIcon(dgStatus),
                    }}
                 />
            </Grid>
            <Grid item xs={2} sm={1} sx={{display: 'flex', alignItems: 'center', height: '56px' }}>
                 <Tooltip title="Re-fetch Gateway">
                     <span>
                        <IconButton onClick={handleFetchDg} disabled={!ip || isFetchingDg || isTracing} size="small">
                            <SyncIcon />
                        </IconButton>
                     </span>
                 </Tooltip>
            </Grid>
        </Grid>
        <Box sx={{ display: 'flex', justifyContent: 'center', mt: 3 }}>
            <Button
                variant="contained"
                color="primary"
                size="large"
                startIcon={isTracing ? <CircularProgress size={20} color="inherit" /> : <SettingsEthernetIcon />}
                onClick={handleTrace}
                disabled={!ip || !dg || isTracing || isFetchingDg}
            >
                {isTracing ? 'Tracing...' : 'Trace MAC Path'}
            </Button>
        </Box>
    </Box>
  );
};

export default MacTraceInputForm;

// ----- End File: src/components/RouteTrace/MacTraceInputForm.jsx -----

// ----- End File: src\components\RouteTrace\MacTraceInputForm.jsx -----

// ----- File: src\components\RouteTrace\MacTraceSection.jsx -----

// ----- File: src/components/RouteTrace/MacTraceSection.jsx -----

import React from 'react';
import { Paper, Box, IconButton, Tooltip } from '@mui/material';
import CloseIcon from '@mui/icons-material/Close';
import MacTraceInputForm from './MacTraceInputForm';
import MacTraceVisualizer from './MacTraceVisualizer';
import { useDispatch } from 'react-redux';
import { removeMacTraceSection } from '../../store/slices/macTraceSlice'; // Use correct slice action

const MacTraceSection = ({ trace, canRemove }) => {
  const dispatch = useDispatch();

  const handleRemove = () => {
      if (canRemove) {
          dispatch(removeMacTraceSection(trace.id));
      }
  }

  return (
    <Paper elevation={2} sx={{ p: 2, mb: 3, position: 'relative' }}>
        {canRemove && (
            <Tooltip title="Remove this trace section">
                <IconButton
                    onClick={handleRemove}
                    size="small"
                    sx={{ position: 'absolute', top: 8, right: 8 }}
                >
                    <CloseIcon />
                </IconButton>
            </Tooltip>
        )}
        <MacTraceInputForm trace={trace} />
        <MacTraceVisualizer trace={trace} />
    </Paper>
  );
};

export default MacTraceSection;

// ----- End File: src/components/RouteTrace/MacTraceSection.jsx -----

// ----- End File: src\components\RouteTrace\MacTraceSection.jsx -----

// ----- File: src\components\RouteTrace\MacTraceVisualizer.jsx -----

// ----- File: src/components/RouteTrace/MacTraceVisualizer.jsx -----

import React from 'react';
import { Box, Typography, Stack, Paper } from '@mui/material';
import LoadingSpinner from '../Common/LoadingSpinner';
import ErrorMessage from '../Common/ErrorMessage';
import HopDisplay from './HopDisplay'; // Reuse HopDisplay

const MacTraceVisualizer = ({ trace }) => {
  const {
    ip, // Source IP
    dg, // Destination Gateway
    traceResult, // Renamed from macTrace in slice to avoid confusion
    traceStatus,
    error
  } = trace;

  if (traceStatus === 'loading') {
    return <LoadingSpinner />;
  }

  const displayError = error && traceStatus === 'failed';

  return (
    <Paper elevation={0} sx={{ mt: 3, p: { xs: 1, sm: 2 }, border: '1px solid', borderColor: 'divider', borderRadius: 1 }}>
      <Typography variant="h6" gutterBottom align="center">MAC Trace Results</Typography>

      {displayError && <ErrorMessage error={error} title="MAC Trace Error" />}

      {/* Display results only if trace has run */}
      {(traceStatus === 'succeeded' || traceStatus === 'failed') && !displayError && (
        <Box>
            {/* Simplified Display: IP <-> DG */}
            <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', gap: 2, mb: 2, flexWrap: 'wrap' }}>
                 <Paper elevation={1} sx={{ p: 1, textAlign: 'center', bgcolor: 'primary.light', color: 'primary.contrastText', minWidth: '120px' }}>
                    <Typography variant="overline" sx={{lineHeight: 1.2}}>Endpoint</Typography>
                    <Typography variant="body1" sx={{wordBreak: 'break-all'}}>{ip || 'N/A'}</Typography>
                </Paper>
                <Typography variant="h5">↔</Typography>
                 <Paper elevation={1} sx={{ p: 1, textAlign: 'center', minWidth: '120px' }}>
                    <Typography variant="overline" sx={{lineHeight: 1.2}}>Gateway</Typography>
                    <Typography variant="body1" sx={{wordBreak: 'break-all'}}>{dg || 'N/A'}</Typography>
                 </Paper>
            </Box>

          {/* Display Hops */}
          {traceResult && traceResult.length > 0 ? (
            <Stack
              direction="row"
              spacing={0} // Handled by HopDisplay
              alignItems="center"
              sx={{
                overflowX: 'auto', // Enable horizontal scrolling
                minWidth: 0, // <<<--- ADD THIS LINE
                maxWidth: '70vw',
                py: 2,
                px: 1,
                borderTop: '1px dashed',
                borderBottom: '1px dashed',
                borderColor: 'divider',
                my: 2,
                minHeight: '100px',
              }}
            >
              {traceResult.map((hop, index) => (
                <HopDisplay
                  key={`${hop.device_id || hop.ip}-${hop.hop}-${index}`}
                  hopData={hop}
                  isFirst={index === 0}
                  isLast={index === traceResult.length - 1}
                />
              ))}
            </Stack>
          ) : (
             traceStatus === 'succeeded' && (!traceResult || traceResult.length === 0) && (
                <Typography align="center" color="text.secondary" sx={{ my: 3 }}>
                    No MAC trace hops returned.
                </Typography>
             )
          )}
        </Box>
      )}

      {/* Initial state message */}
      {traceStatus === 'idle' && !error && (
        <Typography align="center" color="text.secondary">Enter details and click 'Trace MAC Path' to see results.</Typography>
      )}
    </Paper>
  );
};

export default MacTraceVisualizer;

// ----- End File: src/components/RouteTrace/MacTraceVisualizer.jsx -----

// ----- End File: src\components\RouteTrace\MacTraceVisualizer.jsx -----

// ----- File: src\components\RouteTrace\RouteComparisonContainer.jsx -----

// ----- File: src/components/RouteTrace/RouteComparisonContainer.jsx -----

import React from 'react';
import { Box, Grid } from '@mui/material';

// Now accepts traces and the specific Section Component to render as props
const RouteComparisonContainer = ({ traces = [], SectionComponent }) => {
  const canRemove = traces.length > 1;

  // Determine grid sizing based on number of traces
  let mdSize = 12;
  if (traces.length === 2) mdSize = 6;
  if (traces.length >= 3) mdSize = 4; // Max 3 side-by-side on medium screens

  if (!SectionComponent) {
    console.error("RouteComparisonContainer requires a SectionComponent prop.");
    return <Box sx={{ color: 'error.main' }}>Error: SectionComponent not provided.</Box>;
  }

  return (
    <Box>
      <Grid container spacing={3}>
        {traces.map((trace) => (
          <Grid item xs={12} md={mdSize} key={trace.id}>
             {/* Render the passed-in SectionComponent */}
             <SectionComponent trace={trace} canRemove={canRemove} />
          </Grid>
        ))}
      </Grid>
    </Box>
  );
};

export default RouteComparisonContainer;

// ----- End File: src/components/RouteTrace/RouteComparisonContainer.jsx -----

// ----- End File: src\components\RouteTrace\RouteComparisonContainer.jsx -----

// ----- File: src\components\RouteTrace\RouteInputForm.jsx -----

import React from 'react';
import { useDispatch } from 'react-redux';
import { TextField, Button, Box, Grid, CircularProgress, Tooltip, IconButton } from '@mui/material'; // Remove Typography from here later
import TravelExploreIcon from '@mui/icons-material/TravelExplore';
import SyncIcon from '@mui/icons-material/Sync';
import SyncProblemIcon from '@mui/icons-material/SyncProblem';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import EditIcon from '@mui/icons-material/Edit';
import { updateTraceInput, fetchDefaultGateway, performFullTrace } from '../../store/slices/routeTraceSlice';
import ErrorMessage from '../Common/ErrorMessage'; // <<<--- ADD THIS LINE

const RouteInputForm = ({ trace }) => {
  const dispatch = useDispatch();
  const {
    id: traceId,
    sourceIp, destinationIp, sourceDg, destinationDg,
    sourceDgStatus, destinationDgStatus, traceStatus, error
  } = trace;

  const handleInputChange = (field) => (event) => {
    dispatch(updateTraceInput({ traceId, field, value: event.target.value }));
  };

  const handleFetchDg = (type) => () => {
    const ip = type === 'source' ? sourceIp : destinationIp;
    if (ip) {
      dispatch(fetchDefaultGateway({ ip, type, traceId }));
    }
  };

  const handleTrace = () => {
    dispatch(performFullTrace({ traceId, sourceIp, destinationIp, sourceDg, destinationDg }));
  };

  const isFetchingSourceDg = sourceDgStatus === 'loading';
  const isFetchingDestDg = destinationDgStatus === 'loading';
  const isTracing = traceStatus === 'loading';

  // Determine if DG field should be disabled
  // Disable if loading, allow edit if succeeded, failed, or manual
  const sourceDgDisabled = isFetchingSourceDg;
  const destDgDisabled = isFetchingDestDg;

  const renderDgStatusIcon = (status) => {
    switch (status) {
      case 'loading':
        return <CircularProgress size={20} />;
      case 'succeeded':
        return <Tooltip title="Gateway Fetched"><CheckCircleIcon color="success" /></Tooltip>;
      case 'failed':
        return <Tooltip title="Failed to Fetch Gateway"><SyncProblemIcon color="error" /></Tooltip>;
      case 'manual':
         return <Tooltip title="Manually Entered"><EditIcon color="action" /></Tooltip>;
      default: // idle
        return null;
    }
  };

   // Show DG fetch error specifically
   const dgError = error && (sourceDgStatus === 'failed' || destinationDgStatus === 'failed');

  return (
    <Box sx={{ mb: 3 }}>
        {dgError && <ErrorMessage error={error} title="Gateway Fetch Error" />}
        <Grid container spacing={2} alignItems="flex-start"> {/* Use alignItems="flex-start" */}
            {/* Source IP */}
            <Grid item xs={12} sm={6} md={3}>
                <TextField
                    label="Source IP"
                    value={sourceIp}
                    onChange={handleInputChange('sourceIp')}
                    onBlur={handleFetchDg('source')} // Trigger fetch on blur
                    variant="outlined"
                    fullWidth
                    required
                    disabled={isTracing}
                />
            </Grid>

             {/* Source DG */}
            <Grid item xs={10} sm={5} md={2}>
                 <TextField
                    label="Source DG"
                    value={sourceDg}
                    onChange={handleInputChange('sourceDg')}
                    variant="outlined"
                    fullWidth
                    required
                    disabled={sourceDgDisabled || isTracing}
                    InputProps={{
                        endAdornment: renderDgStatusIcon(sourceDgStatus),
                    }}
                 />
            </Grid>
            <Grid item xs={2} sm={1} md={1} sx={{display: 'flex', alignItems: 'center', height: '56px' }}> {/* Match TextField height */}
                 <Tooltip title="Re-fetch Source Gateway">
                     <span> {/* Span needed for tooltip on disabled button */}
                        <IconButton onClick={handleFetchDg('source')} disabled={!sourceIp || isFetchingSourceDg || isTracing} size="small">
                            <SyncIcon />
                        </IconButton>
                     </span>
                 </Tooltip>
            </Grid>


            {/* Destination IP */}
            <Grid item xs={12} sm={6} md={3}>
                <TextField
                    label="Destination IP"
                    value={destinationIp}
                    onChange={handleInputChange('destinationIp')}
                    onBlur={handleFetchDg('destination')} // Trigger fetch on blur
                    variant="outlined"
                    fullWidth
                    required
                    disabled={isTracing}
                 />
            </Grid>

             {/* Destination DG */}
            <Grid item xs={10} sm={5} md={2}>
                 <TextField
                    label="Destination DG"
                    value={destinationDg}
                    onChange={handleInputChange('destinationDg')}
                    variant="outlined"
                    fullWidth
                    required
                    disabled={destDgDisabled || isTracing}
                    InputProps={{
                         endAdornment: renderDgStatusIcon(destinationDgStatus),
                    }}
                />
            </Grid>
             <Grid item xs={2} sm={1} md={1} sx={{display: 'flex', alignItems: 'center', height: '56px'}}>
                 <Tooltip title="Re-fetch Destination Gateway">
                     <span>
                        <IconButton onClick={handleFetchDg('destination')} disabled={!destinationIp || isFetchingDestDg || isTracing} size="small">
                            <SyncIcon />
                        </IconButton>
                     </span>
                 </Tooltip>
            </Grid>


        </Grid>
        <Box sx={{ display: 'flex', justifyContent: 'center', mt: 3 }}>
            <Button
                variant="contained"
                color="primary"
                size="large"
                startIcon={isTracing ? <CircularProgress size={20} color="inherit" /> : <TravelExploreIcon />}
                onClick={handleTrace}
                disabled={!sourceIp || !destinationIp || !sourceDg || !destinationDg || isTracing || isFetchingSourceDg || isFetchingDestDg}
            >
                {isTracing ? 'Tracing...' : 'Trace Route'}
            </Button>
        </Box>
    </Box>
  );
};

export default RouteInputForm;

// ----- End File: src\components\RouteTrace\RouteInputForm.jsx -----

// ----- File: src\components\RouteTrace\RouteTraceSection.jsx -----

import React from 'react';
import { Paper, Box, IconButton, Tooltip } from '@mui/material';
import CloseIcon from '@mui/icons-material/Close';
import RouteInputForm from './RouteInputForm';
import RouteVisualizer from './RouteVisualizer';
import { useDispatch } from 'react-redux';
import { removeTraceSection } from '../../store/slices/routeTraceSlice';

const RouteTraceSection = ({ trace, canRemove }) => {
  const dispatch = useDispatch();

  const handleRemove = () => {
      if (canRemove) {
          dispatch(removeTraceSection(trace.id));
      }
  }

  return (
    <Paper elevation={2} sx={{ p: 2, mb: 3, position: 'relative' }}>
        {canRemove && (
            <Tooltip title="Remove this trace section">
                <IconButton
                    onClick={handleRemove}
                    size="small"
                    sx={{ position: 'absolute', top: 8, right: 8 }}
                >
                    <CloseIcon />
                </IconButton>
            </Tooltip>
        )}
        <RouteInputForm trace={trace} />
        <RouteVisualizer trace={trace} />
    </Paper>
  );
};

export default RouteTraceSection;

// ----- End File: src\components\RouteTrace\RouteTraceSection.jsx -----

// ----- File: src\components\RouteTrace\RouteVisualizer.jsx -----

// src/components/RouteTrace/RouteVisualizer.jsx

import React from 'react';
import { Box, Typography, Stack, Paper } from '@mui/material';
import LoadingSpinner from '../Common/LoadingSpinner';
import ErrorMessage from '../Common/ErrorMessage';
import HopDisplay from './HopDisplay';
import MacTraceDisplay from './MacTraceDisplay';

const RouteVisualizer = ({ trace }) => {
  const {
    sourceIp, destinationIp, sourceDg, destinationDg,
    mainRouteTrace,
    sourceMacTrace,
    destinationMacTrace,
    traceStatus,
    error
  } = trace;

  if (traceStatus === 'loading') {
    return <LoadingSpinner />;
  }

  const displayError = error && (traceStatus === 'failed' || traceStatus === 'partial_success');

  return (
    <Paper elevation={0} sx={{ mt: 3, p: { xs: 1, sm: 2 }, border: '1px solid', borderColor: 'divider', borderRadius: 1 }}>
      <Typography variant="h6" gutterBottom align="center">Trace Results</Typography>

      {displayError && <ErrorMessage error={error} title="Trace Problem" />}

      {(traceStatus === 'succeeded' || traceStatus === 'partial_success' || traceStatus === 'failed') && (
        <Box>
          {/* 1. Source IP Box */}
           <Paper elevation={1} sx={{ p: 1, mb: 1, textAlign: 'center', bgcolor: 'primary.light', color: 'primary.contrastText' }}>
              <Typography variant="overline" sx={{lineHeight: 1.2}}>Source</Typography>
              <Typography variant="body1" sx={{wordBreak: 'break-all'}}>{sourceIp}</Typography>
          </Paper>

          {/* 2. Source MAC Trace (already updated internally) */}
          <MacTraceDisplay
            label={`${sourceIp || 'Src'} ↔ ${sourceDg || 'DG'}`}
            hops={sourceMacTrace}
            isLoading={false}
            error={traceStatus === 'partial_success' && !sourceMacTrace ? "Failed to retrieve source MAC trace" : null}
           />

           {/* 3. Source DG Box */}
           <Paper elevation={1} sx={{ p: 1, my: 1, textAlign: 'center' }}>
              <Typography variant="overline" sx={{lineHeight: 1.2}}>Source DG</Typography>
              <Typography variant="body1" sx={{wordBreak: 'break-all'}}>{sourceDg}</Typography>
           </Paper>


          {/* 4. Main Route Hops */}
          {mainRouteTrace && mainRouteTrace.length > 0 ? (
            <Stack
              direction="row"
              spacing={0}
              alignItems="center"
              sx={{
                overflowX: 'auto',
                minWidth: 0,
                maxWidth: '70vw', // <<<--- ADDED THIS LINE
                py: 2,
                px: 1,
                borderTop: '2px dashed',
                borderBottom: '2px dashed',
                borderColor: 'divider',
                my: 2,
                minHeight: '100px',
                // Optional: Center the stack if content is narrower than maxWidth
                // marginX: 'auto',
              }}
            >
              {mainRouteTrace.map((hop, index) => (
                <HopDisplay
                  key={`${hop.device_id || hop.ip}-${hop.hop}-${index}`}
                  hopData={hop}
                  isFirst={index === 0}
                  isLast={index === mainRouteTrace.length - 1}
                />
              ))}
            </Stack>
          ) : (
             traceStatus !== 'idle' && traceStatus !== 'loading' && !displayError && (
                <Typography align="center" color="text.secondary" sx={{ my: 3 }}>
                    {mainRouteTrace === null ? 'Main route trace did not run or failed.' : 'No hops returned for main route.'}
                </Typography>
             )
          )}

           {/* 5. Destination DG Box */}
           <Paper elevation={1} sx={{ p: 1, my: 1, textAlign: 'center' }}>
              <Typography variant="overline" sx={{lineHeight: 1.2}}>Destination DG</Typography>
              <Typography variant="body1" sx={{wordBreak: 'break-all'}}>{destinationDg}</Typography>
           </Paper>

          {/* 6. Destination MAC Trace (already updated internally) */}
          <MacTraceDisplay
            label={`${destinationDg || 'DG'} ↔ ${destinationIp || 'Dst'}`}
            hops={destinationMacTrace}
            isLoading={false}
            error={traceStatus === 'partial_success' && !destinationMacTrace ? "Failed to retrieve destination MAC trace" : null}
           />

            {/* 7. Destination IP Box */}
           <Paper elevation={1} sx={{ p: 1, mt: 1, textAlign: 'center', bgcolor: 'secondary.light', color: 'secondary.contrastText' }}>
              <Typography variant="overline" sx={{lineHeight: 1.2}}>Destination</Typography>
              <Typography variant="body1" sx={{wordBreak: 'break-all'}}>{destinationIp}</Typography>
           </Paper>

        </Box>
      )}

      {/* Initial state message */}
      {traceStatus === 'idle' && !error && (
        <Typography align="center" color="text.secondary">Enter details and click 'Trace Route' to see results.</Typography>
      )}
    </Paper>
  );
};

export default RouteVisualizer;

// ----- End File: src/components/RouteTrace/RouteVisualizer.jsx -----

// ----- End File: src\components\RouteTrace\RouteVisualizer.jsx -----

// ----- File: src\hooks\useAuth.js -----

import { useSelector } from 'react-redux';

export const useAuth = () => {
  const { user, isAuthenticated, loading, error } = useSelector((state) => state.auth);
  return { user, isAuthenticated, loading, error };
};

// ----- End File: src\hooks\useAuth.js -----

// ----- File: src\index.css -----

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}


// ----- End File: src\index.css -----

// ----- File: src\index.js -----

// ----- File: src/index.js -----

import React from 'react';
import ReactDOM from 'react-dom/client';
import { Provider } from 'react-redux';
import { BrowserRouter } from 'react-router-dom';
// Remove ThemeProvider, createTheme, CssBaseline from here
import App from './App';
import store from './store/store';
import './index.css'; // Keep if you have other global non-MUI styles, otherwise remove

// Old basic theme is removed. Theme is now handled within App.js
// const theme = createTheme({ ... });

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <Provider store={store}>
      {/* Remove ThemeProvider and CssBaseline from here */}
      <BrowserRouter>
          <App />
      </BrowserRouter>
    </Provider>
  </React.StrictMode>
);

// ----- End File: src/index.js -----

// ----- End File: src\index.js -----

// ----- File: src\pages\AllRoutesPage.jsx -----

import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { Typography, Box } from '@mui/material';
import HistoryList from '../components/History/HistoryList';
import LoadingSpinner from '../components/Common/LoadingSpinner';
import ErrorMessage from '../components/Common/ErrorMessage';
import { fetchAllHistory, resetHistoryError } from '../store/slices/historySlice';

const AllRoutesPage = () => {
  const dispatch = useDispatch();
  const { allHistory, allHistoryStatus, error } = useSelector((state) => state.history);

  useEffect(() => {
    if (allHistoryStatus === 'idle') {
      dispatch(fetchAllHistory());
    }
     // Clear errors when component unmounts
     return () => {
        dispatch(resetHistoryError());
    }
  }, [allHistoryStatus, dispatch]);

  return (
    <Box>
      {allHistoryStatus === 'loading' && <LoadingSpinner />}
      {allHistoryStatus === 'failed' && <ErrorMessage error={error} title="Could not load all routes"/>}
      {allHistoryStatus === 'succeeded' && (
         // Pass the user object if backend includes it: route.user.username
        <HistoryList routes={allHistory} title="All User Routes" />
      )}
    </Box>
  );
};

export default AllRoutesPage;

// ----- End File: src\pages\AllRoutesPage.jsx -----

// ----- File: src\pages\ComparisonPage.jsx -----

// ----- File: src/pages/ComparisonPage.jsx -----

import React, { useState, useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { Box, Typography, Alert } from '@mui/material';
import ComparisonSelector from '../components/Comparison/ComparisonSelector';
import RouteComparisonContainer from '../components/RouteTrace/RouteComparisonContainer';
import ComparisonItem from '../components/Comparison/ComparisonItem';
import LoadingSpinner from '../components/Common/LoadingSpinner';
import ErrorMessage from '../components/Common/ErrorMessage';
import { fetchAllHistory, resetHistoryError } from '../store/slices/historySlice';

const ComparisonPage = () => {
    const dispatch = useDispatch();
    const { allHistory, allHistoryStatus, error: historyError } = useSelector((state) => state.history);
    const [selectedRouteIds, setSelectedRouteIds] = useState([]);

    // Fetch all history if not already loaded
    useEffect(() => {
        if (allHistoryStatus === 'idle') {
            dispatch(fetchAllHistory());
        }
        // Clear errors on unmount
        return () => {
            dispatch(resetHistoryError());
        };
    }, [allHistoryStatus, dispatch]);

    const handleSelectionChange = (selectedIds) => {
        setSelectedRouteIds(selectedIds);
    };

    // Filter the full history data based on selected IDs
    const selectedRoutesData = allHistory.filter(route => selectedRouteIds.includes(route.id));

    return (
        <Box>
            <Typography variant="h4" component="h1" gutterBottom>
                Compare Historical Traces
            </Typography>

            {allHistoryStatus === 'loading' && <LoadingSpinner />}
            {allHistoryStatus === 'failed' && <ErrorMessage error={historyError} title="Could not load route history" />}

            {allHistoryStatus === 'succeeded' && (
                <Box>
                    <ComparisonSelector
                        availableRoutes={allHistory}
                        selectedIds={selectedRouteIds}
                        onChange={handleSelectionChange}
                    />

                    {selectedRoutesData.length > 0 ? (
                         // Use RouteComparisonContainer, passing the selected *historical* routes
                         // and the ComparisonItem component to render each one.
                        <Box sx={{mt: 3}}>
                             <RouteComparisonContainer
                                traces={selectedRoutesData} // Pass historical data
                                SectionComponent={ComparisonItem} // Use the specific component for historical items
                             />
                        </Box>
                    ) : (
                        <Alert severity="info" sx={{ mt: 3 }}>
                            Select two or more routes from the history list above to compare them side-by-side.
                        </Alert>
                    )}
                </Box>
            )}
        </Box>
    );
};

export default ComparisonPage;

// ----- End File: src/pages/ComparisonPage.jsx -----

// ----- End File: src\pages\ComparisonPage.jsx -----

// ----- File: src\pages\DirectRouteTracePage.jsx -----

// ----- File: src/pages/DirectRouteTracePage.jsx -----

import React from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { Button, Box, Typography } from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import RouteComparisonContainer from '../components/RouteTrace/RouteComparisonContainer';
import DirectRouteTraceSection from '../components/RouteTrace/DirectRouteTraceSection'; // Import the correct section
import { addDirectTraceSection } from '../store/slices/directRouteSlice'; // Use correct slice action

const DirectRouteTracePage = () => {
    const dispatch = useDispatch();
    // Select state from the directRouteTrace slice
    const traces = useSelector((state) => state.directRoute.traces);

    const handleAddRoute = () => {
        dispatch(addDirectTraceSection()); // Dispatch action from directRouteSlice
    }

  return (
    <Box>
      <Typography variant="h4" component="h1" gutterBottom>
        Trace Direct Network Route
      </Typography>

      {/* Pass the specific SectionComponent */}
      <RouteComparisonContainer traces={traces} SectionComponent={DirectRouteTraceSection} />

       <Box sx={{ mt: 3, display: 'flex', justifyContent: 'center' }}>
            <Button
                variant="outlined"
                startIcon={<AddIcon />}
                onClick={handleAddRoute}
                disabled={traces.length >= 5} // Optional limit
            >
                Add Trace for Comparison
            </Button>
       </Box>
    </Box>
  );
};

export default DirectRouteTracePage;

// ----- End File: src/pages/DirectRouteTracePage.jsx -----

// ----- End File: src\pages\DirectRouteTracePage.jsx -----

// ----- File: src\pages\HistoryPage.jsx -----

import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { Typography, Box } from '@mui/material';
import HistoryList from '../components/History/HistoryList';
import LoadingSpinner from '../components/Common/LoadingSpinner';
import ErrorMessage from '../components/Common/ErrorMessage';
import { fetchUserHistory, resetHistoryError } from '../store/slices/historySlice';

const HistoryPage = () => {
  const dispatch = useDispatch();
  const { userHistory, userHistoryStatus, error } = useSelector((state) => state.history);

  useEffect(() => {
    // Fetch history only if it's not already loaded or loading
    if (userHistoryStatus === 'idle') {
      dispatch(fetchUserHistory());
    }
    // Clear errors when component unmounts
    return () => {
        dispatch(resetHistoryError());
    }
  }, [userHistoryStatus, dispatch]);

  return (
    <Box>
      {userHistoryStatus === 'loading' && <LoadingSpinner />}
      {userHistoryStatus === 'failed' && <ErrorMessage error={error} title="Could not load history"/>}
      {userHistoryStatus === 'succeeded' && (
        <HistoryList routes={userHistory} title="My Route History" />
      )}
    </Box>
  );
};

export default HistoryPage;

// ----- End File: src\pages\HistoryPage.jsx -----

// ----- File: src\pages\LoginPage.jsx -----

import React from 'react';
import LoginForm from '../components/Auth/LoginForm';

const LoginPage = () => {
  // Optional: Add any surrounding layout or elements specific to the login page
  return <LoginForm />;
};

export default LoginPage;

// ----- End File: src\pages\LoginPage.jsx -----

// ----- File: src\pages\MacTracePage.jsx -----

// ----- File: src/pages/MacTracePage.jsx -----

import React from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { Button, Box, Typography } from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import RouteComparisonContainer from '../components/RouteTrace/RouteComparisonContainer';
import MacTraceSection from '../components/RouteTrace/MacTraceSection'; // Import the correct section
import { addMacTraceSection } from '../store/slices/macTraceSlice'; // Use correct slice action

const MacTracePage = () => {
    const dispatch = useDispatch();
    // Select state from the macTrace slice
    const traces = useSelector((state) => state.macTrace.traces);

    const handleAddRoute = () => {
        dispatch(addMacTraceSection()); // Dispatch action from macTraceSlice
    }

  return (
    <Box>
      <Typography variant="h4" component="h1" gutterBottom>
        Trace MAC Path (Endpoint ↔ Gateway)
      </Typography>

      {/* Pass the specific SectionComponent */}
      <RouteComparisonContainer traces={traces} SectionComponent={MacTraceSection} />

       <Box sx={{ mt: 3, display: 'flex', justifyContent: 'center' }}>
            <Button
                variant="outlined"
                startIcon={<AddIcon />}
                onClick={handleAddRoute}
                disabled={traces.length >= 5} // Optional limit
            >
                Add Trace for Comparison
            </Button>
       </Box>
    </Box>
  );
};

export default MacTracePage;

// ----- End File: src/pages/MacTracePage.jsx -----

// ----- End File: src\pages\MacTracePage.jsx -----

// ----- File: src\pages\NotFoundPage.jsx -----

import React from 'react';
import { Typography, Box, Button } from '@mui/material';
import { Link as RouterLink } from 'react-router-dom';

const NotFoundPage = () => (
  <Box sx={{ textAlign: 'center', mt: 8 }}>
    <Typography variant="h3" component="h1" gutterBottom>
      404 - Page Not Found
    </Typography>
    <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
      Sorry, the page you are looking for does not exist.
    </Typography>
    <Button variant="contained" component={RouterLink} to="/">
      Go to Homepage
    </Button>
  </Box>
);

export default NotFoundPage;

// ----- End File: src\pages\NotFoundPage.jsx -----

// ----- File: src\pages\RouteTracePage.jsx -----

// ----- File: src/pages/RouteTracePage.jsx -----

import React from 'react';
import { useSelector } from 'react-redux';
import { Box, Typography, Paper } from '@mui/material';
// Remove Button, AddIcon, RouteComparisonContainer, RouteTraceSection imports
import RouteInputForm from '../components/RouteTrace/RouteInputForm'; // Import the form
import RouteVisualizer from '../components/RouteTrace/RouteVisualizer'; // Import the visualizer

const RouteTracePage = () => {
    // Select the single trace state object directly
    const trace = useSelector((state) => state.routeTrace.trace); // Access the single trace state

    // No need for handleAddRoute or dispatching add/remove actions anymore

    // Ensure trace exists before rendering (should always exist based on slice initial state)
    if (!trace) {
        return <Typography>Loading trace state...</Typography>; // Or some loading indicator
    }

    return (
        <Box>
            <Typography variant="h4" component="h1" gutterBottom>
                Trace Network Route (Combined)
            </Typography>

            {/* Render the single trace section directly */}
            {/* Use Paper for consistent look with other pages */}
            <Paper elevation={2} sx={{ p: 2, mb: 3 }}>
                <RouteInputForm trace={trace} />
                <RouteVisualizer trace={trace} />
            </Paper>

            {/* Remove the "Add Route for Comparison" button and surrounding Box */}

        </Box>
    );
};

export default RouteTracePage;

// ----- End File: src/pages/RouteTracePage.jsx -----

// ----- End File: src\pages\RouteTracePage.jsx -----

// ----- File: src\reportWebVitals.js -----

const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;


// ----- End File: src\reportWebVitals.js -----

// ----- File: src\services\api.js -----

import axios from 'axios';
import Cookies from 'js-cookie';

const API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:8000'; // Fallback

const apiClient = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Interceptor to add the auth token to requests
apiClient.interceptors.request.use(
  (config) => {
    const token = Cookies.get('authToken'); // Read token from cookie
    if (token) {
      // Assuming the backend expects the token in an 'Authorization: Bearer <token>' header
      // Adjust 'token' header name if backend expects something different (e.g., 'x-token')
      config.headers['token'] = token; // Use 'Authorization': `Bearer ${token}` if that's the standard used
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Optional: Interceptor to handle 401 Unauthorized errors globally
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response && error.response.status === 401) {
      // Token is invalid or expired
      Cookies.remove('authToken');
      // Optionally redirect to login or dispatch a logout action
      // window.location.href = '/login'; // Hard redirect
      // store.dispatch(logout()); // If you have a logout action
      console.error("Authentication Error: Token invalid or expired.");
    }
    return Promise.reject(error);
  }
);


export default apiClient;

// ----- End File: src\services\api.js -----

// ----- File: src\services\authService.js -----

import apiClient from './api';
import Cookies from 'js-cookie';

// Matches the Python UserG model
const login = async (username, password) => {
  try {
    // Backend endpoint: /verify-device-auth
    // Backend expects: { username: "user", password: "pw" } in the body
    const response = await apiClient.post('/verify-device-auth', { username, password });
    const token = response.data; // Assuming the backend returns the token directly in the data

    if (token) {
      // Store token in cookie - Secure flag should be true in production (HTTPS)
      Cookies.set('authToken', token, { expires: 1, path: '/' /*, secure: true, sameSite: 'strict' */ });
      // You might want to fetch user details here if needed, or decode the token if it's a JWT
      // For now, we just store the token. The presence of the token implies logged in status.
      return { success: true, user: { username } }; // Return basic user info
    } else {
      throw new Error('No token received from server');
    }
  } catch (error) {
    console.error('Login failed:', error.response?.data || error.message);
    throw new Error(error.response?.data?.detail || 'Login failed');
  }
};

const logout = () => {
    Cookies.remove('authToken', { path: '/' });
    // No API call needed unless backend has session invalidation
};

const authService = {
  login,
  logout,
};

export default authService;

// ----- End File: src\services\authService.js -----

// ----- File: src\services\routeService.js -----

import apiClient from './api';

// Corresponds to get_default_gateway(ip: str)
const getDefaultGateway = async (ip) => {
    try {
        // Adjust endpoint if needed, e.g. '/network/default-gateway'
        // Pass IP as a query parameter named 'ip'
        const response = await apiClient.get('/get-default-gateway', { params: { ip } });
        // Assuming the backend returns the gateway IP directly or in a specific field
        // Example: return response.data.gateway;
        return response.data; // Modify based on actual backend response structure
    } catch (error) {
        console.error(`Failed to get default gateway for ${ip}:`, error.response?.data || error.message);
        throw new Error(error.response?.data?.detail || `Failed to get DG for ${ip}`);
    }
};

// Corresponds to get_mac_trace(ip: str, dg: str)
const getMacTrace = async (ip, dg) => {
     try {
        // Adjust endpoint if needed
        // Pass ip and dg as query parameters
        const response = await apiClient.get('/get-mac-trace', { params: { ip, dg } });
        // Assuming backend returns the MAC trace data (e.g., list of hops)
        return response.data; // Modify based on actual backend response structure
    } catch (error) {
        console.error(`Failed to get MAC trace for ${ip} -> ${dg}:`, error.response?.data || error.message);
        throw new Error(error.response?.data?.detail || `Failed to get MAC trace`);
    }
};

// Corresponds to get_route_trace (or potentially get_tufin_route - clarify which one to use)
// Using get_route_trace based on code snippets provided
const getRouteTrace = async (source_ip, destination_ip, source_dg = null, destination_dg = null, source_dg_name = null, destination_dg_name = null, vrf = null, destination_vrf = null) => {
    try {
        const params = {
            source_ip,
            destination_ip,
            // Add other params only if they have values
            ...(source_dg && { source_dg }),
            ...(destination_dg && { destination_dg }),
            ...(source_dg_name && { source_dg_name }),
            ...(destination_dg_name && { destination_dg_name }),
            ...(vrf && { vrf }),
            ...(destination_vrf && { destination_vrf }),
        };
        const response = await apiClient.get('/get-route-trace', { params });
         // Backend saves automatically, frontend just gets the result.
         // Assuming backend returns the full route trace data (e.g., list of hops)
        return response.data; // Modify based on actual backend response structure
    } catch (error) {
        console.error(`Failed to get route trace:`, error.response?.data || error.message);
        throw new Error(error.response?.data?.detail || `Failed to get route trace`);
    }
};


// Corresponds to get_user_routes() - uses POST in backend? Check method. Assuming POST for now.
const getUserRoutes = async () => {
    try {
        // Backend uses POST for get-user-routes, ensure token is sent via interceptor
        const response = await apiClient.post('/get-user-routes');
        // Assuming backend returns a list of routes
        // Response format likely: [{id, source, destination, route, timestamp, ...}, ...]
        return response.data; // Modify based on actual backend response structure
    } catch (error) {
        console.error(`Failed to get user routes:`, error.response?.data || error.message);
        throw new Error(error.response?.data?.detail || `Failed to get user routes`);
    }
};

// Corresponds to get_all_routes() - uses POST in backend? Check method. Assuming POST.
const getAllRoutes = async () => {
    try {
        // Backend uses POST for get-all-routes
        const response = await apiClient.post('/get-all-routes');
        // Assuming backend returns a list of all routes
        return response.data; // Modify based on actual backend response structure
    } catch (error) {
        console.error(`Failed to get all routes:`, error.response?.data || error.message);
        throw new Error(error.response?.data?.detail || `Failed to get all routes`);
    }
};


const routeService = {
    getDefaultGateway,
    getMacTrace,
    getRouteTrace,
    getUserRoutes,
    getAllRoutes,
};

export default routeService;

// ----- End File: src\services\routeService.js -----

// ----- File: src\setupTests.js -----

// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';


// ----- End File: src\setupTests.js -----

// ----- File: src\store\slices\authSlice.js -----

import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import authService from '../../services/authService';
import Cookies from 'js-cookie';

// Async thunk for login
export const loginUser = createAsyncThunk(
  'auth/loginUser',
  async ({ username, password }, { rejectWithValue }) => {
    try {
      const data = await authService.login(username, password);
      return data; // Should return { success: true, user: { username } }
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// Initial state checks if a token exists in cookies
const initialState = {
  user: null,
  isAuthenticated: !!Cookies.get('authToken'), // Check cookie on initial load
  loading: false,
  error: null,
};

const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    logoutUser: (state) => {
      authService.logout(); // Clear cookie
      state.user = null;
      state.isAuthenticated = false;
      state.loading = false;
      state.error = null;
    },
    resetAuthError: (state) => {
        state.error = null;
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(loginUser.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(loginUser.fulfilled, (state, action) => {
        state.loading = false;
        state.isAuthenticated = true;
        state.user = action.payload.user; // Store user info from payload
        state.error = null;
      })
      .addCase(loginUser.rejected, (state, action) => {
        state.loading = false;
        state.isAuthenticated = false;
        state.user = null;
        state.error = action.payload; // Error message from rejectWithValue
      });
  },
});

export const { logoutUser, resetAuthError } = authSlice.actions;
export default authSlice.reducer;

// ----- End File: src\store\slices\authSlice.js -----

// ----- File: src\store\slices\directRouteSlice.js -----

// ----- File: src/store/slices/directRouteSlice.js -----

import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import routeService from '../../services/routeService';
import { v4 as uuidv4 } from 'uuid';

// Helper to create initial trace state for Direct Route trace
const createInitialDirectTraceState = () => ({
  id: uuidv4(),
  sourceIp: '',
  destinationIp: '',
  sourceDg: '',
  destinationDg: '',
  vrf: '', // Add VRF field
  sourceDgStatus: 'idle',
  destinationDgStatus: 'idle',
  traceStatus: 'idle', // 'idle', 'loading', 'succeeded', 'failed'
  traceResult: null, // Will hold the List[DetailedHop] for the direct route trace
  error: null,
});

// --- Async Thunks ---

// Reusable fetch DG logic
export const fetchDirectDefaultGateway = createAsyncThunk(
  'directRoute/fetchDefaultGateway',
  async ({ ip, type, traceId }, { rejectWithValue }) => {
    if (!ip) return rejectWithValue({ message: "IP address is required.", type, traceId });
    try {
      const gateway = await routeService.getDefaultGateway(ip);
      if (!gateway) throw new Error("No gateway found by backend.");
      return { gateway, type, traceId };
    } catch (error) {
      return rejectWithValue({ message: error.message || 'Failed to fetch DG', type, traceId });
    }
  }
);

// Thunk to perform the Direct Route trace
export const performDirectRouteTrace = createAsyncThunk(
  'directRoute/performDirectRouteTrace',
  async ({ traceId, sourceIp, destinationIp, sourceDg, destinationDg, vrf }, { rejectWithValue }) => {
    if (!sourceIp || !destinationIp || !sourceDg || !destinationDg) {
        return rejectWithValue({ message: "Source IP, Destination IP, Source DG, and Destination DG are required.", traceId });
    }
    try {
      // Call the specific backend endpoint for direct route trace
      const result = await routeService.getRouteTrace(
          sourceIp, destinationIp, sourceDg, destinationDg, null, null, vrf // Map frontend names to backend params (dg_name params omitted, vrf added)
      );
      return { traceId, result }; // result is expected List[DetailedHop]
    } catch (error) {
      return rejectWithValue({ message: error.message || 'Direct route trace failed', traceId, errorObj: error });
    }
  }
);

// --- Slice Definition ---

const initialState = {
  traces: [createInitialDirectTraceState()], // Start with one direct trace section
};

const directRouteSlice = createSlice({
  name: 'directRoute',
  initialState,
  reducers: {
    addDirectTraceSection: (state) => {
       if (state.traces.length < 5) {
         state.traces.push(createInitialDirectTraceState());
       }
    },
    removeDirectTraceSection: (state, action) => {
        const traceIdToRemove = action.payload;
        if (state.traces.length > 1) {
            state.traces = state.traces.filter(trace => trace.id !== traceIdToRemove);
        }
    },
    updateDirectTraceInput: (state, action) => {
      const { traceId, field, value } = action.payload;
      const trace = state.traces.find(t => t.id === traceId);
      if (trace) {
        trace[field] = value;
        // Reset status and results when inputs change
        trace.traceStatus = 'idle';
        trace.traceResult = null;
        trace.error = null;

        // Handle DG status updates
        if (field === 'sourceDg' && trace.sourceDgStatus !== 'loading') trace.sourceDgStatus = 'manual';
        if (field === 'destinationDg' && trace.destinationDgStatus !== 'loading') trace.destinationDgStatus = 'manual';
        if (field === 'sourceIp') {
            trace.sourceDg = ''; trace.sourceDgStatus = 'idle';
        }
        if (field === 'destinationIp') {
            trace.destinationDg = ''; trace.destinationDgStatus = 'idle';
        }
      }
    },
    resetDirectTraceState: (state) => {
        state.traces = [createInitialDirectTraceState()];
    }
  },
  extraReducers: (builder) => {
    builder
      // Default Gateway Fetching (identical logic to other slices)
      .addCase(fetchDirectDefaultGateway.pending, (state, action) => {
        const { type, traceId } = action.meta.arg;
        const trace = state.traces.find(t => t.id === traceId);
        if (trace) {
          if (type === 'source') trace.sourceDgStatus = 'loading';
          if (type === 'destination') trace.destinationDgStatus = 'loading';
          trace.error = null;
        }
      })
      .addCase(fetchDirectDefaultGateway.fulfilled, (state, action) => {
        const { gateway, type, traceId } = action.payload;
        const trace = state.traces.find(t => t.id === traceId);
        if (trace) {
          if (type === 'source') { trace.sourceDg = gateway; trace.sourceDgStatus = 'succeeded'; }
          if (type === 'destination') { trace.destinationDg = gateway; trace.destinationDgStatus = 'succeeded'; }
        }
      })
      .addCase(fetchDirectDefaultGateway.rejected, (state, action) => {
        const { message, type, traceId } = action.payload;
        const trace = state.traces.find(t => t.id === traceId);
         if (trace) {
          if (type === 'source') trace.sourceDgStatus = 'failed';
          if (type === 'destination') trace.destinationDgStatus = 'failed';
          trace.error = `DG Fetch Error (${type}): ${message}`;
        }
      })

      // Direct Route Trace Execution
      .addCase(performDirectRouteTrace.pending, (state, action) => {
        const { traceId } = action.meta.arg;
        const trace = state.traces.find(t => t.id === traceId);
        if (trace) {
          trace.traceStatus = 'loading';
          trace.error = null;
          trace.traceResult = null; // Clear previous result
        }
      })
      .addCase(performDirectRouteTrace.fulfilled, (state, action) => {
        const { traceId, result } = action.payload;
        const trace = state.traces.find(t => t.id === traceId);
        if (trace) {
          trace.traceStatus = 'succeeded';
          trace.traceResult = result; // Store the List[DetailedHop]
          trace.error = null;
        }
      })
      .addCase(performDirectRouteTrace.rejected, (state, action) => {
        const { message, traceId } = action.payload;
        const trace = state.traces.find(t => t.id === traceId);
        if (trace) {
          trace.traceStatus = 'failed';
          trace.error = message;
          trace.traceResult = null; // Ensure result is null on failure
        }
      });
  },
});

export const { addDirectTraceSection, removeDirectTraceSection, updateDirectTraceInput, resetDirectTraceState } = directRouteSlice.actions;
export default directRouteSlice.reducer;

// ----- End File: src/store/slices/directRouteSlice.js -----

// ----- End File: src\store\slices\directRouteSlice.js -----

// ----- File: src\store\slices\historySlice.js -----

// src/store/slices/historySlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import routeService from '../../services/routeService';

// Helper to safely parse JSON
const safeParseJson = (jsonString, defaultValue = null) => {
  // Added check for already parsed objects which might happen in some scenarios
  if (typeof jsonString === 'object' && jsonString !== null) return jsonString;
  if (typeof jsonString !== 'string') return defaultValue; // Return default if not string or object
  try {
    return JSON.parse(jsonString);
  } catch (e) {
    console.error("Failed to parse JSON:", e, "Input:", jsonString);
    return defaultValue; // Return default if parsing fails
  }
};

// Async thunk for fetching user-specific route history
export const fetchUserHistory = createAsyncThunk(
  'history/fetchUserHistory',
  async (_, { rejectWithValue }) => {
    try {
      const routes = await routeService.getUserRoutes();
      // Backend returns RouteHistoryEntry model
      // route field is a JSON string of List[DetailedHop]
      // device_additional_info is optional JSON string
      return routes.map(r => ({
        ...r,
        // Parse the JSON strings into objects/arrays
        // Ensure routeData becomes an array of hops or null/empty array
        routeData: safeParseJson(r.route, []), // Default to empty array if parse fails
        deviceInfo: safeParseJson(r.device_additional_info), // Default to null
      }));
    } catch (error) {
      return rejectWithValue(error.message || 'Failed to fetch user history');
    }
  }
);

// Async thunk for fetching all routes (admin)
export const fetchAllHistory = createAsyncThunk(
  'history/fetchAllHistory',
  async (_, { rejectWithValue }) => {
    try {
      const routes = await routeService.getAllRoutes();
       return routes.map(r => ({
        ...r,
        routeData: safeParseJson(r.route, []),
        deviceInfo: safeParseJson(r.device_additional_info),
        // Keep user info if backend provides it
        user: r.user || null
      }));
    } catch (error) {
      return rejectWithValue(error.message || 'Failed to fetch all routes');
    }
  }
);

const initialState = {
  userHistory: [],
  allHistory: [],
  userHistoryStatus: 'idle', // 'idle', 'loading', 'succeeded', 'failed'
  allHistoryStatus: 'idle',
  error: null,
};

const historySlice = createSlice({
  name: 'history',
  initialState,
  reducers: {
    resetHistoryError: (state) => {
        state.error = null;
    }
  },
  extraReducers: (builder) => {
    builder
      // User History Fetching
      .addCase(fetchUserHistory.pending, (state) => {
        state.userHistoryStatus = 'loading';
        state.error = null;
      })
      .addCase(fetchUserHistory.fulfilled, (state, action) => {
        state.userHistoryStatus = 'succeeded';
        state.userHistory = action.payload;
      })
      .addCase(fetchUserHistory.rejected, (state, action) => {
        state.userHistoryStatus = 'failed';
        state.error = action.payload;
      })
      // All History Fetching
      .addCase(fetchAllHistory.pending, (state) => {
        state.allHistoryStatus = 'loading';
        state.error = null;
      })
      .addCase(fetchAllHistory.fulfilled, (state, action) => {
        state.allHistoryStatus = 'succeeded';
        state.allHistory = action.payload;
      })
      .addCase(fetchAllHistory.rejected, (state, action) => {
        state.allHistoryStatus = 'failed';
        state.error = action.payload;
      });
  },
});

export const { resetHistoryError } = historySlice.actions;
export default historySlice.reducer;

// ----- End File: src\store\slices\historySlice.js -----

// ----- File: src\store\slices\macTraceSlice.js -----

// ----- File: src/store/slices/macTraceSlice.js -----

import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import routeService from '../../services/routeService';
import { v4 as uuidv4 } from 'uuid';

// Helper to create initial trace state for MAC trace
const createInitialMacTraceState = () => ({
  id: uuidv4(),
  ip: '', // Endpoint IP
  dg: '', // Default Gateway
  dgStatus: 'idle', // 'idle', 'loading', 'succeeded', 'failed', 'manual'
  traceStatus: 'idle', // 'idle', 'loading', 'succeeded', 'failed'
  traceResult: null, // Will hold the List[DetailedHop] for the MAC trace
  error: null,
});

// --- Async Thunks ---

// Reusable fetch DG logic (or could import from a shared utility if needed)
export const fetchMacDefaultGateway = createAsyncThunk(
  'macTrace/fetchDefaultGateway',
  async ({ ip, traceId }, { rejectWithValue }) => {
    if (!ip) return rejectWithValue({ message: "IP address is required.", traceId });
    try {
      const gateway = await routeService.getDefaultGateway(ip);
      if (!gateway) throw new Error("No gateway found by backend.");
      return { gateway, traceId }; // Only need gateway and traceId
    } catch (error) {
      return rejectWithValue({ message: error.message || 'Failed to fetch DG', traceId });
    }
  }
);

// Thunk to perform the MAC trace
export const performMacTrace = createAsyncThunk(
  'macTrace/performMacTrace',
  async ({ traceId, ip, dg }, { rejectWithValue }) => {
    if (!ip || !dg) {
        return rejectWithValue({ message: "Endpoint IP and Default Gateway are required.", traceId });
    }
    try {
      const result = await routeService.getMacTrace(ip, dg);
      return { traceId, result }; // result is expected List[DetailedHop]
    } catch (error) {
      return rejectWithValue({ message: error.message || 'MAC trace failed', traceId, errorObj: error });
    }
  }
);

// --- Slice Definition ---

const initialState = {
  traces: [createInitialMacTraceState()], // Start with one MAC trace section
};

const macTraceSlice = createSlice({
  name: 'macTrace',
  initialState,
  reducers: {
    addMacTraceSection: (state) => {
       if (state.traces.length < 5) {
         state.traces.push(createInitialMacTraceState());
       }
    },
    removeMacTraceSection: (state, action) => {
        const traceIdToRemove = action.payload;
        if (state.traces.length > 1) {
            state.traces = state.traces.filter(trace => trace.id !== traceIdToRemove);
        }
    },
    updateMacTraceInput: (state, action) => {
      const { traceId, field, value } = action.payload;
      const trace = state.traces.find(t => t.id === traceId);
      if (trace) {
        trace[field] = value;
        // Reset status and results when inputs change
        trace.traceStatus = 'idle';
        trace.traceResult = null;
        trace.error = null;

        // Mark DG as manually entered if user changes it
        if (field === 'dg' && trace.dgStatus !== 'loading') trace.dgStatus = 'manual';

        // Reset DG status if IP changes
        if (field === 'ip') {
            trace.dg = ''; // Clear old DG if IP changes
            trace.dgStatus = 'idle';
        }
      }
    },
    resetMacTraceState: (state) => {
        state.traces = [createInitialMacTraceState()];
    }
  },
  extraReducers: (builder) => {
    builder
      // Default Gateway Fetching
      .addCase(fetchMacDefaultGateway.pending, (state, action) => {
        const { traceId } = action.meta.arg;
        const trace = state.traces.find(t => t.id === traceId);
        if (trace) {
          trace.dgStatus = 'loading';
          trace.error = null; // Clear previous errors
        }
      })
      .addCase(fetchMacDefaultGateway.fulfilled, (state, action) => {
        const { gateway, traceId } = action.payload;
        const trace = state.traces.find(t => t.id === traceId);
        if (trace) {
            trace.dg = gateway;
            trace.dgStatus = 'succeeded';
        }
      })
      .addCase(fetchMacDefaultGateway.rejected, (state, action) => {
        const { message, traceId } = action.payload;
        const trace = state.traces.find(t => t.id === traceId);
         if (trace) {
          trace.dgStatus = 'failed';
          trace.error = `DG Fetch Error: ${message}`;
        }
      })

      // MAC Trace Execution
      .addCase(performMacTrace.pending, (state, action) => {
        const { traceId } = action.meta.arg;
        const trace = state.traces.find(t => t.id === traceId);
        if (trace) {
          trace.traceStatus = 'loading';
          trace.error = null;
          trace.traceResult = null; // Clear previous result
        }
      })
      .addCase(performMacTrace.fulfilled, (state, action) => {
        const { traceId, result } = action.payload;
        const trace = state.traces.find(t => t.id === traceId);
        if (trace) {
          trace.traceStatus = 'succeeded';
          trace.traceResult = result; // Store the List[DetailedHop]
          trace.error = null;
        }
      })
      .addCase(performMacTrace.rejected, (state, action) => {
        const { message, traceId } = action.payload;
        const trace = state.traces.find(t => t.id === traceId);
        if (trace) {
          trace.traceStatus = 'failed';
          trace.error = message;
          trace.traceResult = null; // Ensure result is null on failure
        }
      });
  },
});

export const { addMacTraceSection, removeMacTraceSection, updateMacTraceInput, resetMacTraceState } = macTraceSlice.actions;
export default macTraceSlice.reducer;

// ----- End File: src/store/slices/macTraceSlice.js -----

// ----- End File: src\store\slices\macTraceSlice.js -----

// ----- File: src\store\slices\routeTraceSlice.js -----

// ----- File: src/store/slices/routeTraceSlice.js -----

import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import routeService from '../../services/routeService';
import { v4 as uuidv4 } from 'uuid';

// Helper to create initial trace state
const createInitialTraceState = () => ({
  id: uuidv4(), // Unique ID for this trace instance
  sourceIp: '',
  destinationIp: '',
  sourceDg: '',
  destinationDg: '',
  sourceDgStatus: 'idle', // 'idle', 'loading', 'succeeded', 'failed', 'manual'
  destinationDgStatus: 'idle',
  traceStatus: 'idle', // 'idle', 'loading', 'succeeded', 'failed', 'partial_success'
  sourceMacTrace: null, // Expecting format like List[DetailedHop] or null
  destinationMacTrace: null, // Expecting format like List[DetailedHop] or null
  mainRouteTrace: null, // Expecting format like List[DetailedHop] or null
  error: null, // Can store string or object for more details
});

// --- Async Thunks (Modified to accept traceId in payload but operate on single state) ---

// Fetch DG needs traceId in case multiple slices use it, but RouteTrace only has one trace
export const fetchDefaultGateway = createAsyncThunk(
  'routeTrace/fetchDefaultGateway',
  async ({ ip, type, traceId }, { rejectWithValue, getState }) => {
    // Ensure the traceId matches the ID in the current state
    const currentTraceId = getState().routeTrace.trace.id;
    if (traceId !== currentTraceId) {
         console.warn(`fetchDefaultGateway: Mismatched traceId. State: ${currentTraceId}, Action: ${traceId}. Ignoring action.`);
         // Don't reject, just ignore if ID doesn't match current state
         return { ignored: true }; // Signal that the action was ignored
    }

    if (!ip) return rejectWithValue({ message: "IP address is required.", type, traceId });
    try {
      const gateway = await routeService.getDefaultGateway(ip);
      if (!gateway) throw new Error("No gateway found by backend.");
      return { gateway, type, traceId }; // Return traceId for consistency
    } catch (error) {
      return rejectWithValue({ message: error.message || 'Failed to fetch DG', type, traceId });
    }
  }
);

// Perform trace needs traceId to ensure action corresponds to current state
export const performFullTrace = createAsyncThunk(
  'routeTrace/performFullTrace',
  async ({ traceId, sourceIp, destinationIp, sourceDg, destinationDg }, { rejectWithValue, getState }) => {
    const currentTraceId = getState().routeTrace.trace.id;
    if (traceId !== currentTraceId) {
        console.warn(`performFullTrace: Mismatched traceId. State: ${currentTraceId}, Action: ${traceId}. Ignoring action.`);
        // Don't reject, just ignore
        return { ignored: true };
    }

    if (!sourceIp || !destinationIp || !sourceDg || !destinationDg) {
        return rejectWithValue({ message: "Source IP, Destination IP, Source DG, and Destination DG are required.", traceId });
    }
    try {
      // Perform the API calls concurrently
      const results = await Promise.allSettled([
        routeService.getRouteTrace(sourceIp, destinationIp, sourceDg, destinationDg), // Main route first
        routeService.getMacTrace(sourceIp, sourceDg),
        routeService.getMacTrace(destinationIp, destinationDg)
      ]);

      const [mainRouteResult, sourceMacResult, destMacResult] = results;

      // Extract data or null from results
      const mainRouteTrace = mainRouteResult.status === 'fulfilled' ? mainRouteResult.value : null;
      const sourceMacTrace = sourceMacResult.status === 'fulfilled' ? sourceMacResult.value : null;
      const destinationMacTrace = destMacResult.status === 'fulfilled' ? destMacResult.value : null;

      // Collect error messages
      const errors = results
        .filter(p => p.status === 'rejected')
        .map(p => p.reason?.message || 'Unknown trace component error') // Use optional chaining
        .join('; ');

      // Determine overall status
      let status = 'failed'; // Default to failed
      if (mainRouteResult.status === 'fulfilled') {
          status = errors ? 'partial_success' : 'succeeded'; // Success/Partial if main trace worked
      }

      if (status === 'failed' && mainRouteResult.status === 'rejected') {
          // If the main trace failed fundamentally, throw its error to be caught by rejectWithValue
          throw new Error(errors || mainRouteResult.reason?.message || 'Main trace failed fundamentally');
      }

      return {
        traceId, // Include traceId in the fulfilled payload for matching
        mainRouteTrace,
        sourceMacTrace,
        destinationMacTrace,
        status, // 'succeeded' or 'partial_success' or 'failed' (if only mac traces failed)
        error: errors || null // Report partial errors if any
      };

    } catch (error) {
      // Catches error from the try block (fundamental failure) or rejections if not handled above
      return rejectWithValue({ message: error.message || 'Full trace operation failed', traceId, errorObj: error });
    }
  }
);

// --- Slice Definition (Simplified State) ---

const initialState = {
  // Contains only *one* trace state object, not an array
  trace: createInitialTraceState(),
};

const routeTraceSlice = createSlice({
  name: 'routeTrace',
  initialState,
  reducers: {
    // REMOVED: addTraceSection, removeTraceSection

    updateTraceInput: (state, action) => {
      const { traceId, field, value } = action.payload;
      // Check if the action is for the *current* trace object in state
      if (state.trace.id === traceId) {
          const trace = state.trace; // Direct reference to the single trace object
          trace[field] = value;
          // Reset status and results when inputs change
          trace.traceStatus = 'idle';
          trace.mainRouteTrace = null;
          trace.sourceMacTrace = null;
          trace.destinationMacTrace = null;
          trace.error = null;

          // Mark DG as manually entered if user changes it after auto-fetch/fail
          if (field === 'sourceDg' && trace.sourceDgStatus !== 'loading') trace.sourceDgStatus = 'manual';
          if (field === 'destinationDg' && trace.destinationDgStatus !== 'loading') trace.destinationDgStatus = 'manual';

          // Reset DG status if IP changes
          if (field === 'sourceIp') {
              trace.sourceDg = ''; // Clear old DG if source IP changes
              trace.sourceDgStatus = 'idle';
          }
          if (field === 'destinationIp') {
              trace.destinationDg = ''; // Clear old DG if destination IP changes
              trace.destinationDgStatus = 'idle';
          }
      } else {
          console.warn(`updateTraceInput: Mismatched traceId. State: ${state.trace.id}, Action: ${traceId}. Ignoring update.`);
      }
    },
    resetTraceState: (state) => {
        // Replace the existing trace object with a new initial one
        state.trace = createInitialTraceState();
    }
  },
  extraReducers: (builder) => {
    builder
      // Default Gateway Fetching
      .addCase(fetchDefaultGateway.pending, (state, action) => {
        const { type, traceId } = action.meta.arg;
        // Only update state if the pending action matches the current trace ID
        if (state.trace.id === traceId) {
          if (type === 'source') state.trace.sourceDgStatus = 'loading';
          if (type === 'destination') state.trace.destinationDgStatus = 'loading';
          state.trace.error = null; // Clear previous DG errors
        }
      })
      .addCase(fetchDefaultGateway.fulfilled, (state, action) => {
         if (action.payload.ignored) return; // Do nothing if action was ignored
        const { gateway, type, traceId } = action.payload;
        // Only update state if the fulfilled action matches the current trace ID
        if (state.trace.id === traceId) {
          if (type === 'source') {
            state.trace.sourceDg = gateway;
            state.trace.sourceDgStatus = 'succeeded';
          }
          if (type === 'destination') {
            state.trace.destinationDg = gateway;
            state.trace.destinationDgStatus = 'succeeded';
          }
           // Clear general error if DG fetch succeeds (might overwrite a previous trace error)
           state.trace.error = null;
        }
      })
      .addCase(fetchDefaultGateway.rejected, (state, action) => {
        if (action.payload.ignored) return; // Do nothing if action was ignored
        const { message, type, traceId } = action.payload;
        // Only update state if the rejected action matches the current trace ID
        if (state.trace.id === traceId) {
          if (type === 'source') state.trace.sourceDgStatus = 'failed';
          if (type === 'destination') state.trace.destinationDgStatus = 'failed';
          // Set the error specifically for DG failure
          state.trace.error = `DG Fetch Error (${type}): ${message}`;
          // Reset trace status if a DG fetch fails while trace was in progress/success
          state.trace.traceStatus = 'idle';
        }
      })

      // Full Trace Execution
      .addCase(performFullTrace.pending, (state, action) => {
        const { traceId } = action.meta.arg;
        // Only update state if the pending action matches the current trace ID
        if (state.trace.id === traceId) {
          state.trace.traceStatus = 'loading';
          state.trace.error = null;
          // Clear previous results while loading new ones
          state.trace.mainRouteTrace = null;
          state.trace.sourceMacTrace = null;
          state.trace.destinationMacTrace = null;
        }
      })
      .addCase(performFullTrace.fulfilled, (state, action) => {
         if (action.payload.ignored) return; // Do nothing if action was ignored
        const { traceId, mainRouteTrace, sourceMacTrace, destinationMacTrace, status, error } = action.payload;
        // Only update state if the fulfilled action matches the current trace ID
        if (state.trace.id === traceId) {
          state.trace.traceStatus = status; // 'succeeded' or 'partial_success' or 'failed'
          state.trace.mainRouteTrace = mainRouteTrace;
          state.trace.sourceMacTrace = sourceMacTrace;
          state.trace.destinationMacTrace = destinationMacTrace;
          state.trace.error = error; // Store any partial errors reported
        }
      })
      .addCase(performFullTrace.rejected, (state, action) => {
        if (action.payload.ignored) return; // Do nothing if action was ignored
        const { message, traceId } = action.payload;
        // Only update state if the rejected action matches the current trace ID
        if (state.trace.id === traceId) {
          state.trace.traceStatus = 'failed';
          state.trace.error = message; // Store the main error message
           // Ensure results are explicitly null on failure
           state.trace.mainRouteTrace = null;
           state.trace.sourceMacTrace = null;
           state.trace.destinationMacTrace = null;
        }
      });
  },
});

// Export only the relevant actions
export const { updateTraceInput, resetTraceState } = routeTraceSlice.actions;
export default routeTraceSlice.reducer;

// ----- End File: src/store/slices/routeTraceSlice.js -----

// ----- End File: src\store\slices\routeTraceSlice.js -----

// ----- File: src\store\store.js -----

// ----- File: src/store/store.js -----

import { configureStore } from '@reduxjs/toolkit';
import authReducer from './slices/authSlice';
import routeTraceReducer from './slices/routeTraceSlice'; // Combined trace
import macTraceReducer from './slices/macTraceSlice'; // MAC trace
import directRouteReducer from './slices/directRouteSlice'; // Direct route trace
import historyReducer from './slices/historySlice';

const store = configureStore({
  reducer: {
    auth: authReducer,
    routeTrace: routeTraceReducer, // State key for combined trace page
    macTrace: macTraceReducer,     // State key for MAC trace page
    directRoute: directRouteReducer, // State key for direct route trace page
    history: historyReducer,
  },
  // Middleware is automatically included by configureStore (e.g., thunk)
});

export default store;

// ----- End File: src/store/store.js -----

// ----- End File: src\store\store.js -----

// ----- File: src\theme.js -----

// ----- File: src/theme.js -----

import { createTheme } from '@mui/material/styles';
import { amber, grey, deepOrange } from '@mui/material/colors';

const getDesignTokens = (mode) => ({
  palette: {
    mode,
    ...(mode === 'light'
      ? {
          // palette values for light mode
          primary: { // Example: Blueish primary
              main: '#1976d2',
          },
          secondary: { // Example: Purpleish secondary
              main: '#9c27b0',
          },
          divider: grey[300], // Lighter divider
          background: {
            default: '#f4f6f8', // Light grey background
            paper: '#ffffff', // White paper background
          },
          text: {
            primary: grey[900],
            secondary: grey[700],
          },
        }
      : {
          // palette values for dark mode
          primary: { // Example: A lighter blue for dark mode
            main: '#90caf9',
          },
          secondary: { // Example: A lighter purple
            main: '#ce93d8',
          },
          divider: grey[700], // Darker divider
          background: {
            default: '#121212', // Standard dark background
            paper: '#1e1e1e', // Slightly lighter paper
          },
          text: {
            primary: '#ffffff',
            secondary: grey[400],
          },
        }),
  },
  // You can customize typography, components defaults etc. here
  typography: {
      fontFamily: 'Roboto, sans-serif',
  },
  components: {
      // Example: Default props for MuiAppBar
      MuiAppBar: {
          defaultProps: {
              elevation: 1, // Subtle shadow
          }
      },
      // Example: Default props for MuiDrawer
      MuiDrawer: {
          styleOverrides: {
              paper: {
                  // Add styles if needed, e.g., borderRight for permanent drawer
                  // borderRight: `1px solid ${mode === 'light' ? grey[300] : grey[700]}`,
              }
          }
      }
  }
});

export default getDesignTokens;

// ----- End File: src/theme.js -----

// ----- End File: src\theme.js -----

// ----- File: src\utils\formatters.js -----

import { format } from 'date-fns'; // Using date-fns, install if needed: npm install date-fns

export const formatTimestamp = (timestamp, fmt = 'yyyy-MM-dd HH:mm:ss') => {
  if (!timestamp) return 'N/A';
  try {
    // Assuming timestamp is in a format Date can parse (like ISO 8601)
    const date = new Date(timestamp);
    return format(date, fmt);
  } catch (error) {
    console.error("Error formatting timestamp:", error);
    return timestamp; // Return original if formatting fails
  }
};

// ----- End File: src\utils\formatters.js -----

