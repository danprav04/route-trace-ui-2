--- Project Tree ---

route-trace-app/
├── public
│   ├── index.html
│   ├── manifest.json
│   └── robots.txt
├── src
│   ├── components
│   │   ├── Auth
│   │   │   └── LoginForm.jsx
│   │   ├── Common
│   │   │   ├── ErrorMessage.jsx
│   │   │   ├── LoadingSpinner.jsx
│   │   │   └── Navbar.jsx
│   │   ├── History
│   │   │   ├── HistoryItem.jsx
│   │   │   └── HistoryList.jsx
│   │   └── RouteTrace
│   │       ├── HopDisplay.jsx
│   │       ├── MacTraceDisplay.jsx
│   │       ├── RouteComparisonContainer.jsx
│   │       ├── RouteInputForm.jsx
│   │       ├── RouteTraceSection.jsx
│   │       └── RouteVisualizer.jsx
│   ├── hooks
│   │   └── useAuth.js
│   ├── pages
│   │   ├── AllRoutesPage.jsx
│   │   ├── HistoryPage.jsx
│   │   ├── LoginPage.jsx
│   │   ├── NotFoundPage.jsx
│   │   └── RouteTracePage.jsx
│   ├── services
│   │   ├── api.js
│   │   ├── authService.js
│   │   └── routeService.js
│   ├── store
│   │   ├── slices
│   │   │   ├── authSlice.js
│   │   │   ├── historySlice.js
│   │   │   └── routeTraceSlice.js
│   │   └── store.js
│   ├── utils
│   │   └── formatters.js
│   ├── App.css
│   ├── App.js
│   ├── App.test.js
│   ├── index.css
│   ├── index.js
│   ├── reportWebVitals.js
│   └── setupTests.js
├── .gitignore
├── combine_project.js
├── package.json
└── README.md


--- File Contents ---

// ----- File: .gitignore -----

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*


// ----- End File: .gitignore -----

// ----- File: README.md -----

# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: [https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

### Analyzing the Bundle Size

This section has moved here: [https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

### Making a Progressive Web App

This section has moved here: [https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

### Advanced Configuration

This section has moved here: [https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

### Deployment

This section has moved here: [https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

### `npm run build` fails to minify

This section has moved here: [https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)


// ----- End File: README.md -----

// ----- File: combine_project.js -----

const fs = require('fs');
const path = require('path');

// --- Configuration ---

// Directories to completely ignore
const EXCLUDED_DIRS = [
    'node_modules',
    '.git',
    'build',
    'coverage',
    '.vscode',
    '.idea',
    '. Caches' // Example for specific tools
];

// Specific files to ignore
const EXCLUDED_FILES = [
    'package-lock.json',
    'yarn.lock',
    '.env',
    '.DS_Store'
];

// File extensions to ignore (lower-cased)
const EXCLUDED_EXTENSIONS = [
    '.png', '.jpg', '.jpeg', '.gif', '.bmp', '.tiff', '.webp', // Images
    '.svg', // SVGs can be code, but often treated as assets in CRA
    '.ico', // Favicon
    '.woff', '.woff2', '.ttf', '.eot', // Fonts
    '.mp4', '.mov', '.avi', // Videos
    '.mp3', '.wav', // Audio
    '.map', // Source maps
    '.pdf', '.doc', '.docx', '.xls', '.xlsx', // Documents
    '.zip', '.gz', '.tar' // Archives
];

// File extensions to *include* (if not excluded elsewhere). Add more if needed.
// If empty, all non-excluded extensions will be included.
// Useful if you *only* want specific source types.
const INCLUDED_EXTENSIONS = [
    // '.js', '.jsx', '.ts', '.tsx', // Javascript/Typescript
    // '.css', '.scss', '.sass', '.less', '.module.css', // Stylesheets
    // '.json', // Config files, data
    // '.html', // HTML files (like public/index.html)
    // '.md' // Markdown
]; // Leave empty to include *all* non-excluded files

const OUTPUT_FILE = 'combined_project_output.txt';

// --- Helper Functions ---

function isExcluded(relativePath, stats) {
    const baseName = path.basename(relativePath);
    const ext = path.extname(baseName).toLowerCase();

    if (stats.isDirectory()) {
        return EXCLUDED_DIRS.includes(baseName);
    }

    if (EXCLUDED_FILES.includes(baseName)) {
        return true;
    }

    if (EXCLUDED_EXTENSIONS.includes(ext)) {
        return true;
    }

    // If INCLUDED_EXTENSIONS is specified, *only* include those
    if (INCLUDED_EXTENSIONS.length > 0 && !INCLUDED_EXTENSIONS.includes(ext)) {
        return true;
    }


    return false;
}

// --- Tree Generation ---

function generateTree(dir, rootDir, prefix = '', includedFiles) {
    let tree = '';
    try {
        const entries = fs.readdirSync(dir, { withFileTypes: true });
        const filteredEntries = entries
            .filter(entry => {
                 // Always check exclusion based on the *full* relative path from the root
                const entryRelativePath = path.relative(rootDir, path.join(dir, entry.name));
                const stats = fs.statSync(path.join(dir, entry.name)); // Need stats for isExcluded check
                 // Don't add excluded items to the tree *at all*
                return !isExcluded(entryRelativePath, stats);
            })
            .sort((a, b) => {
                // Directories first, then files, then alphabetically
                if (a.isDirectory() && !b.isDirectory()) return -1;
                if (!a.isDirectory() && b.isDirectory()) return 1;
                return a.name.localeCompare(b.name);
            });

        filteredEntries.forEach((entry, index) => {
            const isLast = index === filteredEntries.length - 1;
            const connector = isLast ? '└── ' : '├── ';
            const entryPath = path.join(dir, entry.name);
            const entryRelativePath = path.relative(rootDir, entryPath); // Path relative to project root

            tree += `${prefix}${connector}${entry.name}\n`;

            if (entry.isDirectory()) {
                const newPrefix = prefix + (isLast ? '    ' : '│   ');
                tree += generateTree(entryPath, rootDir, newPrefix, includedFiles);
            } else {
                // Optionally: Only add files to the tree that will be included in the content part
                 if (includedFiles.has(entryRelativePath)) {
                     // File already added during tree build if check is here
                 } else {
                    // If we want the tree to show *all* non-excluded files, even if INCLUDED_EXTENSIONS
                    // limits content, then we don't need the check above.
                    // Current implementation shows all non-excluded files/dirs in the tree.
                 }
            }
        });
    } catch (err) {
        console.error(`Error reading directory ${dir}: ${err.message}`);
        tree += `${prefix}└── [Error reading directory]\n`;
    }
    return tree;
}


// --- File Content Gathering ---

function gatherFileContents(dir, rootDir) {
    let filesToInclude = new Map(); // Using Map to store { relativePath: absolutePath }

    function traverse(currentDir) {
        try {
            const entries = fs.readdirSync(currentDir, { withFileTypes: true });

            for (const entry of entries) {
                const absolutePath = path.join(currentDir, entry.name);
                const relativePath = path.relative(rootDir, absolutePath);
                 // Use statSync here to check if it's a file or dir for exclusion
                let stats;
                 try {
                     stats = fs.statSync(absolutePath);
                 } catch (statErr) {
                     console.warn(`Warning: Could not stat ${absolutePath}. Skipping. Error: ${statErr.message}`);
                     continue; // Skip if stat fails (e.g., broken symlink)
                 }


                if (isExcluded(relativePath, stats)) {
                    // console.log(`Excluding: ${relativePath}`); // Uncomment for debugging exclusions
                    continue;
                }

                if (entry.isDirectory()) {
                    traverse(absolutePath);
                } else if (entry.isFile()) {
                    // console.log(`Including: ${relativePath}`); // Uncomment for debugging inclusions
                    filesToInclude.set(relativePath, absolutePath);
                }
            }
        } catch (err) {
            console.error(`Error reading directory ${currentDir}: ${err.message}`);
        }
    }

    traverse(dir);
    return filesToInclude; // Return the Map
}

// --- Main Execution ---

function main() {
    // Use current directory as default, or first command-line argument
    const projectDir = path.resolve(process.argv[2] || '.');
    const outputFilePath = path.join(projectDir, OUTPUT_FILE); // Output in the project dir

    console.log(`Scanning project directory: ${projectDir}`);
    console.log(`Output will be written to: ${outputFilePath}`);

    if (!fs.existsSync(projectDir) || !fs.statSync(projectDir).isDirectory()) {
        console.error(`Error: Project directory not found or is not a directory: ${projectDir}`);
        process.exit(1);
    }

    // 1. Gather all files first to know what will be included in the content
    const includedFilesMap = gatherFileContents(projectDir, projectDir); // Map { relativePath: absolutePath }
    const includedFileRelativePaths = new Set(includedFilesMap.keys()); // Set { relativePath } for quick lookup in tree generation

    // 2. Generate the project tree (pass the set of included files for potential filtering)
    console.log("Generating project tree...");
    const projectName = path.basename(projectDir);
    const projectTree = `${projectName}/\n` + generateTree(projectDir, projectDir, '', includedFileRelativePaths);


    // 3. Read and combine file contents
    console.log(`Reading content of ${includedFilesMap.size} files...`);
    let combinedContent = '';
    const sortedRelativePaths = Array.from(includedFilesMap.keys()).sort(); // Sort for consistent order

    for (const relativePath of sortedRelativePaths) {
        const absolutePath = includedFilesMap.get(relativePath);
        try {
            const content = fs.readFileSync(absolutePath, 'utf8');
            combinedContent += `// ----- File: ${relativePath} -----\n\n`;
            combinedContent += content;
            combinedContent += '\n\n// ----- End File: ' + relativePath + ' -----\n\n';
        } catch (err) {
            console.warn(`Warning: Could not read file ${absolutePath}. Skipping. Error: ${err.message}`);
            combinedContent += `// ----- File: ${relativePath} -----\n\n`;
            combinedContent += `// ***** Error reading file: ${err.message} *****\n\n`;
             combinedContent += '// ----- End File: ' + relativePath + ' -----\n\n';
        }
    }

    // 4. Combine tree and content
    const finalOutput = `--- Project Tree ---\n\n${projectTree}\n\n--- File Contents ---\n\n${combinedContent}`;

    // 5. Write to output file
    console.log(`Writing combined output to ${outputFilePath}...`);
    try {
        fs.writeFileSync(outputFilePath, finalOutput, 'utf8');
        console.log('Done!');
    } catch (err) {
        console.error(`Error writing output file ${outputFilePath}: ${err.message}`);
        process.exit(1);
    }
}

main();

// ----- End File: combine_project.js -----

// ----- File: package.json -----

{
  "name": "route-trace-app",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@mui/icons-material": "^7.0.2",
    "@mui/material": "^7.0.2",
    "@reduxjs/toolkit": "^2.6.1",
    "@testing-library/dom": "^10.4.0",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^13.5.0",
    "axios": "^1.8.4",
    "date-fns": "^4.1.0",
    "js-cookie": "^3.0.5",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "react-redux": "^9.2.0",
    "react-router-dom": "^7.5.0",
    "react-scripts": "5.0.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}


// ----- End File: package.json -----

// ----- File: public\index.html -----

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="RouteTrace Network Utility"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!-- Material UI Fonts -->
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
    />
    <title>RouteTrace</title>
    <style>
      body {
        margin: 0;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
          'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
          sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        background-color: #f4f6f8; /* Light grey background */
      }
    </style>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>

// ----- End File: public\index.html -----

// ----- File: public\manifest.json -----

{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}


// ----- End File: public\manifest.json -----

// ----- File: public\robots.txt -----

# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:


// ----- End File: public\robots.txt -----

// ----- File: src\App.css -----

.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}


// ----- End File: src\App.css -----

// ----- File: src\App.js -----

import React from 'react';
import { Routes, Route, Navigate, useLocation } from 'react-router-dom';
import { Box, Container } from '@mui/material';
import LoginPage from './pages/LoginPage';
import RouteTracePage from './pages/RouteTracePage';
import HistoryPage from './pages/HistoryPage';
import AllRoutesPage from './pages/AllRoutesPage';
import NotFoundPage from './pages/NotFoundPage';
import Navbar from './components/Common/Navbar';
import { useAuth } from './hooks/useAuth';
import { useSelector } from 'react-redux';

function ProtectedRoute({ children }) {
  const { isAuthenticated } = useAuth();
  const location = useLocation();

  if (!isAuthenticated) {
    // Redirect them to the /login page, but save the current location they were
    // trying to go to. This allows us to send them back after login.
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return children;
}

function App() {
  const { isAuthenticated } = useAuth(); // Get auth status for Navbar conditional rendering

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', minHeight: '100vh' }}>
      {isAuthenticated && <Navbar />} {/* Show Navbar only when logged in */}
      {/* Use Container to constrain max width and center content */}
      <Container component="main" maxWidth="xl" sx={{ flexGrow: 1, py: 3, mt: isAuthenticated ? 8 : 0 }}> {/* Add margin-top if Navbar exists (64px + padding) */}
        <Routes>
          <Route path="/login" element={<LoginPage />} />
          <Route
            path="/"
            element={
              <ProtectedRoute>
                <RouteTracePage />
              </ProtectedRoute>
            }
          />
          <Route
            path="/history"
            element={
              <ProtectedRoute>
                <HistoryPage />
              </ProtectedRoute>
            }
          />
           <Route
            path="/all-routes"
            element={
              <ProtectedRoute>
                {/* Add role check here if needed in future */}
                <AllRoutesPage />
              </ProtectedRoute>
            }
          />
          <Route path="*" element={<NotFoundPage />} />
        </Routes>
      </Container>
    </Box>
  );
}

export default App;

// ----- End File: src\App.js -----

// ----- File: src\App.test.js -----

import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});


// ----- End File: src\App.test.js -----

// ----- File: src\components\Auth\LoginForm.jsx -----

import React, { useState, useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { useNavigate, useLocation } from 'react-router-dom';
import { TextField, Button, Box, Typography, CircularProgress, Alert } from '@mui/material';
import { loginUser, resetAuthError } from '../../store/slices/authSlice';

const LoginForm = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const dispatch = useDispatch();
  const navigate = useNavigate();
  const location = useLocation();
  const { loading, error, isAuthenticated } = useSelector((state) => state.auth);

  const from = location.state?.from?.pathname || "/"; // Redirect path after login

  // Redirect if already logged in
  useEffect(() => {
      if (isAuthenticated) {
          navigate(from, { replace: true });
      }
  }, [isAuthenticated, navigate, from]);

  // Clear error when component mounts or unmounts
  useEffect(() => {
      dispatch(resetAuthError());
      return () => {
          dispatch(resetAuthError());
      };
  }, [dispatch]);


  const handleSubmit = (e) => {
    e.preventDefault();
    if (!username || !password) return; // Basic validation
    dispatch(loginUser({ username, password }))
      .unwrap() // Allows chaining .then() and .catch() on the dispatch
      .then(() => {
        navigate(from, { replace: true }); // Redirect on successful login
      })
      .catch((err) => {
        // Error is already handled by the slice and displayed via useSelector
        console.error("Login failed:", err);
      });
  };

  return (
    <Box
      component="form"
      onSubmit={handleSubmit}
      sx={{
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        maxWidth: 400,
        margin: 'auto',
        mt: 8,
        p: 3,
        boxShadow: 3,
        borderRadius: 2,
        bgcolor: 'background.paper'
      }}
    >
      <Typography variant="h5" component="h1" gutterBottom>
        Login
      </Typography>
      {error && <Alert severity="error" sx={{ width: '100%', mb: 2 }}>{error}</Alert>}
      <TextField
        label="Username"
        variant="outlined"
        margin="normal"
        required
        fullWidth
        value={username}
        onChange={(e) => setUsername(e.target.value)}
        disabled={loading}
      />
      <TextField
        label="Password"
        type="password"
        variant="outlined"
        margin="normal"
        required
        fullWidth
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        disabled={loading}
      />
      <Button
        type="submit"
        variant="contained"
        color="primary"
        fullWidth
        disabled={loading}
        sx={{ mt: 3, mb: 2, position: 'relative' }}
      >
        {loading ? <CircularProgress size={24} sx={{
             position: 'absolute',
             top: '50%',
             left: '50%',
             marginTop: '-12px',
             marginLeft: '-12px',
        }}/> : 'Login'}
      </Button>
    </Box>
  );
};

export default LoginForm;

// ----- End File: src\components\Auth\LoginForm.jsx -----

// ----- File: src\components\Common\ErrorMessage.jsx -----

import React from 'react';
import { Alert, AlertTitle } from '@mui/material';

const ErrorMessage = ({ error, title = "Error" }) => {
  if (!error) return null;

  const message = typeof error === 'string' ? error : error.message || 'An unexpected error occurred.';

  return (
    <Alert severity="error" sx={{ mt: 2, mb: 2 }}>
      <AlertTitle>{title}</AlertTitle>
      {message}
    </Alert>
  );
};

export default ErrorMessage;

// ----- End File: src\components\Common\ErrorMessage.jsx -----

// ----- File: src\components\Common\LoadingSpinner.jsx -----

import React from 'react';
import { Box, CircularProgress } from '@mui/material';

const LoadingSpinner = ({ size = 40 }) => (
  <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', p: 2 }}>
    <CircularProgress size={size} />
  </Box>
);

export default LoadingSpinner;

// ----- End File: src\components\Common\LoadingSpinner.jsx -----

// ----- File: src\components\Common\Navbar.jsx -----

import React from 'react';
import { useDispatch } from 'react-redux';
import { Link as RouterLink, useNavigate } from 'react-router-dom';
import { AppBar, Toolbar, Typography, Button, Box, IconButton } from '@mui/material';
import AccountTreeIcon from '@mui/icons-material/AccountTree'; // Example icon
import { logoutUser } from '../../store/slices/authSlice';

const Navbar = () => {
  const dispatch = useDispatch();
  const navigate = useNavigate();

  const handleLogout = () => {
    dispatch(logoutUser());
    navigate('/login'); // Redirect to login after logout
  };

  return (
    <AppBar position="fixed">
      <Toolbar>
         <IconButton
          size="large"
          edge="start"
          color="inherit"
          aria-label="logo"
          component={RouterLink}
          to="/"
          sx={{ mr: 1 }}
        >
          <AccountTreeIcon />
        </IconButton>
        <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
          RouteTrace
        </Typography>
        <Box sx={{ '& button': { ml: 1 } }}>
             <Button color="inherit" component={RouterLink} to="/">
                 Trace Route
            </Button>
             <Button color="inherit" component={RouterLink} to="/history">
                 My History
            </Button>
              <Button color="inherit" component={RouterLink} to="/all-routes">
                 All Routes
            </Button>
            <Button color="inherit" onClick={handleLogout}>
                Logout
            </Button>
        </Box>
      </Toolbar>
    </AppBar>
  );
};

export default Navbar;

// ----- End File: src\components\Common\Navbar.jsx -----

// ----- File: src\components\History\HistoryItem.jsx -----

import React, { useState } from 'react';
import { ListItem, ListItemText, Collapse, IconButton, Typography, Box, Paper, Stack, Chip } from '@mui/material';
import ExpandLess from '@mui/icons-material/ExpandLess';
import ExpandMore from '@mui/icons-material/ExpandMore';
import HopDisplay from '../RouteTrace/HopDisplay'; // Reuse HopDisplay
import { formatTimestamp } from '../../utils/formatters';

const HistoryItem = ({ route }) => {
  const [open, setOpen] = useState(false);
  const { id, source, destination, timestamp, routeData, deviceInfo, user } = route; // Assuming 'user' field available in 'all routes'

  const handleClick = () => {
    setOpen(!open);
  };

  // Basic check if routeData looks like a valid trace array
  const hasValidRouteData = Array.isArray(routeData) && routeData.length > 0 && typeof routeData[0] === 'object';

  return (
    <>
      <ListItem button onClick={handleClick} divider>
        <ListItemText
          primary={
              <Stack direction="row" justifyContent="space-between" alignItems="center">
                  <Typography variant="body1">
                      <Chip label="Src" size="small" color="primary" sx={{ mr: 1}} />{source || 'N/A'}
                      <Typography component="span" sx={{ mx: 1 }}>→</Typography>
                      <Chip label="Dst" size="small" color="secondary" sx={{ mr: 1}} />{destination || 'N/A'}
                  </Typography>
                  {user && <Typography variant="caption" color="text.secondary">User: {user.username}</Typography>}
             </Stack>
            }
          secondary={`Traced on: ${formatTimestamp(timestamp)} (ID: ${id})`}
        />
        {hasValidRouteData ? (open ? <ExpandLess /> : <ExpandMore />) : null }
      </ListItem>
      {hasValidRouteData && (
          <Collapse in={open} timeout="auto" unmountOnExit>
            <Paper sx={{ p: 2, m: 1, bgcolor: 'grey.50' }}>
                <Typography variant="h6" gutterBottom>Detailed Route</Typography>
                {deviceInfo && (
                    <Box mb={2}>
                        <Typography variant="subtitle2">Device Info:</Typography>
                        <pre style={{fontSize: '0.8rem', background: '#eee', padding: '5px', borderRadius: '4px', overflowX: 'auto'}}>{JSON.stringify(deviceInfo, null, 2)}</pre>
                    </Box>
                )}
                <Stack
                  direction="row"
                  spacing={0}
                  alignItems="flex-start"
                  sx={{
                    overflowX: 'auto', // Enable horizontal scrolling
                    py: 2,
                    px: 1,
                    borderTop: '1px dashed',
                    borderColor: 'divider',
                  }}
                >
                 {routeData.map((hop, index) => (
                    <HopDisplay
                        key={hop.hop || index}
                        hopData={hop}
                        isFirst={index === 0}
                        isLast={index === routeData.length - 1}
                    />
                 ))}
                </Stack>
            </Paper>
          </Collapse>
      )}
      {!hasValidRouteData && open && (
           <Collapse in={open} timeout="auto" unmountOnExit>
                <Paper sx={{ p: 2, m: 1, bgcolor: 'grey.50' }}>
                    <Typography color="text.secondary">No detailed route hops available for this entry.</Typography>
                     {routeData && <pre style={{fontSize: '0.8rem', background: '#eee', padding: '5px', borderRadius: '4px', overflowX: 'auto'}}>{JSON.stringify(routeData, null, 2)}</pre>}
                </Paper>
           </Collapse>
      )}
    </>
  );
};

export default HistoryItem;

// ----- End File: src\components\History\HistoryItem.jsx -----

// ----- File: src\components\History\HistoryList.jsx -----

import React from 'react';
import { List, Typography, Paper } from '@mui/material';
import HistoryItem from './HistoryItem';

const HistoryList = ({ routes, title = "Route History" }) => {
  if (!routes || routes.length === 0) {
    return <Typography sx={{ mt: 3, textAlign: 'center' }} color="text.secondary">No history found.</Typography>;
  }

  return (
    <Paper elevation={1} sx={{ mt: 2 }}>
        <Typography variant="h5" component="h2" sx={{ p: 2 }}>{title}</Typography>
        <List component="nav" aria-label="route history">
        {routes.map((route) => (
            <HistoryItem key={route.id} route={route} />
        ))}
        </List>
    </Paper>
  );
};

export default HistoryList;

// ----- End File: src\components\History\HistoryList.jsx -----

// ----- File: src\components\RouteTrace\HopDisplay.jsx -----

import React from 'react';
import { Paper, Typography, Box, Chip } from '@mui/material';
import ArrowForwardIcon from '@mui/icons-material/ArrowForward';

const HopDisplay = ({ hopData, isFirst, isLast }) => {
  // Assuming hopData structure like { hop: number, ip: string, name: string, type: string }
  // Type might indicate firewall, router etc. - adjust as needed based on backend output
  const { hop, ip, name, type } = hopData;

  return (
    <Box sx={{ display: 'flex', alignItems: 'center' }}>
       {!isFirst && <ArrowForwardIcon sx={{ mx: 1, color: 'text.secondary' }} />}
      <Paper elevation={2} sx={{ p: 1.5, minWidth: 150, textAlign: 'center' }}>
          <Typography variant="caption" display="block" gutterBottom>Hop {hop}</Typography>
          <Typography variant="body1" sx={{ fontWeight: 'bold' }}>{ip || 'N/A'}</Typography>
          <Typography variant="body2" sx={{ color: 'text.secondary' }}>{name || 'Unknown Host'}</Typography>
          {type && <Chip label={type} size="small" sx={{ mt: 1 }} />}
      </Paper>
    </Box>
  );
};

export default HopDisplay;

// ----- End File: src\components\RouteTrace\HopDisplay.jsx -----

// ----- File: src\components\RouteTrace\MacTraceDisplay.jsx -----

// ----- File: src/components/RouteTrace/MacTraceDisplay.jsx -----

import React from 'react';
import { Paper, Typography, Box, Stack } from '@mui/material';
import CompareArrowsIcon from '@mui/icons-material/CompareArrows';
import LoadingSpinner from '../Common/LoadingSpinner';
import ErrorMessage from '../Common/ErrorMessage';
import HopDisplay from './HopDisplay'; // Reuse HopDisplay

const MacTraceDisplay = ({ label, hops, isLoading, error }) => {
  // hops is now expected to be an array like [{hop: 1, ip: 'mac/ip', name: 'dev', type: 'L2/L3'}, ...] or null/undefined

  return (
    <Paper elevation={1} sx={{ p: 2, my: 1, bgcolor: 'grey.100' }}>
      <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 1, mb: 1 }}>
        <CompareArrowsIcon fontSize="small" color="action" />
        <Typography variant="overline">{label}</Typography>
      </Box>

      {isLoading && <LoadingSpinner size={25} />}
      {error && <ErrorMessage error={error} title="MAC Trace Error" />}

      {!isLoading && !error && (
        <>
          {hops === null || hops === undefined ? (
            <Typography variant="caption" display="block" align="center">MAC Trace Pending</Typography>
          ) : hops.length === 0 ? (
            <Typography variant="caption" display="block" align="center">No MAC trace hops found.</Typography>
          ) : (
            <Stack
              direction="row"
              spacing={0} // Let HopDisplay handle spacing
              alignItems="flex-start"
              sx={{
                overflowX: 'auto', // Enable horizontal scrolling
                py: 1,
                px: 1,
              }}
            >
              {hops.map((hop, index) => (
                <HopDisplay
                  key={hop.hop || index} // Use hop number or index as key
                  hopData={hop}
                  isFirst={index === 0}
                  isLast={index === hops.length - 1}
                />
              ))}
            </Stack>
          )}
        </>
      )}
    </Paper>
  );
};

export default MacTraceDisplay;

// ----- End File: src/components/RouteTrace/MacTraceDisplay.jsx -----

// ----- End File: src\components\RouteTrace\MacTraceDisplay.jsx -----

// ----- File: src\components\RouteTrace\RouteComparisonContainer.jsx -----

import React from 'react';
import { useSelector } from 'react-redux';
import { Box, Grid } from '@mui/material';
import RouteTraceSection from './RouteTraceSection';

const RouteComparisonContainer = () => {
  const traces = useSelector((state) => state.routeTrace.traces);
  const canRemove = traces.length > 1;

  // Determine grid sizing based on number of traces
  let mdSize = 12;
  if (traces.length === 2) mdSize = 6;
  if (traces.length >= 3) mdSize = 4; // Max 3 side-by-side on medium screens

  return (
    <Box>
      <Grid container spacing={3}>
        {traces.map((trace) => (
          <Grid item xs={12} md={mdSize} key={trace.id}>
             <RouteTraceSection trace={trace} canRemove={canRemove} />
          </Grid>
        ))}
      </Grid>
    </Box>
  );
};

export default RouteComparisonContainer;

// ----- End File: src\components\RouteTrace\RouteComparisonContainer.jsx -----

// ----- File: src\components\RouteTrace\RouteInputForm.jsx -----

import React from 'react';
import { useDispatch } from 'react-redux';
import { TextField, Button, Box, Grid, CircularProgress, Tooltip, IconButton } from '@mui/material'; // Remove Typography from here later
import TravelExploreIcon from '@mui/icons-material/TravelExplore';
import SyncIcon from '@mui/icons-material/Sync';
import SyncProblemIcon from '@mui/icons-material/SyncProblem';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import EditIcon from '@mui/icons-material/Edit';
import { updateTraceInput, fetchDefaultGateway, performFullTrace } from '../../store/slices/routeTraceSlice';
import ErrorMessage from '../Common/ErrorMessage'; // <<<--- ADD THIS LINE

const RouteInputForm = ({ trace }) => {
  const dispatch = useDispatch();
  const {
    id: traceId,
    sourceIp, destinationIp, sourceDg, destinationDg,
    sourceDgStatus, destinationDgStatus, traceStatus, error
  } = trace;

  const handleInputChange = (field) => (event) => {
    dispatch(updateTraceInput({ traceId, field, value: event.target.value }));
  };

  const handleFetchDg = (type) => () => {
    const ip = type === 'source' ? sourceIp : destinationIp;
    if (ip) {
      dispatch(fetchDefaultGateway({ ip, type, traceId }));
    }
  };

  const handleTrace = () => {
    dispatch(performFullTrace({ traceId, sourceIp, destinationIp, sourceDg, destinationDg }));
  };

  const isFetchingSourceDg = sourceDgStatus === 'loading';
  const isFetchingDestDg = destinationDgStatus === 'loading';
  const isTracing = traceStatus === 'loading';

  // Determine if DG field should be disabled
  // Disable if loading, allow edit if succeeded, failed, or manual
  const sourceDgDisabled = isFetchingSourceDg;
  const destDgDisabled = isFetchingDestDg;

  const renderDgStatusIcon = (status) => {
    switch (status) {
      case 'loading':
        return <CircularProgress size={20} />;
      case 'succeeded':
        return <Tooltip title="Gateway Fetched"><CheckCircleIcon color="success" /></Tooltip>;
      case 'failed':
        return <Tooltip title="Failed to Fetch Gateway"><SyncProblemIcon color="error" /></Tooltip>;
      case 'manual':
         return <Tooltip title="Manually Entered"><EditIcon color="action" /></Tooltip>;
      default: // idle
        return null;
    }
  };

   // Show DG fetch error specifically
   const dgError = error && (sourceDgStatus === 'failed' || destinationDgStatus === 'failed');

  return (
    <Box sx={{ mb: 3 }}>
        {dgError && <ErrorMessage error={error} title="Gateway Fetch Error" />}
        <Grid container spacing={2} alignItems="flex-start"> {/* Use alignItems="flex-start" */}
            {/* Source IP */}
            <Grid item xs={12} sm={6} md={3}>
                <TextField
                    label="Source IP"
                    value={sourceIp}
                    onChange={handleInputChange('sourceIp')}
                    onBlur={handleFetchDg('source')} // Trigger fetch on blur
                    variant="outlined"
                    fullWidth
                    required
                    disabled={isTracing}
                />
            </Grid>

             {/* Source DG */}
            <Grid item xs={10} sm={5} md={2}>
                 <TextField
                    label="Source DG"
                    value={sourceDg}
                    onChange={handleInputChange('sourceDg')}
                    variant="outlined"
                    fullWidth
                    required
                    disabled={sourceDgDisabled || isTracing}
                    InputProps={{
                        endAdornment: renderDgStatusIcon(sourceDgStatus),
                    }}
                 />
            </Grid>
            <Grid item xs={2} sm={1} md={1} sx={{display: 'flex', alignItems: 'center', height: '56px' }}> {/* Match TextField height */}
                 <Tooltip title="Re-fetch Source Gateway">
                     <span> {/* Span needed for tooltip on disabled button */}
                        <IconButton onClick={handleFetchDg('source')} disabled={!sourceIp || isFetchingSourceDg || isTracing} size="small">
                            <SyncIcon />
                        </IconButton>
                     </span>
                 </Tooltip>
            </Grid>


            {/* Destination IP */}
            <Grid item xs={12} sm={6} md={3}>
                <TextField
                    label="Destination IP"
                    value={destinationIp}
                    onChange={handleInputChange('destinationIp')}
                    onBlur={handleFetchDg('destination')} // Trigger fetch on blur
                    variant="outlined"
                    fullWidth
                    required
                    disabled={isTracing}
                 />
            </Grid>

             {/* Destination DG */}
            <Grid item xs={10} sm={5} md={2}>
                 <TextField
                    label="Destination DG"
                    value={destinationDg}
                    onChange={handleInputChange('destinationDg')}
                    variant="outlined"
                    fullWidth
                    required
                    disabled={destDgDisabled || isTracing}
                    InputProps={{
                         endAdornment: renderDgStatusIcon(destinationDgStatus),
                    }}
                />
            </Grid>
             <Grid item xs={2} sm={1} md={1} sx={{display: 'flex', alignItems: 'center', height: '56px'}}>
                 <Tooltip title="Re-fetch Destination Gateway">
                     <span>
                        <IconButton onClick={handleFetchDg('destination')} disabled={!destinationIp || isFetchingDestDg || isTracing} size="small">
                            <SyncIcon />
                        </IconButton>
                     </span>
                 </Tooltip>
            </Grid>


        </Grid>
        <Box sx={{ display: 'flex', justifyContent: 'center', mt: 3 }}>
            <Button
                variant="contained"
                color="primary"
                size="large"
                startIcon={isTracing ? <CircularProgress size={20} color="inherit" /> : <TravelExploreIcon />}
                onClick={handleTrace}
                disabled={!sourceIp || !destinationIp || !sourceDg || !destinationDg || isTracing || isFetchingSourceDg || isFetchingDestDg}
            >
                {isTracing ? 'Tracing...' : 'Trace Route'}
            </Button>
        </Box>
    </Box>
  );
};

export default RouteInputForm;

// ----- End File: src\components\RouteTrace\RouteInputForm.jsx -----

// ----- File: src\components\RouteTrace\RouteTraceSection.jsx -----

import React from 'react';
import { Paper, Box, IconButton, Tooltip } from '@mui/material';
import CloseIcon from '@mui/icons-material/Close';
import RouteInputForm from './RouteInputForm';
import RouteVisualizer from './RouteVisualizer';
import { useDispatch } from 'react-redux';
import { removeTraceSection } from '../../store/slices/routeTraceSlice';

const RouteTraceSection = ({ trace, canRemove }) => {
  const dispatch = useDispatch();

  const handleRemove = () => {
      if (canRemove) {
          dispatch(removeTraceSection(trace.id));
      }
  }

  return (
    <Paper elevation={2} sx={{ p: 2, mb: 3, position: 'relative' }}>
        {canRemove && (
            <Tooltip title="Remove this trace section">
                <IconButton
                    onClick={handleRemove}
                    size="small"
                    sx={{ position: 'absolute', top: 8, right: 8 }}
                >
                    <CloseIcon />
                </IconButton>
            </Tooltip>
        )}
        <RouteInputForm trace={trace} />
        <RouteVisualizer trace={trace} />
    </Paper>
  );
};

export default RouteTraceSection;

// ----- End File: src\components\RouteTrace\RouteTraceSection.jsx -----

// ----- File: src\components\RouteTrace\RouteVisualizer.jsx -----

// ----- File: src/components/RouteTrace/RouteVisualizer.jsx -----

import React from 'react';
import { Box, Typography, Stack, Paper } from '@mui/material';
import LoadingSpinner from '../Common/LoadingSpinner';
import ErrorMessage from '../Common/ErrorMessage';
import HopDisplay from './HopDisplay';
import MacTraceDisplay from './MacTraceDisplay';

const RouteVisualizer = ({ trace }) => {
  const {
    sourceIp, destinationIp, sourceDg, destinationDg,
    mainRouteTrace, sourceMacTrace, destinationMacTrace,
    traceStatus, sourceDgStatus, destinationDgStatus, error
  } = trace;

  if (traceStatus === 'loading') {
    return <LoadingSpinner />;
  }

  // Only show main trace error here, DG errors are shown in the input form
  const mainTraceError = error && (traceStatus === 'failed' || (traceStatus === 'partial_success' && !mainRouteTrace));

  return (
    <Paper elevation={0} sx={{ mt: 3, p: 2, border: '1px solid', borderColor: 'divider', borderRadius: 1 }}>
      <Typography variant="h6" gutterBottom align="center">Trace Results</Typography>

      {/* Display overall error only if the main trace failed */}
      {mainTraceError && <ErrorMessage error={error} title="Main Trace Problem" />}


      {(traceStatus === 'succeeded' || traceStatus === 'partial_success' || traceStatus === 'failed') && (
        <Box>
          {/* 1. Source IP Box */}
           <Paper elevation={2} sx={{ p: 1.5, mb: 1, textAlign: 'center', bgcolor: 'primary.light', color: 'primary.contrastText' }}>
              <Typography variant="overline">Source</Typography>
              <Typography variant="body1">{sourceIp}</Typography>
          </Paper>

          {/* 2. Source MAC Trace */}
          <MacTraceDisplay
            label={`${sourceIp} <-> ${sourceDg}`}
            hops={sourceMacTrace} // Pass the array of hops
            isLoading={traceStatus === 'loading'}
            // Pass specific error if source MAC trace failed during partial success, otherwise let MacTraceDisplay show the generic error if overall status is 'failed'
            error={(traceStatus === 'partial_success' || traceStatus === 'failed') && !sourceMacTrace ? (error || "Failed to retrieve source MAC trace") : null}
           />

           {/* 3. Source DG Box */}
           <Paper elevation={2} sx={{ p: 1.5, my: 1, textAlign: 'center' }}>
              <Typography variant="overline">Source DG</Typography>
              <Typography variant="body1">{sourceDg}</Typography>
           </Paper>


          {/* 4. Main Route Hops */}
          {mainRouteTrace && mainRouteTrace.length > 0 ? (
            <Stack
              direction="row"
              spacing={0} // Let HopDisplay handle spacing with icons
              alignItems="flex-start" // Align tops of papers
              sx={{
                overflowX: 'auto', // Enable horizontal scrolling for many hops
                py: 2,
                px: 1, // Padding for scroll container
                borderTop: '1px dashed',
                borderBottom: '1px dashed',
                borderColor: 'divider',
                my: 2,
              }}
            >
              {mainRouteTrace.map((hop, index) => (
                <HopDisplay
                  key={hop.hop || index}
                  hopData={hop}
                  isFirst={index === 0}
                  isLast={index === mainRouteTrace.length - 1}
                />
              ))}
            </Stack>
          ) : (
             traceStatus !== 'idle' && traceStatus !== 'loading' && !mainTraceError && ( // Show message only if main trace didn't fail outright
                <Typography align="center" color="text.secondary" sx={{ my: 3 }}>
                    {mainRouteTrace === null ? 'Main route trace did not run or failed.' : 'No hops returned for main route.'}
                </Typography>
             )
          )}

           {/* 5. Destination DG Box */}
           <Paper elevation={2} sx={{ p: 1.5, my: 1, textAlign: 'center' }}>
              <Typography variant="overline">Destination DG</Typography>
              <Typography variant="body1">{destinationDg}</Typography>
           </Paper>

          {/* 6. Destination MAC Trace */}
          <MacTraceDisplay
            label={`${destinationDg} <-> ${destinationIp}`}
            hops={destinationMacTrace} // Pass the array of hops
            isLoading={traceStatus === 'loading'}
            error={(traceStatus === 'partial_success' || traceStatus === 'failed') && !destinationMacTrace ? (error || "Failed to retrieve destination MAC trace") : null}
           />

            {/* 7. Destination IP Box */}
           <Paper elevation={2} sx={{ p: 1.5, mt: 1, textAlign: 'center', bgcolor: 'secondary.light', color: 'secondary.contrastText' }}>
              <Typography variant="overline">Destination</Typography>
              <Typography variant="body1">{destinationIp}</Typography>
           </Paper>

        </Box>
      )}
      {traceStatus === 'idle' && !error && ( <Typography align="center" color="text.secondary">Enter details and click 'Trace Route' to see results.</Typography>
      )}
    </Paper>
  );
};

export default RouteVisualizer;

// ----- End File: src/components/RouteTrace/RouteVisualizer.jsx -----

// ----- End File: src\components\RouteTrace\RouteVisualizer.jsx -----

// ----- File: src\hooks\useAuth.js -----

import { useSelector } from 'react-redux';

export const useAuth = () => {
  const { user, isAuthenticated, loading, error } = useSelector((state) => state.auth);
  return { user, isAuthenticated, loading, error };
};

// ----- End File: src\hooks\useAuth.js -----

// ----- File: src\index.css -----

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}


// ----- End File: src\index.css -----

// ----- File: src\index.js -----

import React from 'react';
import ReactDOM from 'react-dom/client';
import { Provider } from 'react-redux';
import { BrowserRouter } from 'react-router-dom';
import { ThemeProvider, createTheme, CssBaseline } from '@mui/material';
import App from './App';
import store from './store/store';

// Basic MUI theme (customize as needed)
const theme = createTheme({
  palette: {
    // Add custom theme colors if desired
  },
});

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <Provider store={store}>
      <ThemeProvider theme={theme}>
        <CssBaseline /> {/* Normalize CSS and apply background */}
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </ThemeProvider>
    </Provider>
  </React.StrictMode>
);

// ----- End File: src\index.js -----

// ----- File: src\pages\AllRoutesPage.jsx -----

import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { Typography, Box } from '@mui/material';
import HistoryList from '../components/History/HistoryList';
import LoadingSpinner from '../components/Common/LoadingSpinner';
import ErrorMessage from '../components/Common/ErrorMessage';
import { fetchAllHistory, resetHistoryError } from '../store/slices/historySlice';

const AllRoutesPage = () => {
  const dispatch = useDispatch();
  const { allHistory, allHistoryStatus, error } = useSelector((state) => state.history);

  useEffect(() => {
    if (allHistoryStatus === 'idle') {
      dispatch(fetchAllHistory());
    }
     // Clear errors when component unmounts
     return () => {
        dispatch(resetHistoryError());
    }
  }, [allHistoryStatus, dispatch]);

  return (
    <Box>
      {allHistoryStatus === 'loading' && <LoadingSpinner />}
      {allHistoryStatus === 'failed' && <ErrorMessage error={error} title="Could not load all routes"/>}
      {allHistoryStatus === 'succeeded' && (
         // Pass the user object if backend includes it: route.user.username
        <HistoryList routes={allHistory} title="All User Routes" />
      )}
    </Box>
  );
};

export default AllRoutesPage;

// ----- End File: src\pages\AllRoutesPage.jsx -----

// ----- File: src\pages\HistoryPage.jsx -----

import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { Typography, Box } from '@mui/material';
import HistoryList from '../components/History/HistoryList';
import LoadingSpinner from '../components/Common/LoadingSpinner';
import ErrorMessage from '../components/Common/ErrorMessage';
import { fetchUserHistory, resetHistoryError } from '../store/slices/historySlice';

const HistoryPage = () => {
  const dispatch = useDispatch();
  const { userHistory, userHistoryStatus, error } = useSelector((state) => state.history);

  useEffect(() => {
    // Fetch history only if it's not already loaded or loading
    if (userHistoryStatus === 'idle') {
      dispatch(fetchUserHistory());
    }
    // Clear errors when component unmounts
    return () => {
        dispatch(resetHistoryError());
    }
  }, [userHistoryStatus, dispatch]);

  return (
    <Box>
      {userHistoryStatus === 'loading' && <LoadingSpinner />}
      {userHistoryStatus === 'failed' && <ErrorMessage error={error} title="Could not load history"/>}
      {userHistoryStatus === 'succeeded' && (
        <HistoryList routes={userHistory} title="My Route History" />
      )}
    </Box>
  );
};

export default HistoryPage;

// ----- End File: src\pages\HistoryPage.jsx -----

// ----- File: src\pages\LoginPage.jsx -----

import React from 'react';
import LoginForm from '../components/Auth/LoginForm';

const LoginPage = () => {
  // Optional: Add any surrounding layout or elements specific to the login page
  return <LoginForm />;
};

export default LoginPage;

// ----- End File: src\pages\LoginPage.jsx -----

// ----- File: src\pages\NotFoundPage.jsx -----

import React from 'react';
import { Typography, Box, Button } from '@mui/material';
import { Link as RouterLink } from 'react-router-dom';

const NotFoundPage = () => (
  <Box sx={{ textAlign: 'center', mt: 8 }}>
    <Typography variant="h3" component="h1" gutterBottom>
      404 - Page Not Found
    </Typography>
    <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
      Sorry, the page you are looking for does not exist.
    </Typography>
    <Button variant="contained" component={RouterLink} to="/">
      Go to Homepage
    </Button>
  </Box>
);

export default NotFoundPage;

// ----- End File: src\pages\NotFoundPage.jsx -----

// ----- File: src\pages\RouteTracePage.jsx -----

import React from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { Button, Box, Typography } from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import RouteComparisonContainer from '../components/RouteTrace/RouteComparisonContainer';
import { addTraceSection } from '../store/slices/routeTraceSlice';

const RouteTracePage = () => {
    const dispatch = useDispatch();
    const traces = useSelector((state) => state.routeTrace.traces);

    const handleAddRoute = () => {
        dispatch(addTraceSection());
    }

  return (
    <Box>
      <Typography variant="h4" component="h1" gutterBottom>
        Trace Network Route
      </Typography>
      <RouteComparisonContainer />
       <Box sx={{ mt: 3, display: 'flex', justifyContent: 'center' }}>
            <Button
                variant="outlined"
                startIcon={<AddIcon />}
                onClick={handleAddRoute}
                disabled={traces.length >= 5} // Optional limit
            >
                Add Route for Comparison
            </Button>
       </Box>
    </Box>
  );
};

export default RouteTracePage;

// ----- End File: src\pages\RouteTracePage.jsx -----

// ----- File: src\reportWebVitals.js -----

const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;


// ----- End File: src\reportWebVitals.js -----

// ----- File: src\services\api.js -----

import axios from 'axios';
import Cookies from 'js-cookie';

const API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:8000'; // Fallback

const apiClient = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Interceptor to add the auth token to requests
apiClient.interceptors.request.use(
  (config) => {
    const token = Cookies.get('authToken'); // Read token from cookie
    if (token) {
      // Assuming the backend expects the token in an 'Authorization: Bearer <token>' header
      // Adjust 'token' header name if backend expects something different (e.g., 'x-token')
      config.headers['token'] = token; // Use 'Authorization': `Bearer ${token}` if that's the standard used
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Optional: Interceptor to handle 401 Unauthorized errors globally
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response && error.response.status === 401) {
      // Token is invalid or expired
      Cookies.remove('authToken');
      // Optionally redirect to login or dispatch a logout action
      // window.location.href = '/login'; // Hard redirect
      // store.dispatch(logout()); // If you have a logout action
      console.error("Authentication Error: Token invalid or expired.");
    }
    return Promise.reject(error);
  }
);


export default apiClient;

// ----- End File: src\services\api.js -----

// ----- File: src\services\authService.js -----

import apiClient from './api';
import Cookies from 'js-cookie';

// Matches the Python UserG model
const login = async (username, password) => {
  try {
    // Backend endpoint: /verify-device-auth
    // Backend expects: { username: "user", password: "pw" } in the body
    const response = await apiClient.post('/verify-device-auth', { username, password });
    const token = response.data; // Assuming the backend returns the token directly in the data

    if (token) {
      // Store token in cookie - Secure flag should be true in production (HTTPS)
      Cookies.set('authToken', token, { expires: 1, path: '/' /*, secure: true, sameSite: 'strict' */ });
      // You might want to fetch user details here if needed, or decode the token if it's a JWT
      // For now, we just store the token. The presence of the token implies logged in status.
      return { success: true, user: { username } }; // Return basic user info
    } else {
      throw new Error('No token received from server');
    }
  } catch (error) {
    console.error('Login failed:', error.response?.data || error.message);
    throw new Error(error.response?.data?.detail || 'Login failed');
  }
};

const logout = () => {
    Cookies.remove('authToken', { path: '/' });
    // No API call needed unless backend has session invalidation
};

const authService = {
  login,
  logout,
};

export default authService;

// ----- End File: src\services\authService.js -----

// ----- File: src\services\routeService.js -----

import apiClient from './api';

// Corresponds to get_default_gateway(ip: str)
const getDefaultGateway = async (ip) => {
    try {
        // Adjust endpoint if needed, e.g. '/network/default-gateway'
        // Pass IP as a query parameter named 'ip'
        const response = await apiClient.get('/get-default-gateway', { params: { ip } });
        // Assuming the backend returns the gateway IP directly or in a specific field
        // Example: return response.data.gateway;
        return response.data; // Modify based on actual backend response structure
    } catch (error) {
        console.error(`Failed to get default gateway for ${ip}:`, error.response?.data || error.message);
        throw new Error(error.response?.data?.detail || `Failed to get DG for ${ip}`);
    }
};

// Corresponds to get_mac_trace(ip: str, dg: str)
const getMacTrace = async (ip, dg) => {
     try {
        // Adjust endpoint if needed
        // Pass ip and dg as query parameters
        const response = await apiClient.get('/get-mac-trace', { params: { ip, dg } });
        // Assuming backend returns the MAC trace data (e.g., list of hops)
        return response.data; // Modify based on actual backend response structure
    } catch (error) {
        console.error(`Failed to get MAC trace for ${ip} -> ${dg}:`, error.response?.data || error.message);
        throw new Error(error.response?.data?.detail || `Failed to get MAC trace`);
    }
};

// Corresponds to get_route_trace (or potentially get_tufin_route - clarify which one to use)
// Using get_route_trace based on code snippets provided
const getRouteTrace = async (source_ip, destination_ip, source_dg = null, destination_dg = null, source_dg_name = null, destination_dg_name = null, vrf = null, destination_vrf = null) => {
    try {
        const params = {
            source_ip,
            destination_ip,
            // Add other params only if they have values
            ...(source_dg && { source_dg }),
            ...(destination_dg && { destination_dg }),
            ...(source_dg_name && { source_dg_name }),
            ...(destination_dg_name && { destination_dg_name }),
            ...(vrf && { vrf }),
            ...(destination_vrf && { destination_vrf }),
        };
        const response = await apiClient.get('/get-route-trace', { params });
         // Backend saves automatically, frontend just gets the result.
         // Assuming backend returns the full route trace data (e.g., list of hops)
        return response.data; // Modify based on actual backend response structure
    } catch (error) {
        console.error(`Failed to get route trace:`, error.response?.data || error.message);
        throw new Error(error.response?.data?.detail || `Failed to get route trace`);
    }
};


// Corresponds to get_user_routes() - uses POST in backend? Check method. Assuming POST for now.
const getUserRoutes = async () => {
    try {
        // Backend uses POST for get-user-routes, ensure token is sent via interceptor
        const response = await apiClient.post('/get-user-routes');
        // Assuming backend returns a list of routes
        // Response format likely: [{id, source, destination, route, timestamp, ...}, ...]
        return response.data; // Modify based on actual backend response structure
    } catch (error) {
        console.error(`Failed to get user routes:`, error.response?.data || error.message);
        throw new Error(error.response?.data?.detail || `Failed to get user routes`);
    }
};

// Corresponds to get_all_routes() - uses POST in backend? Check method. Assuming POST.
const getAllRoutes = async () => {
    try {
        // Backend uses POST for get-all-routes
        const response = await apiClient.post('/get-all-routes');
        // Assuming backend returns a list of all routes
        return response.data; // Modify based on actual backend response structure
    } catch (error) {
        console.error(`Failed to get all routes:`, error.response?.data || error.message);
        throw new Error(error.response?.data?.detail || `Failed to get all routes`);
    }
};


const routeService = {
    getDefaultGateway,
    getMacTrace,
    getRouteTrace,
    getUserRoutes,
    getAllRoutes,
};

export default routeService;

// ----- End File: src\services\routeService.js -----

// ----- File: src\setupTests.js -----

// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';


// ----- End File: src\setupTests.js -----

// ----- File: src\store\slices\authSlice.js -----

import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import authService from '../../services/authService';
import Cookies from 'js-cookie';

// Async thunk for login
export const loginUser = createAsyncThunk(
  'auth/loginUser',
  async ({ username, password }, { rejectWithValue }) => {
    try {
      const data = await authService.login(username, password);
      return data; // Should return { success: true, user: { username } }
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// Initial state checks if a token exists in cookies
const initialState = {
  user: null,
  isAuthenticated: !!Cookies.get('authToken'), // Check cookie on initial load
  loading: false,
  error: null,
};

const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    logoutUser: (state) => {
      authService.logout(); // Clear cookie
      state.user = null;
      state.isAuthenticated = false;
      state.loading = false;
      state.error = null;
    },
    resetAuthError: (state) => {
        state.error = null;
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(loginUser.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(loginUser.fulfilled, (state, action) => {
        state.loading = false;
        state.isAuthenticated = true;
        state.user = action.payload.user; // Store user info from payload
        state.error = null;
      })
      .addCase(loginUser.rejected, (state, action) => {
        state.loading = false;
        state.isAuthenticated = false;
        state.user = null;
        state.error = action.payload; // Error message from rejectWithValue
      });
  },
});

export const { logoutUser, resetAuthError } = authSlice.actions;
export default authSlice.reducer;

// ----- End File: src\store\slices\authSlice.js -----

// ----- File: src\store\slices\historySlice.js -----

import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import routeService from '../../services/routeService';

// Helper to safely parse JSON
const safeParseJson = (jsonString, defaultValue = null) => {
  if (typeof jsonString !== 'string') return jsonString; // Already parsed or not a string
  try {
    return JSON.parse(jsonString);
  } catch (e) {
    console.error("Failed to parse route JSON:", e);
    return defaultValue; // Return null or default if parsing fails
  }
};

// Async thunk for fetching user-specific route history
export const fetchUserHistory = createAsyncThunk(
  'history/fetchUserHistory',
  async (_, { rejectWithValue }) => {
    try {
      const routes = await routeService.getUserRoutes();
      // Assuming routes is an array: [{id, source, destination, route(json_string), timestamp, device_additional_info(json_string? check model), ...}, ...]
      return routes.map(r => ({
        ...r,
        // Parse potentially nested JSON strings
        routeData: safeParseJson(r.route),
        deviceInfo: safeParseJson(r.device_additional_info), // Adjust field name based on DB model
      }));
    } catch (error) {
      return rejectWithValue(error.message || 'Failed to fetch user history');
    }
  }
);

// Async thunk for fetching all routes (admin)
export const fetchAllHistory = createAsyncThunk(
  'history/fetchAllHistory',
  async (_, { rejectWithValue }) => {
    try {
      const routes = await routeService.getAllRoutes();
       return routes.map(r => ({
        ...r,
        routeData: safeParseJson(r.route),
        deviceInfo: safeParseJson(r.device_additional_info),
      }));
    } catch (error) {
      return rejectWithValue(error.message || 'Failed to fetch all routes');
    }
  }
);

const initialState = {
  userHistory: [],
  allHistory: [],
  userHistoryStatus: 'idle', // 'idle', 'loading', 'succeeded', 'failed'
  allHistoryStatus: 'idle',
  error: null,
};

const historySlice = createSlice({
  name: 'history',
  initialState,
  reducers: {
    resetHistoryError: (state) => {
        state.error = null;
    }
  },
  extraReducers: (builder) => {
    builder
      // User History Fetching
      .addCase(fetchUserHistory.pending, (state) => {
        state.userHistoryStatus = 'loading';
        state.error = null;
      })
      .addCase(fetchUserHistory.fulfilled, (state, action) => {
        state.userHistoryStatus = 'succeeded';
        state.userHistory = action.payload;
      })
      .addCase(fetchUserHistory.rejected, (state, action) => {
        state.userHistoryStatus = 'failed';
        state.error = action.payload;
      })
      // All History Fetching
      .addCase(fetchAllHistory.pending, (state) => {
        state.allHistoryStatus = 'loading';
        state.error = null;
      })
      .addCase(fetchAllHistory.fulfilled, (state, action) => {
        state.allHistoryStatus = 'succeeded';
        state.allHistory = action.payload;
      })
      .addCase(fetchAllHistory.rejected, (state, action) => {
        state.allHistoryStatus = 'failed';
        state.error = action.payload;
      });
  },
});

export const { resetHistoryError } = historySlice.actions;
export default historySlice.reducer;

// ----- End File: src\store\slices\historySlice.js -----

// ----- File: src\store\slices\routeTraceSlice.js -----

// ----- File: src/store/slices/routeTraceSlice.js -----

import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import routeService from '../../services/routeService';
import { v4 as uuidv4 } from 'uuid';

// Helper to create initial trace state
const createInitialTraceState = () => ({
  id: uuidv4(), // Unique ID for this trace section
  sourceIp: '',
  destinationIp: '',
  sourceDg: '',
  destinationDg: '',
  sourceDgStatus: 'idle', // 'idle', 'loading', 'succeeded', 'failed', 'manual'
  destinationDgStatus: 'idle', // 'manual' means user edited it after fetch/fail
  traceStatus: 'idle', // 'idle', 'loading', 'succeeded', 'failed', 'partial_success'
  sourceMacTrace: null, // Expecting format like [{hop: 1, ip: 'mac/ip', name: 'dev', type: 'L2/L3'}, ...] or null
  destinationMacTrace: null, // Expecting format like [{hop: 1, ip: 'mac/ip', name: 'dev', type: 'L2/L3'}, ...] or null
  mainRouteTrace: null, // Expecting format like [{hop: 1, ip: 'x', name: 'y'}, ...]
  error: null, // Can store string or object for more details
});

// --- Async Thunks ---

export const fetchDefaultGateway = createAsyncThunk(
  'routeTrace/fetchDefaultGateway',
  async ({ ip, type, traceId }, { rejectWithValue }) => {
    if (!ip) return rejectWithValue({ message: "IP address is required.", type, traceId });
    try {
      const gateway = await routeService.getDefaultGateway(ip);
      // Assuming gateway is returned directly as a string
      if (!gateway) throw new Error("No gateway found by backend.");
      return { gateway, type, traceId };
    } catch (error) {
      return rejectWithValue({ message: error.message || 'Failed to fetch DG', type, traceId });
    }
  }
);

export const performFullTrace = createAsyncThunk(
  'routeTrace/performFullTrace',
  async ({ traceId, sourceIp, destinationIp, sourceDg, destinationDg }, { rejectWithValue }) => {
    if (!sourceIp || !destinationIp || !sourceDg || !destinationDg) {
        return rejectWithValue({ message: "Source IP, Destination IP, Source DG, and Destination DG are required.", traceId });
    }
    try {
      const results = await Promise.allSettled([
        routeService.getRouteTrace(sourceIp, destinationIp, sourceDg, destinationDg), // Main route first
        routeService.getMacTrace(sourceIp, sourceDg),
        routeService.getMacTrace(destinationIp, destinationDg)
      ]);

      const [mainRouteResult, sourceMacResult, destMacResult] = results;

      const mainRouteTrace = mainRouteResult.status === 'fulfilled' ? mainRouteResult.value : null;
      const sourceMacTrace = sourceMacResult.status === 'fulfilled' ? sourceMacResult.value : null;
      const destinationMacTrace = destMacResult.status === 'fulfilled' ? destMacResult.value : null;

      const errors = results
        .filter(p => p.status === 'rejected')
        .map(p => p.reason.message || 'Unknown error')
        .join('; ');

      // Determine overall status: Assume failed unless main trace succeeds
      let status = 'failed'; // Default to failed
      if (mainRouteResult.status === 'fulfilled') {
          status = errors ? 'partial_success' : 'succeeded';
      }

      if (status === 'failed') {
          // Throw error to be caught by rejectWithValue if the main trace failed fundamentally
          throw new Error(errors || 'Trace failed');
      }

      return {
        traceId,
        mainRouteTrace,
        sourceMacTrace, // Expected to be an array of hops or null
        destinationMacTrace,
        status, // 'succeeded' or 'partial_success'
        error: errors || null // Report partial errors if any
      };

    } catch (error) {
      // Catches error from the try block (fundamental failure) or rejections if not handled above
      return rejectWithValue({ message: error.message || 'Full trace failed', traceId, errorObj: error }); // Pass original error too if needed
    }
  }
);

// --- Slice Definition ---

const initialState = {
  traces: [createInitialTraceState()], // Start with one trace section
};

const routeTraceSlice = createSlice({
  name: 'routeTrace',
  initialState,
  reducers: {
    addTraceSection: (state) => {
       if (state.traces.length < 5) { // Limit comparison sections if needed
         state.traces.push(createInitialTraceState());
       }
    },
    removeTraceSection: (state, action) => {
        const traceIdToRemove = action.payload;
        if (state.traces.length > 1) { // Prevent removing the last one
            state.traces = state.traces.filter(trace => trace.id !== traceIdToRemove);
        }
    },
    updateTraceInput: (state, action) => {
      const { traceId, field, value } = action.payload;
      const trace = state.traces.find(t => t.id === traceId);
      if (trace) {
        trace[field] = value;
        // Reset status and results when inputs change
        trace.traceStatus = 'idle';
        trace.mainRouteTrace = null;
        trace.sourceMacTrace = null;
        trace.destinationMacTrace = null;
        trace.error = null;

        // Mark DG as manually entered if user changes it after auto-fetch/fail
        if (field === 'sourceDg' && trace.sourceDgStatus !== 'loading') trace.sourceDgStatus = 'manual';
        if (field === 'destinationDg' && trace.destinationDgStatus !== 'loading') trace.destinationDgStatus = 'manual';

        // Reset DG status if IP changes
        if (field === 'sourceIp') {
            trace.sourceDg = ''; // Clear old DG if source IP changes
            trace.sourceDgStatus = 'idle';
        }
        if (field === 'destinationIp') {
            trace.destinationDg = ''; // Clear old DG if destination IP changes
            trace.destinationDgStatus = 'idle';
        }
      }
    },
    resetTraceState: (state) => {
        state.traces = [createInitialTraceState()];
    }
  },
  extraReducers: (builder) => {
    builder
      // Default Gateway Fetching
      .addCase(fetchDefaultGateway.pending, (state, action) => {
        const { type, traceId } = action.meta.arg;
        const trace = state.traces.find(t => t.id === traceId);
        if (trace) {
          if (type === 'source') trace.sourceDgStatus = 'loading';
          if (type === 'destination') trace.destinationDgStatus = 'loading';
          trace.error = null;
        }
      })
      .addCase(fetchDefaultGateway.fulfilled, (state, action) => {
        const { gateway, type, traceId } = action.payload;
        const trace = state.traces.find(t => t.id === traceId);
        if (trace) {
          if (type === 'source') {
            trace.sourceDg = gateway;
            trace.sourceDgStatus = 'succeeded';
          }
          if (type === 'destination') {
            trace.destinationDg = gateway;
            trace.destinationDgStatus = 'succeeded';
          }
        }
      })
      .addCase(fetchDefaultGateway.rejected, (state, action) => {
        const { message, type, traceId } = action.payload;
        const trace = state.traces.find(t => t.id === traceId);
         if (trace) {
          if (type === 'source') trace.sourceDgStatus = 'failed';
          if (type === 'destination') trace.destinationDgStatus = 'failed';
           trace.error = `DG Fetch Error (${type}): ${message}`;
        }
      })

      // Full Trace Execution
      .addCase(performFullTrace.pending, (state, action) => {
        const { traceId } = action.meta.arg;


        const trace = state.traces.find(t => t.id === traceId);
        if (trace) {
          trace.traceStatus = 'loading';
          trace.error = null;
          // Clear previous results while loading new ones
          trace.mainRouteTrace = null;
          trace.sourceMacTrace = null;
          trace.destinationMacTrace = null;
        }
      })
      .addCase(performFullTrace.fulfilled, (state, action) => {
        const { traceId, mainRouteTrace, sourceMacTrace, destinationMacTrace, status, error } = action.payload;

        const trace = state.traces.find(t => t.id === traceId);
        if (trace) {
          trace.traceStatus = status; // 'succeeded' or 'partial_success'
          trace.mainRouteTrace = mainRouteTrace;
          trace.sourceMacTrace = sourceMacTrace;
          trace.destinationMacTrace = destinationMacTrace;
          trace.error = error; // Store any partial errors reported
        }
      })
      .addCase(performFullTrace.rejected, (state, action) => {
        const { message, traceId } = action.payload;

        const trace = state.traces.find(t => t.id === traceId);
        if (trace) {
          trace.traceStatus = 'failed';
          trace.error = message; // Store the main error message
           // Results are already cleared in pending or might be null from failed calls
           // Ensure results are explicitly null on failure
           trace.mainRouteTrace = null;
           trace.sourceMacTrace = null;
           trace.destinationMacTrace = null;
        }
      });
  },
});

export const { addTraceSection, removeTraceSection, updateTraceInput, resetTraceState } = routeTraceSlice.actions;
export default routeTraceSlice.reducer;

// ----- End File: src/store/slices/routeTraceSlice.js -----

// ----- End File: src\store\slices\routeTraceSlice.js -----

// ----- File: src\store\store.js -----

import { configureStore } from '@reduxjs/toolkit';
import authReducer from './slices/authSlice';
import routeTraceReducer from './slices/routeTraceSlice';
import historyReducer from './slices/historySlice';

const store = configureStore({
  reducer: {
    auth: authReducer,
    routeTrace: routeTraceReducer,
    history: historyReducer,
  },
  // Middleware is automatically included by configureStore (e.g., thunk)
});

export default store;

// ----- End File: src\store\store.js -----

// ----- File: src\utils\formatters.js -----

import { format } from 'date-fns'; // Using date-fns, install if needed: npm install date-fns

export const formatTimestamp = (timestamp, fmt = 'yyyy-MM-dd HH:mm:ss') => {
  if (!timestamp) return 'N/A';
  try {
    // Assuming timestamp is in a format Date can parse (like ISO 8601)
    const date = new Date(timestamp);
    return format(date, fmt);
  } catch (error) {
    console.error("Error formatting timestamp:", error);
    return timestamp; // Return original if formatting fails
  }
};

// ----- End File: src\utils\formatters.js -----

